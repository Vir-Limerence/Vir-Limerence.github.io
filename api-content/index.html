{"posts":[{"title":"SpringBoot的启动原理、流程和机制","content":"springboot启动原理、启动过程、启动机制的介绍1.启动原理SpringBoot的一个核心特点是自动配置，它会自动配置Spring应用程序基于项目中添加的jar依赖。如果项目中包括spring-boot-starter-web依赖，SpringBoot将会配置应用程序使用Tomcat作为默认服务器，并且将基本的MVC支持加入容器中，这是通过classpath和已经定义的beans来决定配置类的自动应用来实现的，使用的是@EnableAutoConfiguration注解。1.1起步依赖(starters)SpringBoot的起步依赖是一组方便的依赖描述符，你可以在应用程序的pom.xml中添加它们。每一个起步依赖都旨在简化构建配置，提供所需的依赖。这让你在不担心版本冲突的情况下快速开始一个功能完备的开发环境。1.2命令行界面SpringBoot提供一个可选的CLI，用于快速开发和原型制作Spring应用，CLI使用Spring的@*注解进行编码，允许通过Groovy语言快速编写Spring应用。1.3内嵌服务器SpringBoot内置了常见的服务器（如Tomcat、Jetty或Undertow），无需复杂的服务器配置，只需一个简单的main()方法，即可将应用打包为单一的、可执行的JAR文件，这个JAR文件包含了一切必要的依赖、类和资源。1.4外部化配置SpringBoot允许你通过外部配置（如properties文件、YAML文件、环境变量和命令行参数）来管理应用程序的配置。这使得你的应用可以在不同环境中使用相同的代码，而不需要重新构建。1.5监控和管理SpringBootActuator提供了许多生产级的特性，如监控和管理应用程序。它可以通过HTTP或JMX访问应用的内部状态。1.6无代码生成和XML配置SpringBoot被设计为尽可能地减少显式配置。它使用条件注解来评估环境，自动配置Spring容器。SpringBoot应用不需要使用XML配置，尽管可以选择使用XML来定义配置，但默认情况下，这种需求被最小化了。通过以上原理，SpringBoot实现了“约定大于配置”的软件设计范式，极大地简化了基于Spring的应用开发和服务部署。2.启动过程2.1启动入口SpringBoot应用的启动从一个包含main()方法的主类开始。这个主类会使用SpringApplication.run()方法来启动Spring应用。通常，这个类还带有@SpringBootApplication注解，它是一个组合注解，包含了@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。2.2创建SpringApplication对象当调用SpringApplication.run()时，首先会创建一个SpringApplication对象。这个对象负责管理Spring应用的启动和初始化。它会设置一些基础属性，比如是否应该添加命令行属性，是否需要横幅（Banner）等。2.3运行SpringApplication接下来，SpringApplication对象调用其run()方法。这个过程涉及多个重要步骤：初始化应用上下文：根据你选择的web环境类型（如Servlet或Reactive），SpringBoot设置合适的应用上下文（ApplicationContext）。环境准备：在应用上下文准备前，先准备环境（Environment），这包括配置文件、命令行参数、环境变量等的解析。横幅输出：如果启用，SpringBoot的启动过程中会在控制台打印一个横幅。注册应用上下文初始化器和监听器：应用上下文初始化器（ApplicationContextInitializer）和应用事件监听器（ApplicationListener）会被加载和注册，它们可以在上下文的生命周期的不同阶段执行操作。加载Bean定义：通过扫描类路径中的组件和配置类（由@ComponentScan和@Configuration等注解指定）来加载Bean定义。2.4自动配置和Bean的创建自动配置：@EnableAutoConfiguration注解激活了自动配置的魔法，它告诉SpringBoot基于添加到项目中的jar依赖，尝试去猜测并配置你可能需要的Bean。自动配置类会在应用上下文中被条件化地执行。Bean实例化：在所有的配置类和组件被加载之后，Spring容器会根据需要创建和配置Bean实例。2.5运行应用上下文刷新应用上下文：完成所有配置后，应用上下文会被刷新，此时所有的Bean都已注册完毕，且已准备就绪。触发命令行运行器：如果应用中包含CommandLineRunner或ApplicationRunnerBean，它们会在此时执行。2.6应用就绪触发应用就绪事件：最后，一个ApplicationReadyEvent被发布，表明应用已完全启动并准备好接收请求。3.启动过程详解SpringBoot的启动过程从加载包含main()方法的主类开始。这个主类通常使用@SpringBootApplication注解标记，它是一个组合注解，包含了@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。在主类中调用SpringApplication.run()方法，会创建一个SpringApplication对象。这个对象负责管理Spring应用的启动和初始化。SpringApplication对象负责准备Spring应用的环境。这包括读取配置文件、解析命令行参数、收集系统环境变量等。这些环境属性将会被用于配置应用上下文和其他组件。SpringApplication使用环境信息初始化Spring应用上下文（ApplicationContext）。根据应用是Web应用还是非Web应用，SpringBoot会创建对应的应用上下文。应用上下文初始化后，SpringBoot开始加载Bean的定义。它会扫描项目中的组件和配置类（由@ComponentScan和@Configuration注解指定），并将它们注册到应用上下文中。SpringBoot的自动配置机制会根据项目中添加的jar依赖，尝试猜测并配置可能需要的Bean。自动配置类会根据条件进行加载和执行，以确保配置的正确性和合理性。所有配置类和组件被加载后，Spring容器会根据需要创建和配置Bean实例。这些Bean可能是由SpringBoot提供的自动配置，也可能是开发者自定义的Bean。当所有Bean定义加载完毕后，应用上下文会被刷新。在这个阶段，SpringBoot会执行一系列的初始化动作，确保所有Bean都被正确地创建和配置。应用上下文初始化完成后，SpringBoot将应用状态标记为“已启动”。此时，应用已准备就绪，可以处理请求和响应。在应用启动过程中，SpringBoot会触发一系列的生命周期事件，如应用启动事件、应用就绪事件等。开发者可以监听这些事件并执行相应的操作。通过这些步骤，SpringBoot实现了一个简洁而高效的启动过程，使得开发者能够快速启动和运行一个独立的、生产级的应用程序。","link":"https://Vir-Limerence.github.io/post/springboot-de-qi-dong-yuan-li-liu-cheng-he-ji-zhi/","abstract":"springboot启动原理、启动过程、启动机制的介绍1.启动原理SpringBoot的一个核心特点是自动配置，它会自动配置Spring应用程序基于项目中添加的jar依赖。如果项目中包括spring-boot-starter-web依赖，SpringBoot将会配置应用程序使用Tomcat作为默认服务器，并且将基本的MVC支持加入容器中，这是通过classpath和已经定义的beans来决定配置类..."},{"title":"线段树和树状数组","content":"线段树和树状数组1.线段树线段树适用于区间操作较为复杂或者需要处理多个不同类型的区间操作的场景。具体如下：区间求和、区间最值查询区间更新复杂的动态区间操作（区间最大公约数、最小公倍数）支持懒标记的区间更新（更新无需遍历整个区间）代码模板classSegmentTree{//存储线段树的数组privateint[]tree;//存储原始数据的数组privateint[]data;//构造初始化publicSegmentTree(int[]data){this.data=data;this.n=data.length;tree=newint[n*4];build(0,0,n-1);}privatevoidbuild(intnode,intstart,intend){if(start==end){//叶子节点tree[node]=data[start];}else{intmid=(start+end)/2;intleftChild=2*node+1;intrightChild=2*node+2;build(leftChild,start,mid);build(rightChild,mid+1,end);tree[node]=tree[leftChild]+tree[rightChild];//区间和}}privateintquery(intL,intR){returnquery(0,0,n-1,L,R);}privateintquery(intnode,intstart,intend,intL,intR){if(R&lt;start||L&gt;end){return0;}if(L&lt;=start&amp;&amp;end&lt;=R){returntree[node];}intmid=(start+end)/2;intleftChild=2*node+1;intrightChild=2*node+2;intleftSum=query(leftChild,start,mid,L,R);intrightSum=query(rightChild,mid+1,end,L,R);returnleftSum+rightSum;}//单点更新，将data[index]的值更新为valpublicvoidupdate(intindex,intval){update(0,0,n-1,index,val);}privatevoidupdate(intnode,intstart,intend,intindex,intval){if(start==end){data[index]=val;tree[node]=val;}else{intmid=(start+end)/2;intleftChild=2*node+1;intrightChild=2*node+2;if(index&lt;=mid){update(leftChild,start,mid,index,val);}else{update(rightChild,mid+1,end,index,val);}tree[node]=tree[leftChild]+tree[rightChild];//更新区间和}}}2.树状数组树状数组的应用场景多集中在需要快速处理单点更新、区间查询的场景，尤其是在操作相对简单且要求较少的情况下。前缀和查询单点更新+区间查询动态数组操作ClassFenwickTree{privateint[]tree;privateintn;publicFenwickTree(intn){this.n=n;//树状数组从索引1开始，0索引不用tree=newint[n+1];}//单点更新，将index处的值加上valpublicvoidupdate(intindex,intval){while(index&lt;=n){tree[index]+=val;index+=index&amp;-index;//更新父节点}}//前缀和查询[1,index]publicintquery(intindex){intsum=0;while(index&gt;0){sum+=tree[index];index-=index&amp;-index;//访问父节点}returnsum;}//区间和查询[L,R]publicintqueryRange(intL,intR){returnquery(R)-query(L-1);}}","link":"https://Vir-Limerence.github.io/post/xian-duan-shu-he-shu-zhuang-shu-zu/","abstract":"线段树和树状数组1.线段树线段树适用于区间操作较为复杂或者需要处理多个不同类型的区间操作的场景。具体如下：区间求和、区间最值查询区间更新复杂的动态区间操作（区间最大公约数、最小公倍数）支持懒标记的区间更新（更新无需遍历整个区间）代码模板classSegmentTree{//存储线段树的数组privateint[]tree;//存储原始数据的数组privateint[]data;//构造初始化pub..."},{"title":"手写HashMap","content":"手写HashMap1.定义HashMap的存储单元NodeclassNode&lt;K,V&gt;{finalKkey;Vvalue;Node&lt;K,V&gt;next;Node(Kkey,Vvalue){this.key=key;this.value=value;}}2.构造器初始化和默认参数//定义一个默认的初始容量privatestaticfinalintDEFAULT_CAPACITY=16;privatestaticfinalfloatLOAD_FACTOR=0.75f;//构造参数privateNode&lt;K,V&gt;[]table;//哈希表privateintsize;//当前哈希表中元素个数privateintcapacity;//当前哈希表的容量//构造函数publicSimpleHashMap(){this.capacity=DEFAULT_CAPACITY;this.table=newNode[capacity];this.size=0;}3.计算索引privateinthash(Kkey){returnkey==null?0:Objects.hashCode(key)&amp;(capacity-1);}4.插入/更新putpublicvoidput(Kkey,Vvalue){inthash=hash(key);Node&lt;K,V&gt;node=table[hash];while(node!=null){if(Objects.equals(node.key,key)){//如果找到key，更新值node.value=value;return;}node=node.next;}//否则，将新的节点插入链表头Node&lt;K,V&gt;newNode=newNode&lt;&gt;(key,value);//头插法newNode.next=table[hash];table[hash]=newNode;size++;//插入元素后，判断是否需要扩容if(size&gt;=capacity*LOAD_FACTOR){resize();}}5.获取getpublicVget(Kkey){inthash=hash(key);Node&lt;K,V&gt;node=table[hash];//遍历链表，寻找keywhile(node!=null){if(Objects.equals(node.key,key)){//返回找到的值returnnode.value;}//如果没有找到，返回nullnode=node.next;}returnnull;}6.删除removepublicVremove(Kkey){inthash=hash(key);Node&lt;K,V&gt;node=table[hash];Node&lt;K,V&gt;prev=null;//遍历链表，找到要删除的节点while(node!=null){if(Objects.equals(node.key,key)){if(prev==null){//如果要删除的节点是头节点table[hash]=node.next;}else{prev.next=node.next;}size--;returnnode.value;}prev=node;node=node.next;}returnnull;}7.扩展哈希表的容量resizepublicvoidresize(){capacity=capacity*2;Node&lt;K,V&gt;[]newTable=newNode[capacity];for(Node&lt;K,V&gt;node:table){while(node!=null){Node&lt;K,V&gt;next=node.next;inthash=Objects.hashCode(node.key)&amp;(capacity-1);node.next=newTable[hash];newTable[hash]=node;node=next;}}table=newTable;}8.完整代码importjava.util.Objects;classSimpleHashMap&lt;K,V&gt;{//定义一个默认的初始容量privatestaticfinalintDEFAULT_CAPACITY=16;//定义装载因子，用于扩展哈希表的大小privatestaticfinalfloatLOAD_FACTOR=0.75f;//哈希表中的节点类classNode&lt;K,V&gt;{finalKkey;Vvalue;Node&lt;K,V&gt;next;Node(Kkey,Vvalue){this.key=key;this.value=value;}}privateNode&lt;K,V&gt;[]table;//哈希表privateintsize;//当前哈希表中元素个数privateintcapacity;//当前哈希表的容量//构造函数publicSimpleHashMap(){this.capacity=DEFAULT_CAPACITY;this.table=newNode[capacity];this.size=0;}//获取哈希值privateinthash(Kkey){returnkey==null?0:Objects.hashCode(key)&amp;(capacity-1);}//插入或更新key-value对publicvoidput(Kkey,Vvalue){inthash=hash(key);Node&lt;K,V&gt;node=table[hash];//遍历链表，检查是否已经存在该keywhile(node!=null){if(Objects.equals(node.key,key)){node.value=value;//如果找到key，更新值return;}node=node.next;}//否则，将新节点插入链表头Node&lt;K,V&gt;newNode=newNode&lt;&gt;(key,value);newNode.next=table[hash];table[hash]=newNode;size++;//检查是否需要扩容if(size&gt;=capacity*LOAD_FACTOR){resize();}}//获取key对应的valuepublicVget(Kkey){inthash=hash(key);Node&lt;K,V&gt;node=table[hash];//遍历链表，寻找keywhile(node!=null){if(Objects.equals(node.key,key)){returnnode.value;//返回找到的值}node=node.next;}returnnull;//如果未找到，返回null}//删除key对应的节点publicVremove(Kkey){inthash=hash(key);Node&lt;K,V&gt;node=table[hash];Node&lt;K,V&gt;prev=null;//遍历链表，寻找要删除的节点while(node!=null){if(Objects.equals(node.key,key)){if(prev==null){//如果要删除的是链表头节点table[hash]=node.next;}else{prev.next=node.next;}size--;returnnode.value;//返回被删除的值}prev=node;node=node.next;}returnnull;//未找到返回null}//扩展哈希表的容量privatevoidresize(){capacity=capacity*2;Node&lt;K,V&gt;[]newTable=newNode[capacity];//重新散列所有元素到新表for(Node&lt;K,V&gt;node:table){while(node!=null){Node&lt;K,V&gt;next=node.next;inthash=Objects.hashCode(node.key)&amp;(capacity-1);node.next=newTable[hash];newTable[hash]=node;node=next;}}table=newTable;}//获取当前哈希表中的元素个数publicintsize(){returnsize;}//检查哈希表是否为空publicbooleanisEmpty(){returnsize==0;}publicstaticvoidmain(String[]args){SimpleHashMap&lt;String,Integer&gt;map=newSimpleHashMap&lt;&gt;();map.put(&quot;one&quot;,1);map.put(&quot;two&quot;,2);map.put(&quot;three&quot;,3);System.out.println(&quot;Get'two':&quot;+map.get(&quot;two&quot;));//输出2System.out.println(&quot;Remove'two':&quot;+map.remove(&quot;two&quot;));//删除并输出2System.out.println(&quot;Get'two'afterremoval:&quot;+map.get(&quot;two&quot;));//输出nullSystem.out.println(&quot;Mapsize:&quot;+map.size());//输出2}}","link":"https://Vir-Limerence.github.io/post/shou-xie-hashmap/","abstract":"手写HashMap1.定义HashMap的存储单元NodeclassNode&lt;K,V&gt;{finalKkey;Vvalue;Node&lt;K,V&gt;next;Node(Kkey,Vvalue){this.key=key;this.value=value;}}2.构造器初始化和默认参数//定义一个默认的初始容量privatestaticfinalintDEFAULT_CAPACITY..."},{"title":"线程池相关","content":"交替打印数字利用volatile同步publicclassVolatilePrint{//全局变量i，用于计数privatestaticinti=1;//是否是奇数的标志，用volatile保证可见性privatestaticvolatilebooleanisOdd=true;publicstaticvoidmain(String[]args){//线程A，负责打印奇数newThread(()-&gt;{while(i&lt;=100){if(isOdd){//打印奇数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);//打印完奇数后，将标志设为falseisOdd=false;}}},&quot;Thread-A&quot;).start();//线程B，负责打印偶数newThread(()-&gt;{while(i&lt;=100){if(!isOdd){//打印偶数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);//打印完偶数后，将标志设为trueisOdd=true;}}},&quot;Thread-B&quot;).start();}}利用wait()/notify()同步publicclassWaitNotify{//全局变量i，用于计数publicstaticinti=1;//锁对象，用于线程同步publicstaticfinalObjectlock=newObject();publicstaticvoidmain(String[]args){//线程A，负责打印奇数newThread(()-&gt;{synchronized(lock){while(i&lt;=100){if(i%2==1){//打印奇数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);//唤醒其他线程lock.notify();}else{try{//当前线程等待，释放锁lock.wait();}catch(InterruptedExceptione){e.printStackTrace();}}}}},&quot;Thread-A&quot;).start();//线程B，负责打印偶数newThread(()-&gt;{synchronized(lock){while(i&lt;=100){if(i%2==0){//打印偶数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);//唤醒其他线程lock.notify();}else{try{//当前线程等待，释放锁lock.wait();}catch(InterruptedExceptione){e.printStackTrace();}}}}},&quot;Thread-B&quot;).start();}}使用Semaphore信号量importjava.util.concurrent.Semaphore;publicclassSemaphoreExample{//全局变量i，用于计数privatestaticinti=1;//奇数信号量，初始许可数为1privatestaticSemaphoresemaphoreOdd=newSemaphore(1);//偶数信号量，初始许可数为0privatestaticSemaphoresemaphoreEven=newSemaphore(0);publicstaticvoidmain(String[]args){//线程A，负责打印奇数newThread(()-&gt;{while(i&lt;=100){try{//获取奇数信号量，获取后许可数变为0semaphoreOdd.acquire();//打印奇数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);//释放偶数信号量，许可数加1semaphoreEven.release();}catch(InterruptedExceptione){e.printStackTrace();}}},&quot;Thread-A&quot;).start();//线程B，负责打印偶数newThread(()-&gt;{while(i&lt;=100){try{//获取偶数信号量，获取后许可数变为0semaphoreEven.acquire();//打印偶数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);//释放奇数信号量，许可数加1semaphoreOdd.release();}catch(InterruptedExceptione){e.printStackTrace();}}},&quot;Thread-B&quot;).start();}}使用Condition和Lockimportjava.util.concurrent.locks.Condition;importjava.util.concurrent.locks.Lock;importjava.util.concurrent.locks.ReentrantLock;publicclassConditionExample{//全局变量i，用于计数privatestaticinti=1;//可重入锁privatestaticfinalLocklock=newReentrantLock();//奇数条件变量privatestaticfinalConditionconditionOdd=lock.newCondition();//偶数条件变量privatestaticfinalConditionconditionEven=lock.newCondition();publicstaticvoidmain(String[]args){//线程A，负责打印奇数newThread(()-&gt;{lock.lock();//加锁try{while(i&lt;=100){if(i%2==1){//打印奇数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);//唤醒偶数条件变量等待的线程conditionEven.signal();}else{//当前线程等待在奇数条件变量上，释放锁conditionOdd.await();}}//结束时，唤醒对方线程，防止阻塞conditionEven.signal();}catch(InterruptedExceptione){e.printStackTrace();}finally{lock.unlock();//释放锁}},&quot;Thread-A&quot;).start();//线程B，负责打印偶数newThread(()-&gt;{lock.lock();//加锁try{while(i&lt;=100){if(i%2==0){//打印偶数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);//唤醒奇数条件变量等待的线程conditionOdd.signal();}else{//当前线程等待在偶数条件变量上，释放锁conditionEven.await();}}//结束时，唤醒对方线程，防止阻塞conditionOdd.signal();}catch(InterruptedExceptione){e.printStackTrace();}finally{lock.unlock();//释放锁}},&quot;Thread-B&quot;).start();}}使用AQSimportjava.util.concurrent.locks.AbstractQueuedSynchronizer;publicclassAQSSyncExample{//全局变量i，用于计数privatestaticinti=1;//自定义AQS类，负责奇偶数线程的同步privatestaticclassMyAQSextendsAbstractQueuedSynchronizer{publicMyAQS(){//初始状态为1，表示奇数线程先执行setState(1);}//打印奇数publicvoidprintOdd(RunnableprintOdd){acquire(1);//获取状态为1的许可printOdd.run();//执行打印操作release(0);//释放状态为0的许可}//打印偶数publicvoidprintEven(RunnableprintEven){acquire(0);//获取状态为0的许可printEven.run();//执行打印操作release(1);//释放状态为1的许可}@OverrideprotectedbooleantryAcquire(intarg){returngetState()==arg;//获取许可时，判断当前状态是否匹配}@OverrideprotectedbooleantryRelease(intarg){setState(arg);//释放许可时，设置新的状态returntrue;}}publicstaticvoidmain(String[]args){MyAQSaqs=newMyAQS();//线程A，负责打印奇数newThread(()-&gt;{while(i&lt;=100){aqs.printOdd(()-&gt;{//打印奇数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);});}},&quot;Thread-A&quot;).start();//线程B，负责打印偶数newThread(()-&gt;{while(i&lt;=100){aqs.printEven(()-&gt;{//打印偶数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);});}},&quot;Thread-B&quot;).start();}}使用LockSupportimportjava.util.concurrent.locks.LockSupport;publicclassLockSupportExample{//全局变量i，用于计数privatestaticinti=1;//线程引用，用于唤醒对方线程privatestaticThreadthreadA,threadB;publicstaticvoidmain(String[]args){//线程A，负责打印奇数threadA=newThread(()-&gt;{while(i&lt;=100){if(i%2==1){//打印奇数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);//唤醒线程BLockSupport.unpark(threadB);//当前线程等待LockSupport.park();}}//结束时，防止对方线程被永远阻塞LockSupport.unpark(threadB);},&quot;Thread-A&quot;);//线程B，负责打印偶数threadB=newThread(()-&gt;{while(i&lt;=100){//当前线程等待LockSupport.park();if(i%2==0){//打印偶数System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i++);//唤醒线程ALockSupport.unpark(threadA);}}},&quot;Thread-B&quot;);//启动线程threadA.start();threadB.start();}}","link":"https://Vir-Limerence.github.io/post/xian-cheng-chi-xiang-guan/","abstract":"交替打印数字利用volatile同步publicclassVolatilePrint{//全局变量i，用于计数privatestaticinti=1;//是否是奇数的标志，用volatile保证可见性privatestaticvolatilebooleanisOdd=true;publicstaticvoidmain(String[]args){//线程A，负责打印奇数newThread(()-&..."},{"title":"八大排序算法","content":"插入排序直接插入排序把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。时间复杂度：O(N^2)空间复杂度：O(1)稳定publicstaticvoidinsertionSort(int[]arr){intn=arr.length;for(inti=1;i&lt;n;++i){intkey=arr[i];intj=i-1;//将选中的元素与已排序的元素进行比较，并将较大的元素向后移动while(j&gt;=0&amp;&amp;arr[j]&gt;key){arr[j+1]=arr[j];j=j-1;}//将选中的元素插入到正确的位置arr[j+1]=key;}}希尔排序希尔排序在直接排序之前，进行预排列，将某些极端数据更快的排列到数列前面，构成一个接近排列好的序列，最后再进行一次直接插入排序。预排列的原理也是插入排列，只不过这里的将数组分成了gap组，分别对每一个小组进行插入排序。希尔排序是对直接插入排序的优化，当gap&gt;1时都是预排序，目的是让数组更接近于有序。当gap==1时，数组已经接近有序的了，这样就会很快。时间复杂度：O(N*logN)空间复杂度O(1)不稳定publicstaticvoidshellSort(int[]arr){intn=arr.length;for(intgap=n/2;gap&gt;0;gap/=2){for(inti=gap;i&lt;n;i+=1){intkey=arr[i];intj=i;//将arr[i]插入到前面已经排好的序列中while(j&gt;=gap&amp;&amp;arr[j-gap]&gt;key){arr[j]=arr[j-gap];j-=gap;}arr[j]=key;}}}选择排序直接选择排序每一次遍历待排序的数据元素从中选出最小（或最大）的一个元素，存放在序列的起始（或者末尾）位置，直到全部待排序的数据元素排完。时间复杂度：O(N^2)空间复杂度：O(1)不稳定publicstaticvoidselectionSort(int[]arr){intn=arr.length;//外层循环控制排序的轮数for(inti=0;i&lt;n-1;i++){//假设当前位置是最小值intminIndex=i;//内层循环用于找到最小值的索引for(intj=i+1;j&lt;n;j++){if(arr[j]&lt;arr[minIndex]){minIndex=j;//更新最小值的索引}}//将找到的最小值和当前位置的值交换if(minIndex!=i){inttemp=arr[i];arr[i]=arr[minIndex];arr[minIndex]=temp;}}}这里我们还可以对直接选择排序做一个优化：每次遍历待排序数据找出最大和最小的数据，分别排列到序列起始和末尾。publicstaticvoidoptimizedSelectionSort(int[]arr){intn=arr.length;//外层循环控制排序的轮数for(inti=0;i&lt;n/2;i++){intminIndex=i;intmaxIndex=i;//内层循环用于找到最小值和最大值的索引for(intj=i+1;j&lt;n-i;j++){if(arr[j]&lt;arr[minIndex]){minIndex=j;//更新最小值的索引}if(arr[j]&gt;arr[maxIndex]){maxIndex=j;//更新最大值的索引}}//将找到的最小值和当前位置的值交换if(minIndex!=i){inttemp=arr[i];arr[i]=arr[minIndex];arr[minIndex]=temp;}//将找到的最大值和末尾位置的值交换if(maxIndex!=n-i-1){temp=arr[n-i-1];arr[n-i-1]=arr[maxIndex];arr[maxIndex]=temp;}}}堆排序堆排序是指利用堆（数据结构）进行选择数据的一种排序算法。基本思想：原则：先将原数组建成堆，需要注意的是升序需要建大堆，降序需要建立小堆建堆：一个根节点与子节点数据如果不符合大堆结构，那么则对根节点数据进行向下调整，而向下调整的前提是左右子树也符合大堆结构,所以从堆尾数据的根节点位置开始向下调整建大堆排序：大堆堆顶数据一定是待排数据中最大的，将堆顶数据与堆尾数据交换,交换后将除堆尾数据看成新堆，对现堆顶数据进行向下调整成大堆,以此循环直至排列完毕向下调整：找到子节点中的较大数据节点比较，如果父节点数据比子节点小则交换，直到不符合则停止向下交换，此时再次构成了一个大堆结构时间复杂度：O(N*logN)空间复杂度O(1)不稳定//构建最大堆publicstaticvoidbuildMaxHeap(int[]arr,intn){for(inti=n/2-1;i&gt;=0;i--){heapify(arr,n,i);}}//堆调整publicstaticvoidheapify(int[]arr,intn,inti){intlargest=i;//初始化最大值为根intleft=2*i+1;//左子节点intright=2*i+2;//右子节点//如果左子节点比根大，则更新最大值if(left&lt;n&amp;&amp;arr[left]&gt;arr[largest]){largest=left;}//如果右子节点比最大值还大，则更新最大值if(right&lt;n&amp;&amp;arr[right]&gt;arr[largest]){largest=right;}//如果最大值不是根，交换它们并继续堆调整if(largest!=i){intswap=arr[i];arr[i]=arr[largest];arr[largest]=swap;//递归地堆调整子树heapify(arr,n,largest);}}//堆排序publicstaticvoidheapSort(int[]arr){intn=arr.length;buildMaxHeap(arr,n);//一个个从堆顶取出元素for(inti=n-1;i&gt;=0;i--){//将当前的根（最大值）与最后一个元素交换inttemp=arr[0];arr[0]=arr[i];arr[i]=temp;//堆调整剩下的元素heapify(arr,i,0);}}交换排序冒泡排序每次遍历待排序数组，对相邻数据进行比较，不符合排序要求则交换时间复杂度：O(N^2)空间复杂度：O(1)稳定publicstaticvoidbubbleSort(int[]arr){intn=arr.length;for(inti=0;i&lt;n-1;i++){for(intj=0;j&lt;n-i-1;j++){//遍历数组，比较相邻元素，如果顺序错误就交换if(arr[j]&gt;arr[j+1]){//交换arr[j]和arr[j+1]inttemp=arr[j];arr[j]=arr[j+1];arr[j+1]=temp;}}}}快排任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列。左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值。时间复杂度：O(N*logN)空间复杂度：O(logN)不稳定/*left:数组左边界right：数组右边界*///递归版本publicvoidquickSort(int[]arr,intleft,intright){if(left&lt;right){intpos=partition(arr,left,right);quickSort(arr,left,pos-1);quickSort(arr,pos+1,right);}}//非递归版本publicstaticvoidquickSort(int[]arr,intlow,inthigh){Stack&lt;Integer&gt;stack=newStack&lt;&gt;();stack.push(low);stack.push(high);while(!stack.isEmpty()){//弹出高和低索引high=stack.pop();low=stack.pop();//找到分区点intpartitionIndex=partition(arr,low,high);//如果分区点的左边有元素，那么将其推入栈中if(partitionIndex&gt;low){stack.push(low);stack.push(partitionIndex-1);}//如果分区点的右边有元素，那么将其推入栈中if(partitionIndex&lt;high){stack.push(partitionIndex+1);stack.push(high);}}}publicintpartition(int[]arr,intleft,intright){intbase=arr[left];while(left&lt;right){//从右向左找，比base大，right--while(left&lt;right&amp;&amp;arr[right]&gt;=base){right--;}arr[left]=arr[right];//从左向右找，比base小，left++while(left&lt;right&amp;&amp;arr[left]&lt;=base){left++;}arr[right]=arr[left];}arr[left]=base;returnleft;}归并排序归并排序归并排序是建立在归并操作上的一种有效的排序算法，采用分治法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。//主归并排序函数publicstaticvoidmergeSort(int[]array,intleft,intright){if(left&lt;right){intmiddle=(left+right)/2;//递归地对左半部分排序mergeSort(array,left,middle);//递归地对右半部分排序mergeSort(array,middle+1,right);//合并两个已排序的子数组merge(array,left,middle,right);}}//合并两个已排序的子数组publicstaticvoidmerge(int[]array,intleft,intmiddle,intright){//计算子数组的大小intn1=middle-left+1;intn2=right-middle;//创建临时数组int[]leftArray=newint[n1];int[]rightArray=newint[n2];//拷贝数据到临时数组System.arraycopy(array,left,leftArray,0,n1);System.arraycopy(array,middle+1,rightArray,0,n2);//合并临时数组到原数组inti=0,j=0;intk=left;while(i&lt;n1&amp;&amp;j&lt;n2){if(leftArray[i]&lt;=rightArray[j]){array[k++]=leftArray[i++];}else{array[k++]=rightArray[j++];}}//拷贝剩余的元素while(i&lt;n1){array[k++]=leftArray[i++];}while(j&lt;n2){array[k++]=rightArray[j++];}}计数排序计数排序是一种非比较排序，又称为鸽巢原理，是对哈希直接定址法的变形应用。在排序数组中找到最大最小的数据，算出对应范围并创建对应长度个数组用来计数，遍历排序数组，根据每个出现的数据值与计数数组下标构建的相对映射关系进行统计数据出现次数，最后将统计的出的数据按次序赋值给原数组。//计数排序函数publicstaticvoidcountingSort(int[]array){if(array.length==0)return;//在单次遍历中找到最大值和最小值intmax=array[0];intmin=array[0];for(intnum:array){if(num&gt;max){max=num;}if(num&lt;min){min=num;}}//创建计数数组int[]count=newint[max-min+1];//统计每个元素的出现次数for(intnum:array){count[num-min]++;}//根据计数数组填充排序后的结果数组intindex=0;for(inti=0;i&lt;count.length;i++){while(count[i]&gt;0){array[index++]=i+min;count[i]--;}}}桶排序桶排序（BucketSort）是一种基于分布的排序算法，适用于数据分布比较均匀的情况。它将数据分到若干个桶中，然后对每个桶内的数据进行排序，最后将桶中的数据合并。//桶排序函数publicstaticvoidbucketSort(int[]array){if(array.length==0)return;//1.找到数据范围intmin=array[0];intmax=array[0];for(intnum:array){if(num&lt;min)min=num;if(num&gt;max)max=num;}//2.创建桶intbucketCount=(max-min)/array.length+1;List&lt;Integer&gt;[]buckets=newArrayList[bucketCount];for(inti=0;i&lt;bucketCount;i++){buckets[i]=newArrayList&lt;&gt;();}//3.将数据分配到桶中for(intnum:array){intbucketIndex=(num-min)/array.length;buckets[bucketIndex].add(num);}//4.对每个桶内的数据进行排序for(List&lt;Integer&gt;bucket:buckets){Collections.sort(bucket);}//5.合并桶中的数据intindex=0;for(List&lt;Integer&gt;bucket:buckets){for(intnum:bucket){array[index++]=num;}}}性能比较参考链接：https://www.nowcoder.com/discuss/353159614696988672","link":"https://Vir-Limerence.github.io/post/ba-da-pai-xu-suan-fa/","abstract":"插入排序直接插入排序把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。时间复杂度：O(N^2)空间复杂度：O(1)稳定publicstaticvoidinsertionSort(int[]arr){intn=arr.length;for(inti=1;i&lt;n;++i){intkey=arr[i];intj=i-1;//将选中..."},{"title":"单例模式","content":"饿汉式单例饿汉式单例在类加载时就创建实例，因此是线程安全的。publicclassEagerSingleton{privatestaticfinalEagerSingletonINSTANCE=newEagerSingleton();privateEagerSingleton(){//私有构造器}publicstaticEagerSingletongetInstance(){returnINSTANCE;}}懒汉式单例懒汉式单例在第一次调用getInstance方法时创建实例。这种方式不是线程安全的。在多线程环境下，如果多个线程同时访问getInstance方法并且instance为null，那么多个线程可能会同时通过if(instance==null)这个检查，导致多个线程同时创建实例，这就违反了单例模式的初衷，导致创建了多个实例。publicclassLazySingleton{privatestaticLazySingletoninstance;privateLazySingleton(){//私有构造器}//多线程下，由于多个线程访问publicstaticLazySingletongetInstance(){if(instance==null){instance=newLazySingleton();}returninstance;}}线程安全的懒汉式单例通过同步getInstance方法来确保线程安全，但这种方式性能较差，因为每次访问都需要同步。publicclassSynchronizedLazySingleton{privatestaticSynchronizedLazySingletoninstance;privateSynchronizedLazySingleton(){//私有构造器}publicstaticsynchronizedSynchronizedLazySingletongetInstance(){if(instance==null){instance=newSynchronizedLazySingleton();}returninstance;}}双重检查锁使用双重检查锁机制来确保线程安全，同时提高性能。publicclassDoubleCheckedLockingSingleton{//使用volatile关键字privatestaticvolatileDoubleCheckedLockingSingletoninstance;privateDoubleCheckedLockingSingleton(){//私有构造器}publicstaticDoubleCheckedLockingSingletongetInstance(){if(instance==null){synchronized(DoubleCheckedLockingSingleton.class){if(instance==null){instance=newDoubleCheckedLockingSingleton();}}}returninstance;}}静态内部类Java虚拟机在加载外部类时，并不会立即加载静态内部类，只有在第一次访问静态内部类的成员时，才会加载该内部类。由于类加载过程是线程安全的，JVM会保证一个类的&lt;clinit&gt;()方法在多线程环境下被正确地加锁和同步。publicclassBillPughSingle{privateBillPughSingleton(){//私有构造器}//使用静态内部类privatestaticclassSingletonHelper{privatestaticfinalBillPughSingletonINSTANCE=newBillPughSingleton();}publicstaticBillPughSingletongetInstance(){returnSingletonHelper.INSTANCE;}}","link":"https://Vir-Limerence.github.io/post/dan-li-mo-shi/","abstract":"饿汉式单例饿汉式单例在类加载时就创建实例，因此是线程安全的。publicclassEagerSingleton{privatestaticfinalEagerSingletonINSTANCE=newEagerSingleton();privateEagerSingleton(){//私有构造器}publicstaticEagerSingletongetInstance(){returnINSTA..."},{"title":"37. Java序列化","content":"Java提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对他进行反序列化，也就是说，对象的类型信息，对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是java虚拟机（JVM)独立的，也就是说在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。类ObjectInputStream和ObjectOutputStream是高层次的数据流，它们包含反序列化和序列化对象的方法。ObjectOutputStream类包含很多写方法来写各种数据类型，但是一个特别的方法例外：publicfinalvoidwriteObject(Objectx)throwsIOException上面的方法序列化一个对象，并将它发送到输出流。相似的ObjectInputStream类包含如下反序列化一个对象的方法：publicfinalObjectreadObject()throwsIOException,ClassNotFoundException该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。","link":"https://Vir-Limerence.github.io/post/37-java-xu-lie-hua/","abstract":"Java提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对他进行反序列化，也就是说，对象的类型信息，对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是java虚拟机（JVM)独立的，也就是说在一个平台上序列化的对象可以在另一个完全..."},{"title":"36. Java泛型","content":"Java泛型是jdk5引入的一个新特性，泛型提供了编译时类型安全检测机制，允许程序员在编译时检测到非法的类型，泛型的本质是参数化类型，也就是说操作的数据类型被指定为一个参数。假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？答案是可以使用Java泛型。使用Java泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。泛型方法泛型方法在调用时可以接收不同类型的参数，根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。定义泛型方法的规则：所有泛型方法声明都有一个类型参数声明部分（由尖括号分割）,该类型参数声明部分在方法返回类型之前每一个参数类型声明部分包含一个或多个类型参数，参数间使用逗号分隔。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。泛型方法体的声明和其它方法一样。注意类型参数只能代表引用类型参数，不能是原始类型（像int、double、char等）。java中泛型标记符：E-Element(在集合中使用，因为集合中存放的是元素)T-Type（Java类）K-Key（键）V-Value（值）N-Number（数值类型）？-表示不确定的java类型下面给出一个示例，演示使用泛型方法打印不同类型的数组.publicclassGenericMethodTest{//定义泛型方法printArraypublicstatic&lt;E&gt;voidprintArray(E[]inputArray){//输出数组元素for(Eelement:inputArray){System.out.printf(&quot;%s&quot;,element);}System.out.println();}publicstaticvoidmain(Stringargs[]){//创建不同类型数组：Integer,Double和CharacterInteger[]intArray={1,2,3,4,5};Double[]doubleArray={1.1,2.2,3.3,4.4};Character[]charArray={'H','E','L','L','O'};System.out.println(&quot;整型数组元素为:&quot;);printArray(intArray);//传递一个整型数组System.out.println(&quot;\\n双精度型数组元素为:&quot;);printArray(doubleArray);//传递一个双精度型数组System.out.println(&quot;\\n字符型数组元素为:&quot;);printArray(charArray);//传递一个字符型数组}}有界的类型参数：声明有界的类型参数，首先列出类型参数的名称，然后跟上extends关键字，后面紧跟它的上界publicclassMaximumTest{//比较三个值并返回最大值publicstatic&lt;TextendsComparable&lt;T&gt;&gt;Tmaximum(Tx,Ty,Tz){Tmax=x;//假设x是初始最大值if(y.compareTo(max)&gt;0){max=y;//y更大}if(z.compareTo(max)&gt;0){max=z;//现在z更大}returnmax;//返回最大对象}publicstaticvoidmain(Stringargs[]){System.out.printf(&quot;%d,%d和%d中最大的数为%d\\n\\n&quot;,3,4,5,maximum(3,4,5));System.out.printf(&quot;%.1f,%.1f和%.1f中最大的数为%.1f\\n\\n&quot;,6.6,8.8,7.7,maximum(6.6,8.8,7.7));System.out.printf(&quot;%s,%s和%s中最大的数为%s\\n&quot;,&quot;pear&quot;,&quot;apple&quot;,&quot;orange&quot;,maximum(&quot;pear&quot;,&quot;apple&quot;,&quot;orange&quot;));}}泛型类泛型类和非泛型类的声明类似，在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。publicclassBox&lt;T&gt;{privateTt;publicvoidadd(Tt){this.t=t;}publicTget(){returnt;}publicstaticvoidmain(String[]args){Box&lt;Integer&gt;integerBox=newBox&lt;Integer&gt;();Box&lt;String&gt;stringBox=newBox&lt;String&gt;();integerBox.add(newInteger(10));stringBox.add(newString(&quot;菜鸟教程&quot;));System.out.printf(&quot;整型值为:%d\\n\\n&quot;,integerBox.get());System.out.printf(&quot;字符串为:%s\\n&quot;,stringBox.get());}}类型通配符1、类型通配符一般是使用?代替具体的类型参数。例如List&lt;?&gt;在逻辑上是List&lt;String&gt;,List&lt;Integer&gt;等所有List&lt;具体类型实参&gt;的父类。publicstaticvoidgetData(List&lt;?&gt;data){System.out.println(&quot;data:&quot;+data.get(0));}2、类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。publicstaticvoidgetUperNumber(List&lt;?extendsNumber&gt;data){System.out.println(&quot;data:&quot;+data.get(0));}3、类型通配符下限通过形如List&lt;?superNumber&gt;来定义，表示类型只能接受Number及其上层父类类型，如Object类型的实例。","link":"https://Vir-Limerence.github.io/post/36-java-fan-xing/","abstract":"Java泛型是jdk5引入的一个新特性，泛型提供了编译时类型安全检测机制，允许程序员在编译时检测到非法的类型，泛型的本质是参数化类型，也就是说操作的数据类型被指定为一个参数。假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？答案是可以使用Java泛型。使用Java泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法..."},{"title":"35. Java Object类","content":"java的Obejct类是所有类的父类，也就是说java的所有类都继承了Object类，子类可以使用Object的方法。Object位于java.lang包中，编译时会自动导入，创建一个类，如果没有明确继承一个父类，那么它会自动继承Object类，成为Object的子类.Object类可以显式继承，也可以隐式继承//显式继承publicclassRunoobextendsObject{}//隐式继承publicclassRunoob{}类的构造函数序号构造方法&amp;描述1**Object()**构造一个新对象。类的方法序号方法&amp;描述1protectedObjectclone()创建并返回一个对象的拷贝2booleanequals(Objectobj)比较两个对象是否相等3protectedvoidfinalize()当GC(垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。4ClassgetClass()获取对象的运行时对象的类5inthashCode()获取对象的hash值6voidnotify()唤醒在该对象上等待的某个线程7voidnotifyAll()唤醒在该对象上等待的所有线程8StringtoString()返回对象的字符串表示形式9voidwait()让当前线程进入等待状态。直到其他线程调用此对象的notify()方法或notifyAll()方法。10voidwait(longtimeout)让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者超过参数设置的timeout超时时间。11voidwait(longtimeout,intnanos)与wait(longtimeout)方法类似，多了一个nanos参数，这个参数表示额外时间（以纳秒为单位，范围是0-999999）。所以超时的时间还需要加上nanos纳秒。。","link":"https://Vir-Limerence.github.io/post/35-java-object-lei/","abstract":"java的Obejct类是所有类的父类，也就是说java的所有类都继承了Object类，子类可以使用Object的方法。Object位于java.lang包中，编译时会自动导入，创建一个类，如果没有明确继承一个父类，那么它会自动继承Object类，成为Object的子类.Object类可以显式继承，也可以隐式继承//显式继承publicclassRunoobextendsObject{}//隐式继..."},{"title":"34. Java Iterator(迭代器)","content":"Java迭代器是java集合框架中的一种机制，提供了一种在不暴露集合内部实现的情况下遍历集合元素的方法.Java迭代器不是一个集合，是用于访问集合的方法，可用于迭代ArrayList和HashSet等集合。Iterator是java迭代器最简单的实现，ListIterator是CollectionAPI中的接口，它扩展了Iterator接口。迭代器it的三个基本操作是next、hasNext和remove。调用it.next()会返回迭代器的下一个元素，并且更新迭代器的状态。调用it.hasNext()用于检测集合中是否还有元素。调用it.remove()将迭代器返回的元素删除。Iterator类位于java.util包中，使用前需要引入它，语法格式如下：importjava.util.Iterator;获取迭代器集合获取迭代器可以使用iterator方法//创建集合ArrayList&lt;String&gt;sites=newArrayList&lt;String&gt;();sites.add(&quot;Google&quot;);sites.add(&quot;Runoob&quot;);sites.add(&quot;Taobao&quot;);sites.add(&quot;Zhihu&quot;);//获取迭代器Iterator&lt;String&gt;it=sites.iterator();//输出集合中的第一个元素System.out.println(it.next());循环集合元素让迭代器逐个返回集合中所有元素最简单的方法是使用while循环while(it.hasNext()){System.out.println(it.next());}删除元素使用remove方法可以删除集合中的元素it.remove();while(it.hasNext()){Integeri=it.next();if(i&lt;10){it.remove();//删除小于10的元素}}java迭代器是一种单向遍历机制，只能从前往后遍历集合中的元素，不能往回遍历。同时，在使用迭代器遍历集合时，不能够直接修改集合中的元素，而是使用迭代器的remov方法来删除当前元素.","link":"https://Vir-Limerence.github.io/post/34-java-iteratordie-dai-qi/","abstract":"Java迭代器是java集合框架中的一种机制，提供了一种在不暴露集合内部实现的情况下遍历集合元素的方法.Java迭代器不是一个集合，是用于访问集合的方法，可用于迭代ArrayList和HashSet等集合。Iterator是java迭代器最简单的实现，ListIterator是CollectionAPI中的接口，它扩展了Iterator接口。迭代器it的三个基本操作是next、hasNext和re..."},{"title":"33. Java HashMap","content":"HashMap是一个散列表，它存储的内容是键值对的映射。HashMap实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。HashMap是无序的，即不会记录插入的顺序，HashMap继承于AbstractMap，实现了Map、Cloneable、Java.io.Serializable接口.HashMap的key与value的类型可以不同HashMap的元素实际上是对象，一些常见的基本类型可以使用它的包装类。基本类型引用类型booleanBooleanbyteByteshortShortintIntegerlongLongfloatFloatdoubleDoublecharCharacterHashMap类位于java.util包中，使用前需要引入它，语法格式如下：importjava.util.HashMap;示例：创建HashMap对象HashMap&lt;Integer,String&gt;Sites=newHashMap&lt;Integer,String&gt;();添加元素添加键值对可以使用put()方法Sites.put(1,&quot;Google&quot;);访问元素使用get(key)方法获取key对应的valueSites.get(1);删除元素使用remove(key)方法来删除key对应的键值对Sites.remove(1);删除所有键值对，使用clear()方法Sites.clear();计算大小计算HashMap中的元素数量使用size()方法Sites.size();迭代HashMap使用for-each来迭代HashMap中的元素，如果只想获取key,使用keySet()方法;如果只想获取value，使用values()方法//输出key和valuefor(Integeri:Sites.keySet()){System.out.println(&quot;key:&quot;+i+&quot;value:&quot;+Sites.get(i));}//返回所有value值for(Stringvalue:Sites.values()){//输出每一个valueSystem.out.print(value+&quot;,&quot;);}方法方法描述clear()删除hashMap中的所有键/值对clone()复制一份hashMapisEmpty()判断hashMap是否为空size()计算hashMap中键/值对的数量put()将键/值对添加到hashMap中putAll()将所有键/值对添加到hashMap中putIfAbsent()如果hashMap中不存在指定的键，则将指定的键/值对插入到hashMap中。remove()删除hashMap中指定键key的映射关系containsKey()检查hashMap中是否存在指定的key对应的映射关系。containsValue()检查hashMap中是否存在指定的value对应的映射关系。replace()替换hashMap中是指定的key对应的value。replaceAll()将hashMap中的所有映射关系替换成给定的函数所执行的结果。get()获取指定key对应对valuegetOrDefault()获取指定key对应对value，如果找不到key，则返回设置的默认值forEach()对hashMap中的每个映射执行指定的操作。entrySet()返回hashMap中所有映射项的集合集合视图。keySet()返回hashMap中所有key组成的集合视图。values()返回hashMap中存在的所有value值。merge()添加键值对到hashMap中compute()对hashMap中指定key的值进行重新计算computeIfAbsent()对hashMap中指定key的值进行重新计算，如果不存在这个key，则添加到hasMap中computeIfPresent()对hashMap中指定key的值进行重新计算，前提是该key存在于hashMap中。","link":"https://Vir-Limerence.github.io/post/33-java-hashmap/","abstract":"HashMap是一个散列表，它存储的内容是键值对的映射。HashMap实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。HashMap是无序的，即不会记录插入的顺序，HashMap继承于AbstractMap，实现了Map、Cloneable、Java.io.Serializable接口.HashMap的key与value的类..."},{"title":"32. Java HashSet","content":"HashSet是基于HashMap来实现的，是一个不允许有重复元素的集合.HashSet允许有null值，HashSet是无序的，不会记录插入的顺序.HashSet不是线程安全的,如果多个线程尝试同时修改HashSet,则最终结果是不确定的,必须在多线程访问时，显式同步对HashSet的并发访问.HashSet实现了Set接口.HashSet的元素实际上是对象，一些常见的基本类型可以使用它的包装类.基本类型引用类型booleanBooleanbyteByteshortShortintIntegerlongLongfloatFloatdoubleDoublecharCharacterHashSet位于java.util包中,使用前需要引入它,语法格式如下:importjava.util.HashSet;示例：创建一个HashSet对象，保存字符串元素HashSet&lt;String&gt;sites=newHashSet&lt;String&gt;();添加元素HashSet类提供了很多有用的方法，添加元素可以使用add方法，重复的元素不会被添加importjava.util.HashSet;publicstaticvoidmain(){pulicstaticvoidmain(String[]args){HashSet&lt;String&gt;sites=newHashSet&lt;String&gt;();sites.add(&quot;Google&quot;);}}判断元素是否存在使用contains()方法判断元素是否存在于集合当中，返回布尔值importjava.util.HashSet;publicstaticvoidmain(){pulicstaticvoidmain(String[]args){HashSet&lt;String&gt;sites=newHashSet&lt;String&gt;();sites.add(&quot;Google&quot;);System.out.println(sites.contains(&quot;Google&quot;));}}删除元素使用remove()方法来删除集合中的元素，删除成功返回true，否则返回falsesites.remove(&quot;Taobao&quot;);删除集合中的所有元素可以使用clear方法sites.clear();计算大小使用size()方法计算HashSet中元素的数量sites.size();迭代HashSet使用for-each迭代for(Stringi:sites){System.out.println(i);}","link":"https://Vir-Limerence.github.io/post/32-java-hashset/","abstract":"HashSet是基于HashMap来实现的，是一个不允许有重复元素的集合.HashSet允许有null值，HashSet是无序的，不会记录插入的顺序.HashSet不是线程安全的,如果多个线程尝试同时修改HashSet,则最终结果是不确定的,必须在多线程访问时，显式同步对HashSet的并发访问.HashSet实现了Set接口.HashSet的元素实际上是对象，一些常见的基本类型可以使用它的包装类..."},{"title":"31. Java LinkedList","content":"链表是常见的数据结构，是一种线性表，但是并不会按照线性的顺序存储数据，而是在每个节点中存储到下一个节点的地址。链表可以分为单向链表和双向链表。一个单向链表包含两个值:当前节点的值和一个指向下一个节点的链接。一个双向链表有三个整数值:数值、向后的节点链接、向前的节点链接。JavaLinkedList（链表）类似于ArrayList，是一种常用的数据容器。与ArrayList相比，LinkedList的增加和删除的操作效率更高，而查找和修改的操作效率较低。使用ArrayList的情况：频繁访问列表中的某个元素只需要在列表的末尾进行添加和删除元素的操作使用LinkedList的情况：需要循环迭代来访问列表中的某些元素需要频繁的进行添加和删除元素的操作LinkedList继承了AbstractSequentialList类。LinkedList实现了Queue接口，可以作为队列使用。LinkedList实现了List接口，可以进行列表的相关操作。LinkedList实现了Deque接口，可以作为队列使用。LinkedList实现了Cloneable接口，可以实现克隆。LinkedList实现了java.io.Serializable接口，可支持序列化，能够通过序列化传输。LinkedList类位于java.util包下，使用前需要引入它importjava.util.LinkedList;//普通创建LinkedList&lt;E&gt;list=newLinkedList&lt;E&gt;();//使用集合创建链表LinkedList&lt;E&gt;list=newLinkedList(Collection&lt;?extendsE&gt;c);LinkedList的开头和结尾添加元素使用addFisrt和addLast可以在列表的开头和末尾添加元素同理，使用removeFirst和removeLast可以删除列表开头和末尾的元素常用方法方法描述publicbooleanadd(Ee)链表末尾添加元素，返回是否成功，成功为true，失败为false。publicvoidadd(intindex,Eelement)向指定位置插入元素。publicbooleanaddAll(Collectionc)将一个集合的所有元素添加到链表后面，返回是否成功，成功为true，失败为false。publicbooleanaddAll(intindex,Collectionc)将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为true，失败为false。publicvoidaddFirst(Ee)元素添加到头部。publicvoidaddLast(Ee)元素添加到尾部。publicbooleanoffer(Ee)向链表末尾添加元素，返回是否成功，成功为true，失败为false。publicbooleanofferFirst(Ee)头部插入元素，返回是否成功，成功为true，失败为false。publicbooleanofferLast(Ee)尾部插入元素，返回是否成功，成功为true，失败为false。publicvoidclear()清空链表。publicEremoveFirst()删除并返回第一个元素。publicEremoveLast()删除并返回最后一个元素。publicbooleanremove(Objecto)删除某一元素，返回是否成功，成功为true，失败为false。publicEremove(intindex)删除指定位置的元素。publicEpoll()删除并返回第一个元素。publicEremove()删除并返回第一个元素。publicbooleancontains(Objecto)判断是否含有某一元素。publicEget(intindex)返回指定位置的元素。publicEgetFirst()返回第一个元素。publicEgetLast()返回最后一个元素。publicintindexOf(Objecto)查找指定元素从前往后第一次出现的索引。publicintlastIndexOf(Objecto)查找指定元素最后一次出现的索引。publicEpeek()返回第一个元素。publicEelement()返回第一个元素。publicEpeekFirst()返回头部元素。publicEpeekLast()返回尾部元素。publicEset(intindex,Eelement)设置指定位置的元素。publicObjectclone()克隆该列表。publicIteratordescendingIterator()返回倒序迭代器。publicintsize()返回链表元素个数。publicListIteratorlistIterator(intindex)返回从指定位置开始到末尾的迭代器。publicObject[]toArray()返回一个由链表元素组成的数组。publicT[]toArray(T[]a)返回一个由链表元素转换类型而成的数组。","link":"https://Vir-Limerence.github.io/post/31-java-linkedlist/","abstract":"链表是常见的数据结构，是一种线性表，但是并不会按照线性的顺序存储数据，而是在每个节点中存储到下一个节点的地址。链表可以分为单向链表和双向链表。一个单向链表包含两个值:当前节点的值和一个指向下一个节点的链接。一个双向链表有三个整数值:数值、向后的节点链接、向前的节点链接。JavaLinkedList（链表）类似于ArrayList，是一种常用的数据容器。与ArrayList相比，LinkedList..."},{"title":"30. Java ArrayList","content":"ArrayList类是一个可以动态修改的数组，与普通数组的区别就是它时没有固定大小的限制，我们可以添加或者删除元素。ArrayList继承了AbstractList，并且实现了List接口。ArrayList类位于java.util包中，使用前需要引入：importjava.util.ArrayList;ArrayList&lt;E&gt;objectName=newArrayList&lt;&gt;();E:泛型数据类型，用于设置objectName的数据类型，只能为引用数据类型。objectName:对象名。ArrayList是一个数组队列，提供了相关的添加，删除，修改，遍历等功能添加元素ArrayList类提供了很多有用的方法，添加元素到ArrayList可以使用add方法importjava.util.ArrayList;publicclassRunoobTest{publicstaticvoidmain(String[]args){ArrayList&lt;String&gt;sites=newArrayList&lt;String&gt;();sites.add(&quot;Google&quot;);sites.add(&quot;Runoob&quot;);sites.add(&quot;Taobao&quot;);sites.add(&quot;Weibo&quot;);System.out.println(sites);}}访问元素访问ArrayList中的元素可以使用get方法，数组的索引从0开始importjava.util.ArrayList;publicclassRunoobTest{publicstaticvoidmain(String[]args){ArrayList&lt;String&gt;sites=newArrayList&lt;String&gt;();sites.add(&quot;Google&quot;);sites.add(&quot;Runoob&quot;);sites.add(&quot;Taobao&quot;);sites.add(&quot;Weibo&quot;);System.out.println(sites.get(1));//访问第二个元素}}修改元素如果修改ArrayList中的元素可以使用set方法importjava.util.ArrayList;publicclassRunoobTest{publicstaticvoidmain(String[]args){ArrayList&lt;String&gt;sites=newArrayList&lt;String&gt;();sites.add(&quot;Google&quot;);sites.add(&quot;Runoob&quot;);sites.add(&quot;Taobao&quot;);sites.add(&quot;Weibo&quot;);sites.set(2,&quot;Wiki&quot;);//第一个参数为索引位置，第二个为要修改的值System.out.println(sites);}}删除元素如果要删除ArrayList中的元素，可以使用remove方法importjava.util.ArrayList;publicclassRunoobTest{publicstaticvoidmain(String[]args){ArrayList&lt;String&gt;sites=newArrayList&lt;String&gt;();sites.add(&quot;Google&quot;);sites.add(&quot;Runoob&quot;);sites.add(&quot;Taobao&quot;);sites.add(&quot;Weibo&quot;);sites.remove(3);//删除第四个元素System.out.println(sites);}}计算大小使用size方法计算ArrayList的大小importjava.util.ArrayList;publicclassRunoobTest{publicstaticvoidmain(String[]args){ArrayList&lt;String&gt;sites=newArrayList&lt;String&gt;();sites.add(&quot;Google&quot;);sites.add(&quot;Runoob&quot;);sites.add(&quot;Taobao&quot;);sites.add(&quot;Weibo&quot;);System.out.println(sites.size());}}迭代数组列表可以使用for循环遍历，也可以使用增强循环importjava.util.ArrayList;publicclassRunoobTest{publicstaticvoidmain(String[]args){ArrayList&lt;String&gt;sites=newArrayList&lt;String&gt;();sites.add(&quot;Google&quot;);sites.add(&quot;Runoob&quot;);sites.add(&quot;Taobao&quot;);sites.add(&quot;Weibo&quot;);for(inti=0;i&lt;sites.size();i++){System.out.println(sites.get(i));}for(Stringi:sites){System.out.println(i);}}}其它的引用类型ArrayList中的元素实际上是对象，在以上实例中，数组列表元素都是字符串String类型。如果我们要存储其他类型，而&lt;E&gt;只能为引用数据类型，这时我们就需要使用到基本类型的包装类。基本类型引用类型booleanBooleanbyteByteshortShortintIntegerlongLongfloatFloatdoubleDoublecharCharacter此外，BigInteger、BigDecimal用于高精度的运算，BigInteger支持任意精度的整数，也是引用类型，但它们没有相对应的基本类型。ArrayList排序collections类是一个非常有用的类，位于java.util包中，提供的sort方法可以对字符或者数字列表进行排序importjava.util.ArrayList;importjava.util.Collections;//引入Collections类publicclassRunoobTest{publicstaticvoidmain(String[]args){ArrayList&lt;String&gt;sites=newArrayList&lt;String&gt;();sites.add(&quot;Taobao&quot;);sites.add(&quot;Wiki&quot;);sites.add(&quot;Runoob&quot;);sites.add(&quot;Weibo&quot;);sites.add(&quot;Google&quot;);Collections.sort(sites);//字母排序for(Stringi:sites){System.out.println(i);}}}JavaArrayList方法常用方法：方法描述add()将元素插入到指定位置的arraylist中addAll()添加集合中的所有元素到arraylist中clear()删除arraylist中的所有元素clone()复制一份arraylistcontains()判断元素是否在arraylistget()通过索引值获取arraylist中的元素indexOf()返回arraylist中元素的索引值removeAll()删除存在于指定集合中的arraylist里的所有元素remove()删除arraylist里的单个元素size()返回arraylist里元素数量isEmpty()判断arraylist是否为空subList()截取部分arraylist的元素set()替换arraylist中指定索引的元素sort()对arraylist元素进行排序toArray()将arraylist转换为数组toString()将arraylist转换为字符串ensureCapacity()设置指定容量大小的arraylistlastIndexOf()返回指定元素在arraylist中最后一次出现的位置retainAll()保留arraylist中在指定集合中也存在的那些元素containsAll()查看arraylist是否包含指定集合中的所有元素trimToSize()将arraylist中的容量调整为数组中的元素个数removeRange()删除arraylist中指定索引之间存在的元素replaceAll()将给定的操作内容替换掉数组中每一个元素removeIf()删除所有满足特定条件的arraylist元素forEach()遍历arraylist中每一个元素并执行特定操作","link":"https://Vir-Limerence.github.io/post/30-java-arraylist/","abstract":"ArrayList类是一个可以动态修改的数组，与普通数组的区别就是它时没有固定大小的限制，我们可以添加或者删除元素。ArrayList继承了AbstractList，并且实现了List接口。ArrayList类位于java.util包中，使用前需要引入：importjava.util.ArrayList;ArrayList&lt;E&gt;objectName=newArrayList&lt;&g..."},{"title":"29. Java集合框架","content":"早在Java2中之前，Java就提供了特设类。比如：Dictionary,Vector,Stack,和Properties这些类用来存储和操作对象组。虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用Vector类的方式和使用Properties类的方式有着很大不同。集合框架被设计用于满足以下几个目标：框架必须是高性能的，基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性对一个集合的扩展和适应必须是简单的为此，集合框架围绕一组接口标准设计，可以直接使用这些接口的标准实现，例如：LinkedList，HashSet，TreeSet等，此外也可以通过这些接口实现自己的集合.从java集合框架图中可以看到，java集合框架主要包含两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection接口又有三种子类型：List，Set，和Queue，再下面是一些抽象的类，最后是具体实现的类，常用的有：ArrayList,LinkedList,HashSet,LinkedHashSet,HashMap,LinkedHashMap等等.集合框架是一个用来代表和操作集合的统一架构,所有集合框架都包含如下的内容：接口：是代表集合的抽象数据类型，例如Collection，List，Set，Map等，之所以定义多个接口，是为了以不同的方式操作集合对象实现（类）：是集合接口的具体实现，本质上讲，它们是可以重复使用的数据结构,例如：ArrayList、LinkedList、HashSet、HashMap算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如搜索和排序，这些算法实现了多态，是因为相同的方法可以在相似的接口上有着不同的实现.除了集合外，框架也定义了几个Map接口和类，Map存储的是键值对，尽管Map不是集合，但是它们完全整合在集合中。集合框架体系图java的集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中，所以使用集合框架时要导入相关包.集合接口序号接口描述1Collection接口Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素,Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection接口存储一组不唯一，无序的对象。2List接口是一个有序的Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为0，而且允许有相同的元素。List接口存储一组不唯一，有序（插入顺序）的对象。3Set具有与Collection完全一样的接口，只是行为上不同，Set不保存重复的元素。Set接口存储一组唯一，无序的对象。4SortedSet继承于Set保存有序的集合。5Map接口存储一组键值对象，提供key（键）到value（值）的映射。6Map.Entry描述在一个Map中的一个元素（键/值对）。是一个Map的内部接口。7SortedMap继承于Map，使Key保持在升序排列。8Enumeration这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。Set和List的区别Set接口实例存储的是无序的，不重复的数据，List接口实例存储的是有序的，可以重复的元素Set检索效率低下，删除和插入的效率高，插入和删除不会引起元素位置改变，&lt;实现类有HashSet,TreeSet&gt;。List和数组类似，可以实现动态增长，可以根据实际存储的数据长度自动增长List的长度，查找元素效率高，插入删除的效率低，会引起其它元素位置的改变，&lt;实现类有ArrayList,LinkedList,Vector&gt;。集合实现类（集合类）Java提供了一套实现了Collection接口的标准集合类，其实一些是具体类，可以直接使用，而另外一些是抽象类，提供了接口的部分实现.序号类描述1AbstractCollection实现了大部分的集合接口。2AbstractList继承于AbstractCollection并且实现了大部分List接口。3AbstractSequentialList继承于AbstractList，提供了对数据元素的链式访问而不是随机访问。4LinkedList该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：Listlist=Collections.synchronizedList(newLinkedList(...));LinkedList查找效率低。5ArrayList该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList增长当前长度的50%，插入删除效率低。6AbstractSet继承于AbstractCollection并且实现了大部分Set接口。7HashSet该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。8LinkedHashSet具有可预知迭代顺序的Set接口的哈希表和链接列表实现。9TreeSet该类实现了Set接口，可以实现排序等功能。10AbstractMap实现了大部分的Map接口。11HashMapHashMap是一个散列表，它存储的内容是键值对(key-value)映射。该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。12TreeMap继承了AbstractMap，并且使用一颗树。13WeakHashMap继承AbstractMap类，使用弱密钥的哈希表。14LinkedHashMap继承于HashMap，使用元素的自然顺序对元素进行排序.15IdentityHashMap继承AbstractMap类，比较文档时使用引用相等。java的util包中定义的类：序号类描述1Vector该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。2Stack栈是Vector的一个子类，它实现了一个标准的后进先出的栈。3Dictionary类是一个抽象类，用来存储键/值对，作用和Map类相似。4Hashtable是Dictionary(字典)类的子类，位于java.util包中。5Properties继承于Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。6一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。集合算法集合框架定义了几种算法，用于集合和映射，这些算法被定义位集合类的静态方法.在尝试比较不兼容的类型时，一些方法能够抛出ClassCastException异常，当试图修改一个不可修改的集合时，抛出UnsupportedOperationException异常.集合定义三个静态的变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP的。这些变量都不可改变.序号算法描述1CollectionAlgorithms这里是一个列表中的所有算法实现。使用迭代器如果需要遍历一个集合中的元素，一般采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator接口或ListIterator接口。迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator继承了Iterator，以允许双向遍历列表和修改元素。序号迭代器方法描述1使用JavaIterator这里通过实例列出Iterator和ListIterator接口提供的所有方法。遍历ArrayListimportjava.util.*;publicclassTest{publicstaticvoidmain(String[]args){List&lt;String&gt;list=newArrayList&lt;String&gt;();list.add(&quot;Hello&quot;);list.add(&quot;World&quot;);list.add(&quot;HAHAHAHA&quot;);//第一种遍历方法使用For-Each遍历Listfor(Stringstr:list){//也可以改写for(inti=0;i&lt;list.size();i++)这种形式System.out.println(str);}//第二种遍历，把链表变为数组相关的内容进行遍历String[]strArray=newString[list.size()];list.toArray(strArray);for(inti=0;i&lt;strArray.length;i++)//这里也可以改写为for(Stringstr:strArray)这种形式{System.out.println(strArray[i]);}//第三种遍历使用迭代器进行相关遍历，不用担心超出集合长度Iterator&lt;String&gt;ite=list.iterator();while(ite.hasNext())//判断下一个元素之后有值{System.out.println(ite.next());}}}遍历Mapimportjava.util.*;publicclassTest{publicstaticvoidmain(String[]args){Map&lt;String,String&gt;map=newHashMap&lt;String,String&gt;();map.put(&quot;1&quot;,&quot;value1&quot;);map.put(&quot;2&quot;,&quot;value2&quot;);map.put(&quot;3&quot;,&quot;value3&quot;);//第一种：普遍使用，二次取值System.out.println(&quot;通过Map.keySet遍历key和value：&quot;);for(Stringkey:map.keySet()){System.out.println(&quot;key=&quot;+key+&quot;andvalue=&quot;+map.get(key));}//第二种System.out.println(&quot;通过Map.entrySet使用iterator遍历key和value：&quot;);Iterator&lt;Map.Entry&lt;String,String&gt;&gt;it=map.entrySet().iterator();while(it.hasNext()){Map.Entry&lt;String,String&gt;entry=it.next();System.out.println(&quot;key=&quot;+entry.getKey()+&quot;andvalue=&quot;+entry.getValue());}//第三种：推荐，尤其是容量大时System.out.println(&quot;通过Map.entrySet遍历key和value&quot;);for(Map.Entry&lt;String,String&gt;entry:map.entrySet()){System.out.println(&quot;key=&quot;+entry.getKey()+&quot;andvalue=&quot;+entry.getValue());}//第四种System.out.println(&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;);for(Stringv:map.values()){System.out.println(&quot;value=&quot;+v);}}}使用比较器TreeSet和TreeMap按照排序顺序来存储元素,通过比较器可以精确定义按照什么样的排序顺序。序号比较器方法描述1使用JavaComparator这里通过实例列出Comparator接口提供的所有方法总结Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。集合框架的类和接口均在java.util包中。任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。","link":"https://Vir-Limerence.github.io/post/29-java-ji-he-kuang-jia/","abstract":"早在Java2中之前，Java就提供了特设类。比如：Dictionary,Vector,Stack,和Properties这些类用来存储和操作对象组。虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用Vector类的方式和使用Properties类的方式有着很大不同。集合框架被设计用于满足以下几个目标：框架必须是高性能的，基本集合（动态数组，链表，树，哈希表）的实现也必须..."},{"title":"28. Java中的数据结构","content":"在java中的数据结构主要包括以下几种接口和类：枚举位集合向量栈字典哈希表属性枚举（Enmueration)枚举接口本身不属于数据结构，但是在其它数据结构的范畴中应用很广泛.枚举接口定义了一种从数据结构中取回连续元素的方式.例如，枚举定义了一个叫nextElement的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。位集合（BitSet）位集合类实现了一组可以单独设置和清除的位或标志.该类在处理一组布尔值的时候非常有用，只需要为每个值赋值一位，然后对位进行适当的设置或清除，就可以对布尔值进行操作.向量（Vector)向量和传统数组非常类似，但是Vector的大小可以根据需要动态变化.和数组一样，Vector对象的元素也可以通过索引进行访问.使用Vector的好处在于创建对象的时候不必指定大小，会根据需要动态变换。栈（Stack）栈实现了一种后进先出的数据结构.最后入栈的元素最先被取出.字典（Dictionary)字典类是一个抽象类,定义了键映射到值的数据结构.如果想通过特定的键而不是整数索引来访问数据的时候,可以使用字典.字典类是抽象类，只提供了键映射到值的数据结构，没有提供特定的实现。哈希表（Hashtable）哈希表类提供了一种在用户定义键结构的基础上来组织数据的手段.哈希表的具体含义完全取决于哈希表的使用情景和包含的数据.属性（Properties)属性类继承于哈希表.属性类表示了一个持久的属性集，属性列表中每个键及其对应的值都是一个字符串Properties类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。","link":"https://Vir-Limerence.github.io/post/28-java-zhong-de-shu-ju-jie-gou/","abstract":"在java中的数据结构主要包括以下几种接口和类：枚举位集合向量栈字典哈希表属性枚举（Enmueration)枚举接口本身不属于数据结构，但是在其它数据结构的范畴中应用很广泛.枚举接口定义了一种从数据结构中取回连续元素的方式.例如，枚举定义了一个叫nextElement的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。位集合（BitSet）位集合类实现了一组可以单独设置和清除的位或标志.该..."},{"title":"27. Java枚举（enum）","content":"Java枚举是一个特殊的类，一般表示一组常量，比如一年的4个季节，一年的12个月份，一个星期的7天，方向有东南西北等。Java枚举类使用enum关键字来定义，各个常量使用逗号,来分割。enumColor{RED,GREEN,BLUE;}以上枚举类Color颜色常量有RED,GREEN,BLUE，分别表示红色，绿色，蓝色。内部类中使用枚举publicclassTest{enumColor{RED,GREEN,BLUE;}//执行输出结果publicstaticvoidmain(String[]args){Colorc1=Color.RED;System.out.println(c1);}}//输出为：RED每个枚举都是通过Class在内部实现的，且所有的枚举值都是publicstaticfinal的。迭代枚举元素enumColor{RED,GREEN,BLUE;}publicclassMyClass{publicstaticvoidmain(String[]args){for(ColormyVar:Color.values()){System.out.println(myVar);}}}//RED//GREEN//BLUE枚举类的方法enum定义的枚举类默认继承了java.lang.Enum类，并实现了java.lang.Serializable和java.lang.Comparable两个接口。values(),ordinal()和valueOf()方法位于java.lang.Enum类中：values()返回枚举类中所有的值。ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。valueOf()方法返回指定字符串值的枚举常量。enumColor{RED,GREEN,BLUE;}publicclassTest{publicstaticvoidmain(String[]args){//调用values()Color[]arr=Color.values();//迭代枚举for(Colorcol:arr){//查看索引System.out.println(col+&quot;atindex&quot;+col.ordinal());}//使用valueOf()返回枚举常量，不存在的会报错IllegalArgumentExceptionSystem.out.println(Color.valueOf(&quot;RED&quot;));//System.out.println(Color.valueOf(&quot;WHITE&quot;));}}枚举类成员枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用private访问修饰符，所以外部无法调用。枚举既可以包含具体方法，也可以包含抽象方法。如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。","link":"https://Vir-Limerence.github.io/post/27-java-mei-ju-enum/","abstract":"Java枚举是一个特殊的类，一般表示一组常量，比如一年的4个季节，一年的12个月份，一个星期的7天，方向有东南西北等。Java枚举类使用enum关键字来定义，各个常量使用逗号,来分割。enumColor{RED,GREEN,BLUE;}以上枚举类Color颜色常量有RED,GREEN,BLUE，分别表示红色，绿色，蓝色。内部类中使用枚举publicclassTest{enumColor{RED,G..."},{"title":"26. Java接口","content":"接口的特点接口通常以interface来声明，一个类通过继承接口的方式来继承接口的抽象方法接口不是类，包含类要实现的方法除非实现接口的类是抽象类，否则该类要定义接口中的所有方法接口无法被实例化，但可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。接口与类的区别接口不能用于实例化对象接口没有构造方法接口中所有的方法必须是抽象方法。Java8之后接口中可以使用default关键字修饰的非抽象方法。接口不能包含成员变量，除了static和final变量接口不是被类继承了，而是要被类实现接口支持多继承接口特性接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为publicabstract（只能是publicabstract，其他修饰符都会报错）。接口中可以含有变量，但是接口中的变量会被隐式的指定为publicstaticfinal变量（并且只能是public，用private修饰会报编译错误）。接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。抽象类和接口的区别抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是publicstaticfinal类型的。接口中不能含有静态代码块以及静态方法(用static修饰的方法)，而抽象类是可以有静态代码块和静态方法。一个类只能继承一个抽象类，而一个类却可以实现多个接口。注：JDK1.8以后，接口里可以有静态方法和方法体了。注：JDK1.8以后，接口允许包含具体实现的方法，该方法称为&quot;默认方法&quot;，默认方法使用default关键字修饰。更多内容可参考Java8默认方法。注：JDK1.9以后，允许将方法定义为private，使得某些复用的代码不会把方法暴露出去。更多内容可参考Java9私有接口方法。接口的声明[可见度]interface接口名称[extends其他的接口名]{//声明变量//抽象方法}接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。接口中的方法都是公有的。接口的实现当类实现接口的时候，必须实现接口中的所有方法，否则必须声明为抽象的类。类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。...implements接口名称[,其他接口名称,其他接口名称...,...]...重写接口中声明的方法：类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。如果实现接口的类是抽象类，那么就没必要实现该接口的方法。实现接口注意的规则：一个类可以同时实现多个接口。一个类只能继承一个类，但是能实现多个接口。一个接口能继承另一个接口，这和类之间的继承比较相似。标记接口最常用的接口是不包含任何方法的接口，标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。packagejava.util;publicinterfaceEventListener{}没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：建立一个公共的父接口：正如EventListener接口，这是由几十个其他接口扩展的JavaAPI，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。像一个类添加数据类型：这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。","link":"https://Vir-Limerence.github.io/post/26-java-jie-kou/","abstract":"接口的特点接口通常以interface来声明，一个类通过继承接口的方式来继承接口的抽象方法接口不是类，包含类要实现的方法除非实现接口的类是抽象类，否则该类要定义接口中的所有方法接口无法被实例化，但可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。接口与类的区别接口不能用于实例..."},{"title":"25. Java封装","content":"封装的优点良好的封装能够减少耦合。类内部的结构可以自由修改。可以对成员变量进行更精确的控制。隐藏信息，实现细节。实现封装的步骤修改属性的可见性来限制对属性的访问（一般为private）publicclassPerson{privateStringname;privateintage;}对每个值提供对外的公共访问方法，也就是创建一对赋取值方法，用于对私有属性的访问publicclassPerson{privateStringname;privateintage;publicintgetAge(){returnage;}publicStringgetName(){returnname;}publicvoidsetAge(intage){this.age=age;}publicvoidsetName(Stringname){this.name=name;}}通常情况下，这些方法被称为getter和setter方法。因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。","link":"https://Vir-Limerence.github.io/post/25-java-feng-zhuang/","abstract":"封装的优点良好的封装能够减少耦合。类内部的结构可以自由修改。可以对成员变量进行更精确的控制。隐藏信息，实现细节。实现封装的步骤修改属性的可见性来限制对属性的访问（一般为private）publicclassPerson{privateStringname;privateintage;}对每个值提供对外的公共访问方法，也就是创建一对赋取值方法，用于对私有属性的访问publicclassPerson{..."},{"title":"24. Java抽象类","content":"如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。抽象方法如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。publicabstractclassEmployee{privateStringname;privateStringaddress;privateintnumber;publicabstractdoublecomputePay();//其余代码}如果一个类包含抽象方法，那么该类必须是抽象类任何子类必须重写父类的抽象方法，或者声明自身为抽象类继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。总结抽象类不能被实例化，只有抽象类的非抽象子类才可以创建对象抽象类中不一定包含抽象方法，但是有抽象方法的类必须是抽象类抽象类中的抽象方法只是声明，不包含方法体构造方法，类方法不能被声明为抽象方法抽象类的子类必须给出抽象类中抽象方法的具体实现，除非子类也是抽象类","link":"https://Vir-Limerence.github.io/post/24-java-chou-xiang-lei/","abstract":"如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。抽象方法如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具..."},{"title":"23. Java多态","content":"多态是同一行为具有不同表现形式或形态的能力，多态就是同一个接口，使用不同的实例而执行不同操作。多态的优点消除类型之间耦合关系可替换性可扩充性接口性灵活性简化性多态存在的条件继承重写父类的引用指向子类：Parentp=newChild();在使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有则编译错误，如果有，再去调用子类的同名方法。多态的好处：使得程序有良好的扩展性，并且可以对所有类的对象进行通用处理。publicclassTest{publicstaticvoidmain(String[]args){show(newCat());//以Cat对象调用show方法show(newDog());//以Dog对象调用show方法Animala=newCat();//向上转型a.eat();//调用的是Cat的eatCatc=(Cat)a;//向下转型c.work();//调用的是Cat的work}publicstaticvoidshow(Animala){a.eat();//类型判断if(ainstanceofCat){//猫做的事情Catc=(Cat)a;c.work();}elseif(ainstanceofDog){//狗做的事情Dogc=(Dog)a;c.work();}}}abstractclassAnimal{abstractvoideat();}classCatextendsAnimal{publicvoideat(){System.out.println(&quot;吃鱼&quot;);}publicvoidwork(){System.out.println(&quot;抓老鼠&quot;);}}classDogextendsAnimal{publicvoideat(){System.out.println(&quot;吃骨头&quot;);}publicvoidwork(){System.out.println(&quot;看家&quot;);}}虚函数java中没有虚函数的概念，它的普通函数就相当于C++的虚函数，动态绑定是java的默认行为，如果java中不希望某个函数具有虚函数的特性，可以加上final关键字变成非虚函数重写当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。要想调用父类中被重写的方法，必须使用super关键字。","link":"https://Vir-Limerence.github.io/post/23-java-duo-tai/","abstract":"多态是同一行为具有不同表现形式或形态的能力，多态就是同一个接口，使用不同的实例而执行不同操作。多态的优点消除类型之间耦合关系可替换性可扩充性接口性灵活性简化性多态存在的条件继承重写父类的引用指向子类：Parentp=newChild();在使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有则编译错误，如果有，再去调用子类的同名方法。多态的好处：使得程序有良好的扩展性，并且可以对所有类的对..."},{"title":"22. Java重写（Overrride）和重载（Overload）","content":"重写（Override）重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即外壳不变，核心重写。重写的好处在于子类可以根据需要，定义特定于自己的行为，也就是说子类能够根据需要实现父类的方法。重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。在面向对象的原则里，重写意味着可以重写任何现有的方法。classAnimal{publicvoidmove(){System.out.println(&quot;动物可以移动&quot;);}}classDogextendsAnimal{publicvoidmove(){System.out.println(&quot;狗可以跑和走&quot;);}}publicclassTestDog{publicstaticvoidmain(Stringargs[]){Animala=newAnimal();//Animal对象//向上转型Animalb=newDog();//Dog对象a.move();//执行Animal类的方法b.move();//执行Dog类的方法}}在上述代码中，尽管b属于Animal类型，但是它运行的是Dog类的move方法。这是由于在编译阶段，只是检查参数的引用类型，然而在运行时，java虚拟机（jvm）指定对象的类型并运行该方法。之所以能编译成功，是因为Animal类中存在move方法，然而运行时，运行的是特定对象的方法。重写的规则参数列表于被重写方法的参数列表必须完全相同返回类型与被重写方法的返回类型可以不相同，但必须是父类返回值的派生类访问权限不能比父类中重写的方法的访问权限低父类的成员方法只能被它的子类重写声明为final的方法不能被重写声明为static的方法不能被重写，但是能够被再次声明子类和父类在一个包中，子类可以重写父类的所有方法，除了声明为private和final的方法子类和父类不在一个包中，子类只能重写父类声明为public和protected的非final方法重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常构造方法不能被重写如果不能继承一个类，不能重写该类的方法重载（Overload）重载是在一个类里，方法名字相同，但是参数不同，返回类型可以相同也可以不同每个重载的方法参数列表必须不同，最常用的就是构造器的重载重载规则重载可以改变参数列表重载可以改变返回类型重载可以改变访问修饰符重载可以声明新的或者更广泛的检查异常方法能够在同一个类中或者一个子类中被重载无法以返回值类型作为重载函数的区分标准重写与重载的规则区别点重载方法重写方法参数列表必须修改一定不能修改返回类型可以修改一定不能修改异常可以修改可以减少或删除，一定不能抛出新的或者更广的异常访问可以修改一定不能做更严格的限制（可以降低限制）总结重写和重载是java多态的不同表现形式，重写是父类和子类之间多态性的一种表现，重载可以理解为多态的具体表现形式。方法重载是一个类中定义了多个方法名相同，但是参数不同重写是子类存在方法与父类的发发名称相同，并且参数的个数和类型是一样的，返回值也是一样的方法重载是一个类的多态性表现，而方法重写是子类和父类的一种多态表现","link":"https://Vir-Limerence.github.io/post/22-java-chong-xie-overrridehe-chong-zai-overload/","abstract":"重写（Override）重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即外壳不变，核心重写。重写的好处在于子类可以根据需要，定义特定于自己的行为，也就是说子类能够根据需要实现父类的方法。重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。在面向对象的原则里，重写意味着可以重写任何现有的方法。classAnimal{publicvoidmove(){Sy..."},{"title":"21. Java继承","content":"概念继承是java面向对象编程的基础，因为它允许创建分层次等级的类。继承就是子类继承父类的特征和行为，使得子类对象具有父类的实例域和方法。或者子类从父类继承方法，使得子类具有父类相同的行为。继承需要符合的关系是：is-a,父类更通用，子类更具体格式在java中通过extends关键字可以申明一个类是从另外一个类继承得到的：class父类{}class子类extends父类{}继承的类型单继承、多重继承、不支持多类继承继承的特性子类拥有父类的非private属性、方法子类可以拥有自己的属性和方法，即子类可以对父类进行扩展子类可以用自己的方式实现父类的方法java的继承是单继承，但是可以多重继承提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性变差）继承的关键字extends和implements关键字实现继承，所有的类都是继承于java.lang.Object，当一个类没有继承的两个关键字，默认会继承Object类（这个类默认在java.lang包中，所以不需要import）祖先类extends关键字java中，类是单一继承的，也就是说一个子类只能拥有一个父类，所以extends只能继承一个类implements关键字使用implements关键字可以变相的使java具有多继承的特性，使用范围为继承接口的情况，可以同时继承多个接口（接口跟接口之间使用逗号分隔）super和this关键字super关键字:可以通过super关键字来访问父类成员，引用当前对象的父类this关键字：指向自己的引用final关键字final可以用来修饰变量（包括类的属性，对象属性，局部变量和形参），方法（包括类方法和对象方法）和类使用final关键字来声明类，不能被继承，修饰方法，方法不能被子类重写声明类：finalclass类名{}声明方法：修饰符(public/private/default/protected)final返回值类型方法名(){}构造器子类不继承父类的构造器（构造方法或者构造函数），它只是调用（显式或者隐式）。如果父类的构造器带有参数，则必须在子类的构造器中显示地通过super关键字调父类的构造器，并且配以适当的参数。如果父类构造器没有参数，子类构造器中不需要使用super关键字调用父类构造器，系统会自动调用父类的无参构造器。","link":"https://Vir-Limerence.github.io/post/21-java-ji-cheng/","abstract":"概念继承是java面向对象编程的基础，因为它允许创建分层次等级的类。继承就是子类继承父类的特征和行为，使得子类对象具有父类的实例域和方法。或者子类从父类继承方法，使得子类具有父类相同的行为。继承需要符合的关系是：is-a,父类更通用，子类更具体格式在java中通过extends关键字可以申明一个类是从另外一个类继承得到的：class父类{}class子类extends父类{}继承的类型单继承、多重..."},{"title":"20. Java异常处理","content":"😍异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。异常发生的原因有很多，通常包含以下几大类：用户输入了非法数据。要打开的文件不存在。网络通信时连接中断，或者JVM内存溢出。要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：**检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。Exception类的层次所有的异常类是从java.lang.Exception类继承的子类。Exception类是Throwable类的子类。除了Exception类外，Throwable还有一个子类Error。Java程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。Error用来指示运行时环境发生的错误。例如，JVM内存溢出。一般地，程序不会从错误中恢复。异常类有两个主要的子类：IOException类和RuntimeException类。java内置异常类Java语言定义了一些异常类在java.lang标准包中。标准运行时异常类的子类是最常见的异常类。由于java.lang包是默认加载到所有的Java程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。java的非检查性异常：异常描述ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数&quot;除以零&quot;时，抛出此类的一个实例。ArrayIndexOutOfBoundsException用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。ArrayStoreException试图将错误类型的对象存储到一个对象数组时抛出的异常。ClassCastException当试图将对象强制转换为不是实例的子类时，抛出该异常。IllegalArgumentException抛出的异常表明向方法传递了一个不合法或不正确的参数。IllegalMonitorStateException抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。IllegalStateException在非法或不适当的时间调用方法时产生的信号。换句话说，即Java环境或Java应用程序没有处于请求操作所要求的适当状态下。IllegalThreadStateException线程没有处于请求操作所要求的适当状态时抛出的异常。IndexOutOfBoundsException指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。NegativeArraySizeException如果应用程序试图创建大小为负的数组，则抛出该异常。NullPointerException当应用程序试图在需要对象的地方使用null时，抛出该异常NumberFormatException当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。SecurityException由安全管理器抛出的异常，指示存在安全侵犯。StringIndexOutOfBoundsException此异常由String方法抛出，指示索引或者为负，或者超出字符串的大小。UnsupportedOperationException当不支持请求的操作时，抛出该异常。java的检查性异常：异常描述ClassNotFoundException应用程序试图加载类时，找不到相应的类，抛出该异常。CloneNotSupportedException当调用Object类中的clone方法克隆对象，但该对象的类无法实现Cloneable接口时，抛出该异常。IllegalAccessException拒绝访问一个类的时候，抛出该异常。InstantiationException当试图使用Class类中的newInstance方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。InterruptedException一个线程被另一个线程中断，抛出该异常。NoSuchFieldException请求的变量不存在NoSuchMethodException请求的方法不存在异常方法序号方法及说明1publicStringgetMessage()返回关于发生的异常的详细信息。这个消息在Throwable类的构造函数中初始化了。2publicThrowablegetCause()返回一个Throwable对象代表异常原因。3publicStringtoString()返回此Throwable的简短描述。4publicvoidprintStackTrace()将此Throwable及其回溯打印到标准错误流。。5publicStackTraceElement[]getStackTrace()返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。6publicThrowablefillInStackTrace()用当前的调用栈层次填充Throwable对象栈层次，添加到栈层次任何先前信息中。捕获异常使用try和catch关键字可以捕获异常。try/catch代码块放在异常可能发生的地方。try/catch代码块中的代码称为保护代码，使用try/catch的语法如下：try{//程序代码}catch(ExceptionNamee1){//Catch块}Catch语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try后面的catch块就会被检查。如果发生的异常包含在catch块中，异常会被传递到该catch块，这和传递一个参数到方法是一样。多重捕获块try{//程序代码}catch(异常类型1异常的变量名1){//程序代码}catch(异常类型2异常的变量名2){//程序代码}catch(异常类型3异常的变量名3){//程序代码}可以在try语句后面添加任意数量的catch块。如果保护代码中发生异常，异常被抛给第一个catch块。如果抛出异常的数据类型与ExceptionType1匹配，它在这里就会被捕获。如果不匹配，它会被传递给第二个catch块。如此，直到异常被捕获或者通过所有的catch块。throw/throws关键字在Java中，throw和throws关键字是用于处理异常的。throw关键字用于在代码中抛出异常，而throws关键字用于在方法声明中指定可能会抛出的异常类型。throw关键字throw关键字用于在当前方法中抛出一个异常。通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用throw关键字抛出异常，以告知调用者当前代码的执行状态。publicvoidcheckNumber(intnum){if(num&lt;0){thrownewIllegalArgumentException(&quot;Numbermustbepositive&quot;);}}throws关键字throws关键字用于在方法声明中指定该方法可能抛出的异常。当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常。publicvoidreadFile(StringfilePath)throwsIOException{BufferedReaderreader=newBufferedReader(newFileReader(filePath));Stringline=reader.readLine();while(line!=null){System.out.println(line);line=reader.readLine();}reader.close();}一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。importjava.io.*;publicclassclassName{publicvoidwithdraw(doubleamount)throwsRemoteException,InsufficientFundsException{//Methodimplementation}//Remainderofclassdefinition}finally关键字finally关键字用来创建在try代码块后面执行的代码块。无论是否发生异常，finally代码块中的代码总会被执行。在finally代码块中，可以运行清理类型等收尾善后性质的语句。try{//程序代码}catch(异常类型1异常的变量名1){//程序代码}catch(异常类型2异常的变量名2){//程序代码}finally{//程序代码}注意事项：catch不能独立于try存在。在try/catch后面添加finally块并非强制性要求的。try代码后不能既没catch块也没finally块。try,catch,finally块之间不能添加任何代码。try-with-resourcesJDK7之后，Java新增的try-with-resource语法糖来打开资源，并且可以在语句执行完毕后确保每个资源都被自动关闭。try-with-resources是一种异常处理机制，它可以简化资源管理代码的编写。JDK7之前所有被打开的系统资源，比如流、文件或者Socket连接等，都需要被开发者手动关闭，否则将会造成资源泄露。importjava.io.*;publicclassRunoobTest{publicstaticvoidmain(String[]args){Stringline;try(BufferedReaderbr=newBufferedReader(newFileReader(&quot;test.txt&quot;))){while((line=br.readLine())!=null){System.out.println(&quot;Line=&gt;&quot;+line);}}catch(IOExceptione){System.out.println(&quot;IOExceptionintryblock=&gt;&quot;+e.getMessage());}}}在try-with-resources语句中声明和实例化BufferedReader对象，执行完毕后实例资源，不需要考虑try语句是正常执行还是抛出异常。如果发生异常，可以使用catch来处理异常。try-with-resources处理多个资源，方法是使用分号;分隔各个资源：importjava.io.*;importjava.util.*;classRunoobTest{publicstaticvoidmain(String[]args)throwsIOException{try(Scannerscanner=newScanner(newFile(&quot;testRead.txt&quot;));PrintWriterwriter=newPrintWriter(newFile(&quot;testWrite.txt&quot;))){while(scanner.hasNext()){writer.print(scanner.nextLine());}}}}多个声明资源时，try-with-resources语句以相反的顺序关闭这些资源。在本例中，PrintWriter对象先关闭，然后Scanner对象关闭。声明自定义的异常在Java中你可以自定义异常。编写自己的异常类时需要记住下面的几点。所有异常都必须是Throwable的子类。如果希望写一个检查性异常类，则需要继承Exception类。如果你想写一个运行时异常类，那么需要继承RuntimeException类。classMyExceptionextendsException{}只继承Exception类来创建的异常类是检查性异常类。通用异常在Java中定义了两种类型的异常和错误。JVM(Java虚拟机)异常：由JVM抛出的异常或错误。例如：NullPointerException类，ArrayIndexOutOfBoundsException类，ClassCastException类。程序级异常：由程序或者API程序抛出的异常。例如IllegalArgumentException类，IllegalStateException类。","link":"https://Vir-Limerence.github.io/post/20-java-yi-chang-chu-li/","abstract":"😍异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。异常发生的原因有很多，通常包含以下几大类：用户输入了非法数据。要打开的文件不存在。网络通信时连接中断，或者JVM内存溢出。要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：**检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就..."},{"title":"19. Java Scanner类","content":"java.util.Scanner是Java5的新特征，我们可以通过Scanner类来获取用户的输入。创建Sanner对象：Scanners=newScanner(System.in);通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext与hasNextLine判断是否还有输入的数据：importjava.util.Scanner;publicclassScannerDemo{publicstaticvoidmain(String[]args){Scannerscan=newScanner(System.in);//从键盘接收数据//next方式接收字符串System.out.println(&quot;next方式接收：&quot;);//判断是否还有输入if(scan.hasNext()){Stringstr1=scan.next();System.out.println(&quot;输入的数据为：&quot;+str1);}scan.close();}}next()与nextLine()区别next():1、一定要读取到有效字符后才可以结束输入。2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉。3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。next()不能得到带有空格的字符串。nextLine()：1、以Enter为结束符,也就是说nextLine()方法返回的是输入回车之前的所有字符。2、可以获得空白。如果要输入int或float类型的数据，在Scanner类中也有支持，但是在输入之前最好先使用hasNextXxx()方法进行验证，再使用nextXxx()来读取:importjava.util.Scanner;publicclassScannerDemo{publicstaticvoidmain(String[]args){Scannerscan=newScanner(System.in);//从键盘接收数据inti=0;floatf=0.0f;System.out.print(&quot;输入整数：&quot;);if(scan.hasNextInt()){//判断输入的是否是整数i=scan.nextInt();//接收整数System.out.println(&quot;整数数据：&quot;+i);}else{//输入错误的信息System.out.println(&quot;输入的不是整数！&quot;);}System.out.print(&quot;输入小数：&quot;);if(scan.hasNextFloat()){//判断输入的是否是小数f=scan.nextFloat();//接收小数System.out.println(&quot;小数数据：&quot;+f);}else{//输入错误的信息System.out.println(&quot;输入的不是小数！&quot;);}scan.close();}}","link":"https://Vir-Limerence.github.io/post/19-java-scanner-lei/","abstract":"java.util.Scanner是Java5的新特征，我们可以通过Scanner类来获取用户的输入。创建Sanner对象：Scanners=newScanner(System.in);通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext与hasNextLine判断是否还有输入的数据：importjava.util.Scanner;p..."},{"title":"18. Java流、文件和IO","content":"Java.io包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。读取控制台输入Java的控制台输入由System.in完成。为了获得一个绑定到控制台的字符流，你可以把System.in包装在一个BufferedReader对象中来创建一个字符流。BufferedReaderbr=newBufferedReader(newInputStreamReader(System.in));BufferedReader对象创建后，我们便可以使用read()方法从控制台读取一个字符，或者用readLine()方法读取一个字符串。从控制台读取多字符输入从BufferedReader对象读取一个字符要使用read()方法，它的语法如下：intread()throwsIOException每次调用read()方法，它从输入流读取一个字符并把该字符作为整数值返回。当流结束的时候返回-1。该方法抛出IOException。//使用BufferedReader在控制台读取字符importjava.io.*;publicclassBRRead{publicstaticvoidmain(String[]args)throwsIOException{charc;//使用System.in创建BufferedReaderBufferedReaderbr=newBufferedReader(newInputStreamReader(System.in));System.out.println(&quot;输入字符,按下'q'键退出。&quot;);//读取字符do{c=(char)br.read();System.out.println(c);}while(c!='q');}}从控制台读取字符串从标准输入读取一个字符串需要使用BufferedReader的readLine()方法。StringreadLine()throwsIOException//使用BufferedReader在控制台读取字符importjava.io.*;publicclassBRReadLines{publicstaticvoidmain(String[]args)throwsIOException{//使用System.in创建BufferedReaderBufferedReaderbr=newBufferedReader(newInputStreamReader(System.in));Stringstr;System.out.println(&quot;Enterlinesoftext.&quot;);System.out.println(&quot;Enter'end'toquit.&quot;);do{str=br.readLine();System.out.println(str);}while(!str.equals(&quot;end&quot;));}}JDK5后的版本我们也可以使用JavaScanner类来获取控制台的输入。控制台输出控制台的输出由print()和println()完成。这些方法都由类PrintStream定义，System.out是该类对象的一个引用。PrintStream继承了OutputStream类，并且实现了方法write()。这样，write()也可以用来往控制台写操作。voidwrite(intbyteval);//该方法将byteval的低八位字节写到流中。**注意：**write()方法不经常使用，因为print()和println()方法用起来更为方便。读写文件一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。FileInputStream该流用于从文件读取数据，它的对象可以用关键字new来创建。有多种构造方法可用来创建对象。可以使用字符串类型的文件名来创建一个输入流对象来读取文件：InputStreamf=newFileInputStream(&quot;C:/java/hello&quot;);也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用File()方法来创建一个文件对象：Filef=newFile(&quot;C:/java/hello&quot;);InputStreamin=newFileInputStream(f);序号方法及描述1publicvoidclose()throwsIOException{}关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。2protectedvoidfinalize()throwsIOException{}这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其close方法。抛出IOException异常。3publicintread(intr)throwsIOException{}这个方法从InputStream对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。4publicintread(byte[]r)throwsIOException{}这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。5publicintavailable()throwsIOException{}返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。FileOutputStream该类用来创建一个文件并向文件中写数据。如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。有两个构造方法可以用来创建FileOutputStream对象。使用字符串类型的文件名来创建一个输出流对象：OutputStreamf=newFileOutputStream(&quot;C:/java/hello&quot;)也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：Filef=newFile(&quot;C:/java/hello&quot;);OutputStreamfOut=newFileOutputStream(f);序号方法及描述1publicvoidclose()throwsIOException{}关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。2protectedvoidfinalize()throwsIOException{}这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其close方法。抛出IOException异常。3publicvoidwrite(intw)throwsIOException{}这个方法把指定的字节写到输出流中。4publicvoidwrite(byte[]w)把指定数组中w.length长度的字节写到OutputStream中。//文件名:fileStreamTest2.javaimportjava.io.*;publicclassfileStreamTest2{publicstaticvoidmain(String[]args)throwsIOException{Filef=newFile(&quot;a.txt&quot;);FileOutputStreamfop=newFileOutputStream(f);//构建FileOutputStream对象,文件不存在会自动新建OutputStreamWriterwriter=newOutputStreamWriter(fop,&quot;UTF-8&quot;);//构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbkwriter.append(&quot;中文输入&quot;);//写入到缓冲区writer.append(&quot;\\r\\n&quot;);//换行writer.append(&quot;English&quot;);//刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入writer.close();//关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉fop.close();//关闭输出流,释放系统资源FileInputStreamfip=newFileInputStream(f);//构建FileInputStream对象InputStreamReaderreader=newInputStreamReader(fip,&quot;UTF-8&quot;);//构建InputStreamReader对象,编码与写入相同StringBuffersb=newStringBuffer();while(reader.ready()){sb.append((char)reader.read());//转成char加到StringBuffer对象中}System.out.println(sb.toString());reader.close();//关闭读取流fip.close();//关闭输入流,释放系统资源}}java中的目录创建目录File类中有两个方法可以用来创建文件夹：**mkdir()**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。**mkdirs()**方法创建一个文件夹和它的所有父文件夹。importjava.io.File;publicclassCreateDir{publicstaticvoidmain(String[]args){Stringdirname=&quot;/tmp/user/java/bin&quot;;Filed=newFile(dirname);//现在创建目录d.mkdirs();}}读取目录一个目录其实就是一个File对象，它包含其他文件和文件夹。如果创建一个File对象并且它是一个目录，那么调用isDirectory()方法会返回true。可以通过调用该对象上的list()方法，来提取它包含的文件和文件夹的列表。importjava.io.File;publicclassDirList{publicstaticvoidmain(Stringargs[]){Stringdirname=&quot;/tmp&quot;;Filef1=newFile(dirname);if(f1.isDirectory()){System.out.println(&quot;目录&quot;+dirname);Strings[]=f1.list();for(inti=0;i&lt;s.length;i++){Filef=newFile(dirname+&quot;/&quot;+s[i]);if(f.isDirectory()){System.out.println(s[i]+&quot;是一个目录&quot;);}else{System.out.println(s[i]+&quot;是一个文件&quot;);}}}else{System.out.println(dirname+&quot;不是一个目录&quot;);}}}删除目录或文件删除文件可以使用java.io.File.delete()方法。以下代码会删除目录/tmp/java/，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。importjava.io.File;publicclassDeleteFileDemo{publicstaticvoidmain(String[]args){//这里修改为自己的测试目录Filefolder=newFile(&quot;/tmp/java/&quot;);deleteFolder(folder);}//删除文件及目录publicstaticvoiddeleteFolder(Filefolder){File[]files=folder.listFiles();if(files!=null){for(Filef:files){if(f.isDirectory()){deleteFolder(f);}else{f.delete();}}}folder.delete();}}","link":"https://Vir-Limerence.github.io/post/18-java-liu-wen-jian-he-io/","abstract":"Java.io包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。读取控制台输入Java的控制台输入由System.in完成。为了获得一个绑定到控制台的字符流，你可以把System.in包装在一个Buffere..."},{"title":"17. Java方法","content":"😋在前面几个章节中我们经常使用到System.out.println()，那么它是什么呢？println()是一个方法。System是系统类。out是标准输出对象。这句话的用法是调用系统类System中的标准输出对象out中的方法println()。什么是方法Java方法是语句的集合，它们在一起执行一个功能。方法是解决一类问题的步骤的有序组合方法包含于类或对象中方法在程序中被创建，在其他地方被引用方法的优点使程序变得更简短而清晰。有利于程序维护。可以提高程序开发的效率。提高了代码的重用性。方法的命名规则方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：addPerson。下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test_，例如testPop_emptyStack。方法的定义修饰符返回值类型方法名(参数类型参数名){...方法体...return返回值;}**修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。返回值类型：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字void。**方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。**参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。**方法体：**方法体包含具体的语句，定义该方法的功能。方法调用Java支持两种调用方法的方式，根据方法是否返回值来选择。当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。当方法返回一个值的时候，方法调用通常被当做一个值。intlarger=max(30,40);如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。System.out.println(&quot;欢迎访问菜鸟教程！&quot;);方法的重载如果你调用max方法时传递的是int型参数，则int型参数的max方法就会被调用；如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。Java编译器根据方法签名判断哪个方法应该被调用。重载的方法必须拥有不同的参数列表。变量的作用域变量的范围是程序中该变量可以被引用的部分。方法内定义的变量被称为局部变量。局部变量的作用范围从声明开始，直到包含它的块结束。局部变量必须声明才可以使用。方法的参数范围涵盖整个方法。参数实际上是一个局部变量。for循环的初始化部分声明的变量，其作用范围在整个循环。但循环体内声明的变量其适用范围是从它声明到循环体结束。它包含如下所示的变量声明：你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。使用命令行参数publicclassCommandLine{publicstaticvoidmain(String[]args){for(inti=0;i&lt;args.length;i++){System.out.println(&quot;args[&quot;+i+&quot;]:&quot;+args[i]);}}}//args[1]从1开始指代命令行中的变量，args[0]代指this构造对象当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为public，构造函数也为public；类改为protected，构造函数也改为protected)。一旦你定义了自己的构造方法，默认构造方法就会失效。可变参数JDK1.5开始，Java支持传递同类型的可变参数给一个方法。typeName...parameterName在方法声明中，在指定参数类型后加一个省略号(...)。一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。publicstaticvoidprintMax(double...numbers){if(numbers.length==0){System.out.println(&quot;Noargumentpassed&quot;);return;}doubleresult=numbers[0];for(inti=1;i&lt;numbers.length;i++){if(numbers[i]&gt;result){result=numbers[i];}}System.out.println(&quot;Themaxvalueis&quot;+result);}finalize方法Java允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做finalize()，它用来清除回收对象。例如，你可以使用finalize()来确保一个对象打开的文件被关闭了。在finalize()方法里，你必须指定在对象销毁时候要执行的操作。一般格式：protectedvoidfinalize(){//在这里终结代码}关键字protected是一个限定符，它确保finalize()方法不会被该类以外的代码调用。当然，Java的内存回收可以由JVM来自动完成。如果你手动使用，则可以使用上面的方法。publicclassFinalizationDemo{publicstaticvoidmain(String[]args){Cakec1=newCake(1);Cakec2=newCake(2);Cakec3=newCake(3);c2=c3=null;System.gc();//调用Java垃圾收集器}}classCakeextendsObject{privateintid;publicCake(intid){this.id=id;System.out.println(&quot;CakeObject&quot;+id+&quot;iscreated&quot;);}protectedvoidfinalize()throwsjava.lang.Throwable{super.finalize();System.out.println(&quot;CakeObject&quot;+id+&quot;isdisposed&quot;);}}","link":"https://Vir-Limerence.github.io/post/17-java-fang-fa/","abstract":"😋在前面几个章节中我们经常使用到System.out.println()，那么它是什么呢？println()是一个方法。System是系统类。out是标准输出对象。这句话的用法是调用系统类System中的标准输出对象out中的方法println()。什么是方法Java方法是语句的集合，它们在一起执行一个功能。方法是解决一类问题的步骤的有序组合方法包含于类或对象中方法在程序中被创建，在其他地方被引..."},{"title":"16. Java正则表达式","content":"java.util.regex包主要包括以下三类：Pattern类：pattern对象是一个正则表达式的编译表示，Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。PatternSyntaxException：非强制的异常类，用来表示正则表达式中的语法错误importjava.util.regex.Pattern;classRegexExample1{publicstaticvoidmain(String[]args){Stringcontent=&quot;Iamnoob&quot;+&quot;fromrunoob.com.&quot;;Stringpattern=&quot;.*runoob.*&quot;;booleanisMatch=Pattern.matches(pattern,content);System.out.println(&quot;字符串中是否包含了'runoob'子字符串?&quot;+isMatch);}}捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：((A)(B(C)))(A)(B(C))(C)可以通过调用matcher对象的groupCount方法来查看表达式有多少分组，groupCount方法返回一个int值，表示matcher对象当前有多个捕获组。还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在groupCount的返回值中。importjava.util.regex.Matcher;importjava.util.regex.Pattern;publicclassRegexMatches{publicstaticvoidmain(String[]args){//按指定模式在字符串查找Stringline=&quot;ThisorderwasplacedforQT3000!OK?&quot;;Stringpattern=&quot;(\\\\D*)(\\\\d+)(.*)&quot;;//创建Pattern对象Patternr=Pattern.compile(pattern);//现在创建matcher对象Matcherm=r.matcher(line);if(m.find()){System.out.println(&quot;Foundvalue:&quot;+m.group(0));System.out.println(&quot;Foundvalue:&quot;+m.group(1));System.out.println(&quot;Foundvalue:&quot;+m.group(2));System.out.println(&quot;Foundvalue:&quot;+m.group(3));}else{System.out.println(&quot;NOMATCH&quot;);}}}正则表达式语法在Java中，\\\\表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。在其他语言中，\\\\表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。字符说明\\将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，n匹配字符n。\\n匹配换行符。序列\\\\匹配\\，\\(匹配(。^匹配输入字符串开始的位置。如果设置了RegExp对象的Multiline属性，^还会与&quot;\\n&quot;或&quot;\\r&quot;之后的位置匹配。$匹配输入字符串结尾的位置。如果设置了RegExp对象的Multiline属性，$还会与&quot;\\n&quot;或&quot;\\r&quot;之前的位置匹配。*零次或多次匹配前面的字符或子表达式。例如，zo*匹配&quot;z&quot;和&quot;zoo&quot;。*等效于{0,}。+一次或多次匹配前面的字符或子表达式。例如，&quot;zo+&quot;与&quot;zo&quot;和&quot;zoo&quot;匹配，但与&quot;z&quot;不匹配。+等效于{1,}。?零次或一次匹配前面的字符或子表达式。例如，&quot;do(es)?&quot;匹配&quot;do&quot;或&quot;does&quot;中的&quot;do&quot;。?等效于{0,1}。{n}n是非负整数。正好匹配n次。例如，&quot;o{2}&quot;与&quot;Bob&quot;中的&quot;o&quot;不匹配，但与&quot;food&quot;中的两个&quot;o&quot;匹配。{n,}n是非负整数。至少匹配n次。例如，&quot;o{2,}&quot;不匹配&quot;Bob&quot;中的&quot;o&quot;，而匹配&quot;foooood&quot;中的所有o。&quot;o{1,}&quot;等效于&quot;o+&quot;。&quot;o{0,}&quot;等效于&quot;o*&quot;。{n,m}m和n是非负整数，其中n&lt;=m。匹配至少n次，至多m次。例如，&quot;o{1,3}&quot;匹配&quot;fooooood&quot;中的头三个o。'o{0,1}'等效于'o?'。注意：您不能将空格插入逗号和数字之间。?当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是&quot;非贪心的&quot;。&quot;非贪心的&quot;模式匹配搜索到的、尽可能短的字符串，而默认的&quot;贪心的&quot;模式匹配搜索到的、尽可能长的字符串。例如，在字符串&quot;oooo&quot;中，&quot;o+?&quot;只匹配单个&quot;o&quot;，而&quot;o+&quot;匹配所有&quot;o&quot;。.匹配除&quot;\\r\\n&quot;之外的任何单个字符。若要匹配包括&quot;\\r\\n&quot;在内的任意字符，请使用诸如&quot;[\\s\\S]&quot;之类的模式。(pattern)匹配pattern并捕获该匹配的子表达式。可以使用$0…$9属性从结果&quot;匹配&quot;集合中检索捕获的匹配。若要匹配括号字符()，请使用&quot;(&quot;或者&quot;)&quot;。(?:pattern)匹配pattern但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用&quot;or&quot;字符(|)组合模式部件的情况很有用。例如，'industr(?:y|ies)是比'industry|industries'更经济的表达式。(?=pattern)执行正向预测先行搜索的子表达式，该表达式匹配处于匹配pattern的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows(?=95|98|NT|2000)'匹配&quot;Windows2000&quot;中的&quot;Windows&quot;，但不匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。(?!pattern)执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配pattern的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows(?!95|98|NT|2000)'匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;，但不匹配&quot;Windows2000&quot;中的&quot;Windows&quot;。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。x|y匹配x或y。例如，'z|food'匹配&quot;z&quot;或&quot;food&quot;。'(z|f)ood'匹配&quot;zood&quot;或&quot;food&quot;。[xyz]字符集。匹配包含的任一字符。例如，&quot;[abc]&quot;匹配&quot;plain&quot;中的&quot;a&quot;。[^xyz]反向字符集。匹配未包含的任何字符。例如，&quot;[^abc]&quot;匹配&quot;plain&quot;中&quot;p&quot;，&quot;l&quot;，&quot;i&quot;，&quot;n&quot;。[a-z]字符范围。匹配指定范围内的任何字符。例如，&quot;[a-z]&quot;匹配&quot;a&quot;到&quot;z&quot;范围内的任何小写字母。[^a-z]反向范围字符。匹配不在指定的范围内的任何字符。例如，&quot;[^a-z]&quot;匹配任何不在&quot;a&quot;到&quot;z&quot;范围内的任何字符。\\b匹配一个字边界，即字与空格间的位置。例如，&quot;er\\b&quot;匹配&quot;never&quot;中的&quot;er&quot;，但不匹配&quot;verb&quot;中的&quot;er&quot;。\\B非字边界匹配。&quot;er\\B&quot;匹配&quot;verb&quot;中的&quot;er&quot;，但不匹配&quot;never&quot;中的&quot;er&quot;。\\cx匹配x指示的控制字符。例如，\\cM匹配Control-M或回车符。x的值必须在A-Z或a-z之间。如果不是这样，则假定c就是&quot;c&quot;字符本身。\\d数字字符匹配。等效于[0-9]。\\D非数字字符匹配。等效于[^0-9]。\\f换页符匹配。等效于\\x0c和\\cL。\\n换行符匹配。等效于\\x0a和\\cJ。\\r匹配一个回车符。等效于\\x0d和\\cM。\\s匹配任何空白字符，包括空格、制表符、换页符等。与[\\f\\n\\r\\t\\v]等效。\\S匹配任何非空白字符。与[^\\f\\n\\r\\t\\v]等效。\\t制表符匹配。与\\x09和\\cI等效。\\v垂直制表符匹配。与\\x0b和\\cK等效。\\w匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效。\\W与任何非单词字符匹配。与&quot;[^A-Za-z0-9_]&quot;等效。\\xn匹配n，此处的n是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，&quot;\\x41&quot;匹配&quot;A&quot;。&quot;\\x041&quot;与&quot;\\x04&quot;&amp;&quot;1&quot;等效。允许在正则表达式中使用ASCII代码。\\num匹配num，此处的num是一个正整数。到捕获匹配的反向引用。例如，&quot;(.)\\1&quot;匹配两个连续的相同字符。\\n标识一个八进制转义码或反向引用。如果\\n前面至少有n个捕获子表达式，那么n是反向引用。否则，如果n是八进制数(0-7)，那么n是八进制转义码。\\nm标识一个八进制转义码或反向引用。如果\\nm前面至少有nm个捕获子表达式，那么nm是反向引用。如果\\nm前面至少有n个捕获，则n是反向引用，后面跟有字符m。如果两种前面的情况都不存在，则\\nm匹配八进制值nm，其中n和m是八进制数字(0-7)。\\nml当n是八进制数(0-3)，m和l是八进制数(0-7)时，匹配八进制转义码nml。\\un匹配n，其中n是以四位十六进制数表示的Unicode字符。例如，\\u00A9匹配版权符号(©)。根据JavaLanguageSpecification的要求，Java源代码的字符串中的反斜线被解释为Unicode转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被Java字节码编译器解释。Matcher类的方法索引方法序号方法及说明1publicintstart()返回以前匹配的初始索引。2publicintstart(intgroup)返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引3publicintend()返回最后匹配字符之后的偏移量。4publicintend(intgroup)返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。Start方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end方法最后一个匹配字符的索引加1。查找方法序号方法及说明1publicbooleanlookingAt()尝试将从区域开头开始的输入序列与该模式匹配。2publicbooleanfind()尝试查找与该模式匹配的输入序列的下一个子序列。3publicbooleanfind(intstart）重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。4publicbooleanmatches()尝试将整个区域与模式匹配。matches和lookingAt方法都用来尝试匹配一个输入序列模式。它们的不同是matches要求整个序列都匹配，而lookingAt不要求。ookingAt方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。替换方法序号方法及说明1publicMatcherappendReplacement(StringBuffersb,Stringreplacement)实现非终端添加和替换步骤。2publicStringBufferappendTail(StringBuffersb)实现终端添加和替换步骤。3publicStringreplaceAll(Stringreplacement)替换模式与给定替换字符串相匹配的输入序列的每个子序列。4publicStringreplaceFirst(Stringreplacement)替换模式与给定替换字符串匹配的输入序列的第一个子序列。5publicstaticStringquoteReplacement(Strings)返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement方法一个字面字符串一样工作。replaceFirst和replaceAll方法用来替换匹配正则表达式的文本。不同的是，replaceFirst替换首次匹配，replaceAll替换所有匹配。PatternSyntaxException类的方法PatternSyntaxException是一个非强制异常类，它指示一个正则表达式模式中的语法错误。PatternSyntaxException类提供了下面的方法来帮助我们查看发生了什么错误。序号方法及说明1publicStringgetDescription()获取错误的描述。2publicintgetIndex()获取错误的索引。3publicStringgetPattern()获取错误的正则表达式模式。4publicStringgetMessage()返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。","link":"https://Vir-Limerence.github.io/post/16-java-zheng-ze-biao-da-shi/","abstract":"java.util.regex包主要包括以下三类：Pattern类：pattern对象是一个正则表达式的编译表示，Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也..."},{"title":"15. Java日期时间","content":"java.util包提供了Date类来封装当前的日期和时间。Date类提供两个构造函数来实例化Date对象：//使用当前日期和时间来初始化对象Date()//接收参数，参数是从1970年1月1日起的毫秒数Date(longmillisec)Date对象的方法有：序号方法和描述1booleanafter(Datedate)若当调用此方法的Date对象在指定日期之后返回true,否则返回false。2booleanbefore(Datedate)若当调用此方法的Date对象在指定日期之前返回true,否则返回false。3Objectclone()返回此对象的副本。4intcompareTo(Datedate)比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。5intcompareTo(Objectobj)若obj是Date类型则操作等同于compareTo(Date)。否则它抛出ClassCastException。6booleanequals(Objectdate)当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。7longgetTime()返回自1970年1月1日00:00:00GMT以来此Date对象表示的毫秒数。8inthashCode()返回此对象的哈希码值。9voidsetTime(longtime)用自1970年1月1日00:00:00GMT以后time毫秒数设置时间和日期。10StringtoString()把此Date对象转换为以下形式的String：dowmonddhh:mm:sszzzyyyy其中：dow是一周中的某一天(Sun,Mon,Tue,Wed,Thu,Fri,Sat)。获取当前日期时间Java中获取当前日期和时间很简单，使用Date对象的toString()方法来打印当前日期和时间importjava.util.Date;publicclassDateDemo{publicstaticvoidmain(String[]args){//初始化Date对象Datedate=newDate();//使用toString()函数显示日期时间System.out.println(date.toString());}}日期比较Java使用以下三种方法来比较两个日期：使用getTime()方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。使用方法before()，after()和equals()。例如，一个月的12号比18号早，则newDate(99,2,12).before(newDate(99,2,18))返回true。使用compareTo()方法，它是由Comparable接口定义的，Date类实现了这个接口。SimpleDateFormat格式化日期SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat允许你选择任何用户自定义日期时间格式来运行。importjava.util.Date;importjava.text.SimpleDateFormat;publicclassDateDemo{publicstaticvoidmain(String[]args){DatedNow=newDate();SimpleDateFormatft=newSimpleDateFormat(&quot;yyyy-MM-ddhh:mm:ss&quot;);System.out.println(&quot;当前时间为:&quot;+ft.format(dNow));}}printf格式化日期printf方法可以很轻松地格式化时间和日期。使用两个字母格式，它以%t开头并且以下面表格中的一个字母结尾。%tY：输出四位数的年份，例如：2023%ty：输出两位数的年份，例如：23%tm：输出两位数的月份，例如：02%tB：输出月份的全名，例如：February%tb：输出月份的缩写，例如：Feb%tA：输出星期的全名，例如：Wednesday%ta：输出星期的缩写，例如：Wed%td：输出两位数的日期，例如：24%te：输出一位或两位数的日期，例如：24或02%tH：输出24小时制的小时数，例如：23%tI：输出12小时制的小时数，例如：11%tM：输出分钟数，例如：45%tS：输出秒数，例如：30%tp：输出上午还是下午，例如：AM或PM%tZ：输出时区，例如：GMT+08:00转换符说明示例%tc包括全部日期和时间信息星期六十月2714:21:20CST2007%tF&quot;年-月-日&quot;格式2007-10-27%tD&quot;月/日/年&quot;格式10/27/07%tr&quot;HH:MM:SSPM&quot;格式（12时制）02:25:51下午%tT&quot;HH:MM:SS&quot;格式（24时制）14:28:16%tR&quot;HH:MM&quot;格式（24时制）14:28更多的printf解析，可以参见：Java格式化输出printf例子importjava.util.Date;publicclassDateFormatExample{publicstaticvoidmain(String[]args){Datedate=newDate();System.out.printf(&quot;%tY-%tm-%td%tH:%tM:%tS%tZ&quot;,date,date,date,date,date,date);}}可以利用一个格式化字符串指出要被格式化的参数的索引。索引必须紧跟在%后面，而且必须以$结束。例如：importjava.util.Date;publicclassDateDemo{publicstaticvoidmain(String[]args){//初始化Date对象Datedate=newDate();//使用toString()显示日期和时间System.out.printf(&quot;%1$s%2$tB%2$td,%2$tY&quot;,&quot;Duedate:&quot;,date);//或者，可以使用&lt;标志。它表明先前被格式化的参数要被再次使用。System.out.printf(&quot;%s%tB%&lt;te,%&lt;tY&quot;,&quot;Duedate:&quot;,date);}}结果：Duedate:February09,2014将字符串解析为时间SimpleDateFormat类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat对象的格式化存储来解析字符串。importjava.util.Date;importjava.text.SimpleDateFormat;publicclassDateDemo{publicstaticvoidmain(String[]args){SimpleDateFormatft=newSimpleDateFormat(&quot;yyyy-MM-dd&quot;);Stringinput=args.length==0?&quot;1818-11-11&quot;:args[0];System.out.print(input+&quot;Parsesas&quot;);Datet;try{t=ft.parse(input);System.out.println(t);}catch(ParseExceptione){System.out.println(&quot;Unparseableusing&quot;+ft);}}}Java中的休眠sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。使用java.util.Thread包。importjava.util.Thread;publicclassSleepDemo{publicstaticvoidmain(String[]args){try{System.out.println(newDate()+&quot;\\n&quot;);Thread.sleep(1000*3);//休眠3秒System.out.println(newDate()+&quot;\\n&quot;);}catch(Exceptione){System.out.println(&quot;Gotanexception!&quot;);}}}操作日期Calendar类Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。创建一个代表系统当前日期的Calendar对象Calendarc=Calendar.getInstance();//默认是当前日期创建一个指定日期的Calendar对象使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。//创建一个代表2009年7月12日的Calendar对象//Calendar的月份是从0开始的，但日期和年份是从1开始的Calendarc1=Calendar.getInstance();c1.set(2009,6,12);Calendar类对象字段类型常量描述Calendar.YEAR年份Calendar.MONTH月份Calendar.DATE日期Calendar.DAY_OF_MONTH日期，和上面的字段意义完全相同Calendar.HOUR12小时制的小时Calendar.HOUR_OF_DAY24小时制的小时Calendar.MINUTE分钟Calendar.SECOND秒Calendar.DAY_OF_WEEK星期几Set设置、Add设置和Get设置Calendarc1=Calendar.getInstance();c1.set(2009,6,12);//把Calendar对象c1的年月日分别设这为：2009、6、12//set方法c1.set(Calendar.YEAR,2008);//设置年份//add方法c1.add(Calendar.DATE,-10);//日期减10//get方法intyear=c1.get(Calendar.YEAR);//获得年份GregorianCalendar类Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。Calendar的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。不具体介绍","link":"https://Vir-Limerence.github.io/post/15-java-ri-qi-shi-jian/","abstract":"java.util包提供了Date类来封装当前的日期和时间。Date类提供两个构造函数来实例化Date对象：//使用当前日期和时间来初始化对象Date()//接收参数，参数是从1970年1月1日起的毫秒数Date(longmillisec)Date对象的方法有：序号方法和描述1booleanafter(Datedate)若当调用此方法的Date对象在指定日期之后返回true,否则返回false。2..."},{"title":"14. Java数组","content":"Java语言中数组是用来存储固定大小的同类型元素。声明数组数组变量必须先声明，才能在程序中使用，一般有以下两种方式：dataType[]arrayRefVar;//首选的方法或dataTypearrayRefVar[];//效果相同，但不是首选方法创建数组Java语言使用new操作符来创建数组arrayRefVar=newdataType[arraySize];new操作符做了两件事：使用dataType[arraySize]创建了一个数组将数组的引用赋值给变量arrayRefVar简写形式如下：dataType[]arrayRefVar=newdataType[arraySize];或dataType[]arrayRefVar={value0,value1,...,valuek};处理数组使用基本循环或者For-Each循环//基本循环for(;;){}//for-each循环，可以在不使用下标的情况下遍历数组for(typeelement:array){//}数组作为参数和返回值//数组作为函数的参数publicstaticvoidprintArray(int[]array)//数组作为函数的返回值publicstaticint[]reverse(int[]list)多维数组多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组String[][]str=newString[3][4];多维数组的动态初始化直接为每一维分配空间type[][]typeName=newtype[typeLength1][typeLength2];从最高维开始，分别为每一维分配空间String[][]s=newString[2][];s[0]=newString[2];s[1]=newString[3];多维数组的引用//对二维数组中的每个元素，引用方式为arrayName[index1][index2]num[1][0];Arrays类java.util.Arrays类能够方便地操作数组，它提供的所有方法都是静态的给数组赋值，使用fill方法对数组排序，使用sort方法比较数组，通过equals方法比较数组中的元素值是否相等查找数组元素，通过binarySearch方法能够对排序好的数组进行二分查找序号方法和说明1publicstaticintbinarySearch(Object[]a,Objectkey)用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回(-(插入点)-1)。2publicstaticbooleanequals(long[]a,long[]a2)如果两个指定的long型数组彼此相等，则返回true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。3publicstaticvoidfill(int[]a,intval)将指定的int值分配给指定int型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。4publicstaticvoidsort(Object[]a)对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。","link":"https://Vir-Limerence.github.io/post/14-java-shu-zu/","abstract":"Java语言中数组是用来存储固定大小的同类型元素。声明数组数组变量必须先声明，才能在程序中使用，一般有以下两种方式：dataType[]arrayRefVar;//首选的方法或dataTypearrayRefVar[];//效果相同，但不是首选方法创建数组Java语言使用new操作符来创建数组arrayRefVar=newdataType[arraySize];new操作符做了两件事：使用data..."},{"title":"13. Java StringBuffer","content":"对字符串进行修改的时候，需要使用StringBuffer和StringBuilder类，和String对象不同的是，StringBuffer和StringBuilder类的对象可以被多次修改，并且不产生新的未使用对象.使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改时推荐使用StringBuffer.StringBuilder和StringBuffer之间的最大不同在于StringBuilder的方法不是线程安全的（不能同步访问），但是StringBuilder的速度更快，所以多数情况下建议使用StringBuilder.在应用程序要求线程安全的情况下，必须使用StringBuffer类StringBuffer方法主要方法：序号方法描述1publicStringBufferappend(Strings)将指定的字符串追加到此字符序列。2publicStringBufferreverse()将此字符序列用其反转形式取代。3publicdelete(intstart,intend)移除此序列的子字符串中的字符。4publicinsert(intoffset,inti)将int参数的字符串表示形式插入此序列中。5insert(intoffset,Stringstr)将str参数的字符串插入此序列中。6replace(intstart,intend,Stringstr)使用给定String中的字符替换此序列的子字符串中的字符。其它方法：序号方法描述1intcapacity()返回当前容量。2charcharAt(intindex)返回此序列中指定索引处的char值。3voidensureCapacity(intminimumCapacity)确保容量至少等于指定的最小值。4voidgetChars(intsrcBegin,intsrcEnd,char[]dst,intdstBegin)将字符从此序列复制到目标字符数组dst。5intindexOf(Stringstr)返回第一次出现的指定子字符串在该字符串中的索引。6intindexOf(Stringstr,intfromIndex)从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。7intlastIndexOf(Stringstr)返回最右边出现的指定子字符串在此字符串中的索引。8intlastIndexOf(Stringstr,intfromIndex)返回String对象中子字符串最后出现的位置。9intlength()返回长度（字符数）。10voidsetCharAt(intindex,charch)将给定索引处的字符设置为ch。11voidsetLength(intnewLength)设置字符序列的长度。12CharSequencesubSequence(intstart,intend)返回一个新的字符序列，该字符序列是此序列的子序列。13Stringsubstring(intstart)返回一个新的String，它包含此字符序列当前所包含的字符子序列。14Stringsubstring(intstart,intend)返回一个新的String，它包含此序列当前所包含的字符子序列。15StringtoString()返回此序列中数据的字符串表示形式。关于StringBuffer类和StringBuilder类的更多内容：StringBuffer类：https://www.runoob.com/manual/jdk11api/java.base/java/lang/StringBuffer.htmlStringBuilder类：https://www.runoob.com/manual/jdk11api/java.base/java/lang/StringBuilder.html","link":"https://Vir-Limerence.github.io/post/13-java-stringbuffer/","abstract":"对字符串进行修改的时候，需要使用StringBuffer和StringBuilder类，和String对象不同的是，StringBuffer和StringBuilder类的对象可以被多次修改，并且不产生新的未使用对象.使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改时推荐使用StringBuffer.String..."},{"title":"为网站（文档）自定义聊天机器人","content":"网址：https://knowbo.ai/功能介绍：使用机器人：","link":"https://Vir-Limerence.github.io/post/wei-wang-zhan-wen-dang-zi-ding-yi-liao-tian-ji-qi-ren/","abstract":"网址：https://knowbo.ai/功能介绍：使用机器人："},{"title":"写完一篇博客，Gridea数据被清空了","content":"什么原因根据我的观察，如果你是因为写完一篇博客Gridea打不开了，很有可能是最新写的这篇文章有什么问题举例我在使用gridea写博客的时候，是直接在posts文件夹使用Typora进行编辑的，这就导致我不小心把图片放到了posts文件夹，这里建议可以使用Typora的图床功能解决办法删除posts中的图片就好了建议如果是最后一篇博客出问题了，建议先删除相关博客的内容，应该就能恢复正常了参考博客关于Gridea数据（文章，标签清空）的原因和解决方法","link":"https://Vir-Limerence.github.io/post/xie-wan-yi-pian-bo-ke-gridea-tu-ran-da-bu-kai-liao/","abstract":"什么原因根据我的观察，如果你是因为写完一篇博客Gridea打不开了，很有可能是最新写的这篇文章有什么问题举例我在使用gridea写博客的时候，是直接在posts文件夹使用Typora进行编辑的，这就导致我不小心把图片放到了posts文件夹，这里建议可以使用Typora的图床功能解决办法删除posts中的图片就好了建议如果是最后一篇博客出问题了，建议先删除相关博客的内容，应该就能恢复正常了参考博客关..."},{"title":"亿图脑图导出","content":"思路——&gt;先导出文本（免费的，文本可能出现排版错误，需要微调）——&gt;python处理文本，转换为md格式——&gt;使用markmap——&gt;可导出为svg或者html格式样例网站https://mm.edrawsoft.cn/template/156937超巨大的思维导图处理脚本withopen('xx.txt','r',encoding='utf-8')asf:lines=f.readlines()importref=open('xx.mm.md','w',encoding='utf-8')forlineinlines:#匹配中文字符pattern=re.compile(r'[^\\s*]')match=pattern.search(line)#print(match)ifmatch:spaces_before=len(re.findall(r'^\\s*',line[:match.start()])[0])#line=line.replace('\\t','')ifspaces_before&lt;=5:line=line[:match.start()]+'#'+'#'*spaces_before+''+line[match.start():]else:line=line[:match.start()]+''*(spaces_before-6)+'-'+line[match.start():]line=line.replace('\\t','')print(line,end='')f.write(line)f.close()使用markmap可以使用在线网址，也可以安装vscode插件——markmapDownload可以下载Html或者Svg格式","link":"https://Vir-Limerence.github.io/post/yi-tu-nao-tu-dao-chu/","abstract":"思路——&gt;先导出文本（免费的，文本可能出现排版错误，需要微调）——&gt;python处理文本，转换为md格式——&gt;使用markmap——&gt;可导出为svg或者html格式样例网站https://mm.edrawsoft.cn/template/156937超巨大的思维导图处理脚本withopen('xx.txt','r',encoding='utf-8')asf:lines=f...."},{"title":"10. Java Number和Math类","content":"需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double等，Java语言为每一个内置数据类型提供了对应的包装类。所有的包装类Integer、Long、Byte、Double、Float、Short都是抽象类Number的子类。包装类基本数据类型BooleanbooleanBytebyteShortshortIntegerintLonglongCharactercharFloatfloatDoubledouble关系图：这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number类属于java.lang包。JavaMath类Java的Math包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。Math的方法都被定义为static形式，通过Math类可以在主函数中直接调用。Number&amp;Math类方法序号方法与描述1xxxValue()将Number对象转换为xxx数据类型的值并返回。2compareTo()将number对象与参数比较。3equals()判断number对象是否与参数相等。4valueOf()返回一个Number对象指定的内置数据类型5toString()以字符串形式返回值。6parseInt()将字符串解析为int类型。7abs()返回参数的绝对值。8ceil()返回大于等于(&gt;=)给定参数的的最小整数，类型为双精度浮点型。9floor()返回小于等于（&lt;=）给定参数的最大整数。10rint()返回与参数最接近的整数。返回类型为double。11round()它表示四舍五入，算法为Math.floor(x+0.5)，即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。12min()返回两个参数中的最小值。13max()返回两个参数中的最大值。14exp()返回自然数底数e的参数次方。15log()返回参数的自然数底数的对数值。16pow()返回第一个参数的第二个参数次方。17sqrt()求参数的算术平方根。18sin()求指定double类型参数的正弦值。19cos()求指定double类型参数的余弦值。20tan()求指定double类型参数的正切值。21asin()求指定double类型参数的反正弦值。22acos()求指定double类型参数的反余弦值。23atan()求指定double类型参数的反正切值。24atan2()将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。25toDegrees()将参数转化为角度。26toRadians()将角度转换为弧度。27random()返回一个随机数。Math的floor,round和ceil方法实例比较参数Math.floorMath.roundMath.ceil1.41121.51221.6122-1.4-2-1-1-1.5-2-1-1-1.6-2-2-1","link":"https://Vir-Limerence.github.io/post/10-java-number-he-math-lei/","abstract":"需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double等，Java语言为每一个内置数据类型提供了对应的包装类。所有的包装类Integer、Long、Byte、Double、Float、Short都是抽象类Number的子类。包装类基本数据类型BooleanbooleanBytebyteShortshortIntegerintLonglongCharacterch..."},{"title":"9. Java循环结构","content":"主要有三种循环结构：while循环do…while循环for循环while循环while(布尔表达式){//循环内容}//只要布尔表达式为true，循环就会一直执行下去。dowhile循环do{//代码语句}while(布尔表达式);//至少会执行一次for循环for(初始化;布尔表达式;更新){//代码语句}Java5引入了一种主要用于数组的增强型for循环。for(声明语句:表达式){//代码句子}声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。表达式：表达式是要访问的数组名，或者是返回值为数组的方法。break关键字break主要用在循环语句或者switch语句中，用来跳出整个语句块。break跳出最里层的循环，并且继续执行该循环下面的语句。continue关键字continue适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在for循环中，continue语句使程序立即跳转到更新语句。在while或者do…while循环中，程序立即跳转到布尔表达式的判断语句。","link":"https://Vir-Limerence.github.io/post/9-java-xun-huan-jie-gou/","abstract":"主要有三种循环结构：while循环do…while循环for循环while循环while(布尔表达式){//循环内容}//只要布尔表达式为true，循环就会一直执行下去。dowhile循环do{//代码语句}while(布尔表达式);//至少会执行一次for循环for(初始化;布尔表达式;更新){//代码语句}Java5引入了一种主要用于数组的增强型for循环。for(声明语句:表达式){//代码..."},{"title":"8. Java运算符","content":"运算符类型：算数运算符、关系运算符、位运算符、逻辑运算符、赋值运算符、其他运算符算数运算符操作符描述例子+加法-相加运算符两侧的值A+B等于30-减法-左操作数减去右操作数A–B等于-10*乘法-相乘操作符两侧的值A*B等于200/除法-左操作数除以右操作数B/A等于2％取余-左操作数除以右操作数的余数B%A等于0++自增:操作数的值增加1B++或++B等于21（区别详见下文）--自减:操作数的值减少1B--或--B等于19（区别详见下文）自增自减运算符自增（++）自减（--）运算符是一种特殊的算术运算符，在算术运算符中需要两个操作数来进行运算，而自增自减运算符是一个操作数。前缀自增自减法(++a,--a):先进行自增或者自减运算，再进行表达式运算。后缀自增自减法(a++,a--):先进行表达式运算，再进行自增或者自减运算关系运算符运算符描述例子==检查如果两个操作数的值是否相等，如果相等则条件为真。（A==B）为假。!=检查如果两个操作数的值是否相等，如果值不相等则条件为真。(A!=B)为真。&gt;检查左操作数的值是否大于右操作数的值，如果是那么条件为真。（A&gt;B）为假。&lt;检查左操作数的值是否小于右操作数的值，如果是那么条件为真。（A&lt;B）为真。&gt;=检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。（A&gt;=B）为假。&lt;=检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。（A&lt;=B）为真。位运算符Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。位运算符作用在所有的位上，并且按位运算。作符描述例子＆如果相对应位都是1，则结果为1，否则为0（A＆B），得到12，即00001100|如果相对应位都是0，则结果为0，否则为1（A|B）得到61，即00111101^如果相对应位值相同，则结果为0，否则为1（A^B）得到49，即00110001〜按位取反运算符翻转操作数的每一位，即0变成1，1变成0。（〜A）得到-61，即11000011&lt;&lt;按位左移运算符。左操作数按位左移右操作数指定的位数。A&lt;&lt;2得到240，即11110000&gt;&gt;按位右移运算符。左操作数按位右移右操作数指定的位数。A&gt;&gt;2得到15即1111&gt;&gt;&gt;按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。A&gt;&gt;&gt;2得到15逻辑运算符操作符描述例子&amp;&amp;称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。（A&amp;&amp;B）为假。||称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。（A||B）为真。！称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。！（A&amp;&amp;B）为真。短路逻辑运算符当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。赋值运算符操作符描述例子=简单的赋值运算符，将右操作数的值赋给左侧操作数C=A+B将把A+B得到的值赋给C+=加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数C+=A等价于C=C+A-=减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数C-=A等价于C=C-A*=乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数C*=A等价于C=C*A/=除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数C/=A，C与A同类型时等价于C=C/A（％）=取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数C％=A等价于C=C％A&lt;&lt;=左移位赋值运算符C&lt;&lt;=2等价于C=C&lt;&lt;2&gt;&gt;=右移位赋值运算符C&gt;&gt;=2等价于C=C&gt;&gt;2＆=按位与赋值运算符C＆=2等价于C=C＆2^=按位异或赋值操作符C^=2等价于C=C^2|=按位或赋值操作符C|=2等价于C=C|2条件运算符（?:）条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。variablex=(expression)?valueiftrue:valueiffalse;instanceof运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。(Objectreferencevariable)instanceof(class/interfacetype)如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。java运算符优先级类别操作符关联性后缀()[].(点操作符)左到右一元expr++expr--从左到右一元++expr--expr+-～！从右到左乘性*/％左到右加性+-左到右移位&gt;&gt;&gt;&gt;&gt;&lt;&lt;左到右关系&gt;&gt;=&lt;&lt;=左到右相等==!=左到右按位与＆左到右按位异或^左到右按位或|左到右逻辑与&amp;&amp;左到右逻辑或||左到右条件？：从右到左赋值=+=-=*=/=％=&gt;&gt;=&lt;&lt;=＆=^=|=从右到左逗号，左到右","link":"https://Vir-Limerence.github.io/post/8-java-yun-suan-fu/","abstract":"运算符类型：算数运算符、关系运算符、位运算符、逻辑运算符、赋值运算符、其他运算符算数运算符操作符描述例子+加法-相加运算符两侧的值A+B等于30-减法-左操作数减去右操作数A–B等于-10*乘法-相乘操作符两侧的值A*B等于200/除法-左操作数除以右操作数B/A等于2％取余-左操作数除以右操作数的余数B%A等于0++自增:操作数的值增加1B++或++B等于21（区别详见下文）--自减:操作数的值..."},{"title":"7. Java修饰符","content":"Java语言提供了很多修饰符，主要分为两类：访问修饰符非访问修饰符修饰符用来定义类、方法或者变量，通常放在语句的最前端。例如public、protected、private等。访问控制修饰符java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。default(即默认，什么也不写）:在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。private:在同一类内可见。使用对象：变量、方法。注意：不能修饰类（外部类）public:对所有类可见。使用对象：类、接口、变量、方法protected:对同一包内的类和所有子类可见。使用对象：变量、方法。注意：不能修饰类（外部类）。修饰符当前类同一包内子孙类(同一包)子孙类(不同包)其他包publicYYYYYprotectedYYYY/N（说明）NdefaultYYYNNprivateYNNNN默认访问修饰符-不使用任何关键字如果在类、变量、方法或构造函数的定义中没有指定任何访问修饰符，那么它们就默认具有默认访问修饰符。默认访问修饰符的访问级别是包级别（package-level），即只能被同一包中的其他类访问。私有访问修饰符-private私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。公有访问修饰符-public被声明为public的类、方法、构造方法和接口能够被任何其他类访问。如果几个相互访问的public类分布在不同的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。受保护的访问修饰符-protectedprotected需要从以下两个点来分析说明：子类与基类在同一包中：被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问；子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。protected可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。接口及接口的成员变量和成员方法不能声明为protected。子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。示例：//父类使用了protected访问修饰符，子类重写了父类的openSpeaker()方法classAudioPlayer{protectedbooleanopenSpeaker(Speakersp){//实现细节}}classStreamingAudioPlayerextendsAudioPlayer{protectedbooleanopenSpeaker(Speakersp){//实现细节}}/*如果把openSpeaker()方法声明为private，那么除了AudioPlayer外，其他类将不能访问该方法。如果把openSpeaker()声明为public，那么所有的类都能够访问该方法。如果我们只想让该方法对其所在类的子类可见，则将该方法声明为protected。*/protected是最难理解的一种Java类成员访问权限修饰词,具体内容请查看Javaprotected关键字详解。访问控制和继承继承的规则：父类中声明为public的方法在子类中也必须为public父类中声明为protected的方法在子类中要么声明为protected，要么声明为public，不能声明为private。父类中声明为private的方法，不能够被子类继承。非访问修饰符static修饰符，用来修饰类方法和类变量。final修饰符，用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。abstract修饰符，用来创建抽象类和抽象方法。synchronized和volatile修饰符，主要用于线程的编程。static修饰符静态变量：static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为static变量。静态方法：static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。对类变量和方法的访问可以直接使用classname.variablename和classname.methodname的方式访问。final修饰符变量：final表示&quot;最后的、最终的&quot;含义，变量一旦赋值后，不能被重新赋值。被final修饰的实例变量必须显式指定初始值。final修饰符通常和static修饰符一起使用来创建类常量。方法：父类中的final方法可以被子类继承，但是不能被子类重写。声明final方法的主要目的是防止该方法的内容被修改。类：final类不能被继承，没有类能够继承final类的任何特性。abstract修饰符抽象类：抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。抽象类可以包含抽象方法和非抽象方法。示例：abstractclassCaravan{privatedoubleprice;privateStringmodel;privateStringyear;publicabstractvoidgoFast();//抽象方法publicabstractvoidchangeColor();}抽象方法：抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。抽象方法不能被声明成final和static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象方法的声明以分号结尾，例如：publicabstractsample();。示例：publicabstractclassSuperClass{abstractvoidm();//抽象方法}classSubClassextendsSuperClass{//实现抽象方法voidm(){.........}}synchronized修饰符synchronized关键字声明的方法同一时间只能被一个线程访问。synchronized修饰符可以应用于四个访问修饰符。publicsynchronizedvoidshowDetails(){.......}transient修饰符序列化的对象包含被transient修饰的实例变量时，java虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。publictransientintlimit=55;//不会持久化publicintb;//持久化volatile修饰符volatile修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。publicclassMyRunnableimplementsRunnable{privatevolatilebooleanactive;publicvoidrun(){active=true;while(active)//第一行{//代码}}publicvoidstop(){active=false;//第二行}}","link":"https://Vir-Limerence.github.io/post/7-java-xiu-shi-fu/","abstract":"Java语言提供了很多修饰符，主要分为两类：访问修饰符非访问修饰符修饰符用来定义类、方法或者变量，通常放在语句的最前端。例如public、protected、private等。访问控制修饰符java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。default(即默认，什么也不写）:在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。pr..."},{"title":"6. Java变量类型","content":"在java语言中，所有的变量在使用前必须声明，声明变量的基本格式如下：typeidentifier[=value][,identifier[=value]...];格式说明：type：数据类型identifier：变量名，可以使用逗号,隔开来声明多个同类型变量java支持的变量类型有：局部变量：定义在方法、构造方法或语句块中的变量，作用域只限于当前方法、构造方法或语句块中。局部变量必须在使用前声明，并且不能被访问修饰符修饰。成员变量：定义在类中、方法之外的变量，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问。成员变量可以被访问修饰符修饰。静态变量：定义在类中、方法之外的变量，并且使用static关键字修饰，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问，静态变量的值在程序运行期间只有一个副本。静态变量可以被访问修饰符修饰。参数变量：方法定义时声明的变量，作为调用该方法时传递给方法的值。参数变量的作用域只限于方法内部。示例：publicclassRunoobTest{//成员变量privateintinstanceVar;//静态变量privatestaticintstaticVar;publicvoidmethod(intparamVar){//局部变量intlocalVar=10;//使用变量instanceVar=localVar;staticVar=paramVar;System.out.println(&quot;成员变量:&quot;+instanceVar);System.out.println(&quot;静态变量:&quot;+staticVar);System.out.println(&quot;参数变量:&quot;+paramVar);System.out.println(&quot;局部变量:&quot;+localVar);}publicstaticvoidmain(String[]args){RunoobTestv=newRunoobTest();v.menthod(20);}}Java参数变量Java中的参数变量是指在方法或构造函数中声明的变量，用于接收传递给方法或构造函数的值。参数变量与局部变量类似，但它们只在方法或构造函数被调用时存在，并且只能在方法或构造函数内部使用。在调用方法时，我们必须为参数变量传递值，这些值可以是常量、变量或表达式。方法参数变量的值传递方式有两种：值传递和引用传递。值传递：在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java中的基本数据类型都采用值传递方式传递参数变量的值。引用传递：在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java中的对象类型采用引用传递方式传递参数变量的值。Java局部变量局部变量声明在方法，构造方法或者语句块中局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。局部变量必须在使用前声明，并且不能被访问修饰符修饰，因为它们的作用域已经被限制在了声明它们的方法、代码块或构造函数中。局部变量只在声明它的方法、构造方法或者语句块中可见，不能被其他方法或代码块访问。局部变量是在栈上分配的。局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。局部变量必须在使用之前进行初始化，否则编译器会报错。初始化可以在声明时或后面的代码中进行。如果在声明时未初始化，变量将被赋予默认值，如int类型的变量默认为0，boolean类型的变量默认为false，引用类型的变量默认为null。局部变量只在声明它的方法、构造方法或语句块内可见，其他方法、构造方法或语句块不能访问该局部变量。当方法、构造方法或语句块执行完毕后，局部变量将被销毁，其占用的内存也会被释放。成员变量（实例变量）成员变量声明在一个类中，但在方法、构造方法和语句块之外当一个对象被实例化之后，每个成员变量的值就跟着确定了成员变量在对象创建的时候创建，在对象销毁的时候被销毁成员变量的值至少应该被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息成员变量可以声明在使用前或者使用后访问修饰符可以修饰成员变量成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设置为私有，通过访问修饰符可以使得成员变量对子类可见成员变量具有默认值，数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定成员变量可以直接通过变量名访问，但是在静态方法以及其它类中，就应该使用完全限定名：ObjectReference.VariableName成员变量的声明语法为：accessModifiertypevariableNameaccessModifier表示访问修饰符，可以是public、protected、private或默认访问级别（没有显式指定访问修饰符）type表示变量的类型variableName表示变量的名称与局部变量不同，成员变量的值在创建对象时被分配，即使未对其进行初始化，也会被赋予默认值，例如int类型的变量默认值为0，boolean类型的变量默认值为false。成员变量可以通过对象访问，也可以通类名访问（如果时静态成员变量）。如果没有显示初始化成员变量，将会被赋予默认值。可以在构造函数或者其它方法中初始化成员变量，或者通过对象或类名访问并且设置值。示例：publicclassRunoobTest{privateinta;//私有成员变量publicStringb=&quot;Hello!&quot;;//共有成员变量publicstaticvoidmain(String[]args){RunoobTestobj=newRunoobTest();//创建对象obj.a=10;//访问成员变量a，设置值为10System.out.println(&quot;a=&quot;+obj.a);obj.b=&quot;World！&quot;;System.out.println(&quot;b=&quot;+obuj.b);}}类变量（静态变量）java中的静态变量是指类中定义的一个变量，它与类相关而不是与实例相关，无论创建多少个类实例，静态变量在内存中只有一份拷贝，被所有实例共享。静态变量在类加载时被创建，整个程序运行期间都存在。定义方式静态变量的定义方式是在类中使用static关键字修饰变量，通常也称为类变量。访问方式由于静态变量是与类相关的，因此可以通过类名来访问静态变量，也可以通过实例名来访问静态变量。生命周期静态变量的生命周期与程序的生命周期一样长，即它们在类加载时被创建，在整个程序运行期间都存在，直到程序结束才会被销毁。因此，静态变量可以用来存储整个程序都需要使用的数据，如配置信息、全局变量等。初始化时机静态变量在类加载时被初始化，其初始化顺序与定义顺序有关。如果一个静态变量依赖于另一个静态变量，那么它必须在后面定义。常量与静态变量的区别常量也是与类相关的，但它是用final关键字修饰的变量，一旦被赋值就不能再修改。与静态变量不同的是，常量在编译时就已经确定了它的值，而静态变量的值可以在运行时改变。静态变量是与类相关的变量，具有唯一性和共享性，可以用于存储整个程序都需要使用的数据，但需要注意初始化时机和与常量的区别。静态变量的访问修饰符静态变量的访问修饰符可以是public、protected、private或者默认的访问修饰符（即不写访问修饰符）。需要注意的是，静态变量的访问权限与实例变量不同，因为静态变量是与类相关的，不依赖于任何实例。静态变量的线程安全性由于静态变量是共享的，所以需要注意其线程安全性。多个线程同时对静态变量进行读写操作可能会导致数据不一致或者出现静态条件。因此，在多线程环境中使用静态变量时需要进行同步操作或者使用线程安全的方式访问。命名规则静态变量的命名规范与实例变量相同，一般采用驼峰命名法，并且要用static关键字明确标识。publicstaticintMAX_COUNT=100;静态变量的使用场景存储全局状态或配置信息计数器或统计信息缓存数据或共享资源工具类的常量或方法单例模式中的实例变量示例：publicclassAppConfig{//静态变量+常量publicstaticfinalStringAPP_NAME=&quot;MyApp&quot;;publicstaticfinalStringAPP_VERSION=&quot;1.0.0&quot;;publicstaticfinalStringDATABASE_URL=&quot;jdbc:mysql://localhost:3306/mydb&quot;;publicstaticvoidmain(String[]args){System.out.println(&quot;Applicationname:&quot;+AppConfig.APP_NAME);System.out.println(&quot;Applicationversion:&quot;+AppConfig.APP_VERSION);System.out.println(&quot;DatabaseURL:&quot;+AppConfig.DATABASE_URL);}}","link":"https://Vir-Limerence.github.io/post/6-java-bian-liang-lei-xing/","abstract":"在java语言中，所有的变量在使用前必须声明，声明变量的基本格式如下：typeidentifier[=value][,identifier[=value]...];格式说明：type：数据类型identifier：变量名，可以使用逗号,隔开来声明多个同类型变量java支持的变量类型有：局部变量：定义在方法、构造方法或语句块中的变量，作用域只限于当前方法、构造方法或语句块中。局部变量必须在使用前声明..."},{"title":"5. Java基本数据类型","content":"Java的两大数据类型：内置数据类型引用数据类型内置数据类型Java提供了8种基本类型，6种数字类型（四个整型，两个浮点型），一种字符类型，一种布尔型。bytebyte数据类型是8位、有符号的，以二进制补码表示的整数；最小值是-128（-2^7）；最大值是127（2^7-1）；默认值是0；byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；例子：bytea=100，byteb=-50。shortshort数据类型是16位、有符号的以二进制补码表示的整数最小值是-32768（-2^15）；最大值是32767（2^15-1）；Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；默认值是0；例子：shorts=1000，shortr=-20000。intint数据类型是32位、有符号的以二进制补码表示的整数；最小值是-2,147,483,648（-2^31）；最大值是2,147,483,647（2^31-1）；一般地整型变量默认为int类型；默认值是0；例子：inta=100000,intb=-200000。longlong数据类型是64位、有符号的以二进制补码表示的整数；最小值是-9,223,372,036,854,775,808（-2^63）；最大值是9,223,372,036,854,775,807（2^63-1）；这种类型主要使用在需要比较大整数的系统上；默认值是0L；例子：longa=100000L，longb=-200000L。&quot;L&quot;理论上不分大小写，但是若写成&quot;l&quot;容易与数字&quot;1&quot;混淆，不容易分辩。所以最好大写。floatfloat数据类型是单精度、32位、符合IEEE754标准的浮点数；float在储存大型浮点数组的时候可节省内存空间；默认值是0.0f；浮点数不能用来表示精确的值，如货币；例子：floatf1=234.5f。doubledouble数据类型是双精度、64位、符合IEEE754标准的浮点数；浮点数的默认类型为double类型；double类型同样不能表示精确的值，如货币；默认值是0.0d；booleanboolean数据类型表示一位的信息；只有两个取值：true和false；这种类型只作为一种标志来记录true/false情况；默认值是false；例子：booleanone=true。charchar类型是一个单一的16位Unicode字符；最小值是\\u0000（十进制等效值为0）；最大值是\\uffff（即为65535）；char数据类型可以储存任何字符；例子：charletter='A';。数据类型大小默认值(数值单位忽略大小写)包装类byte80Byteshort160Shortint320Integerlong640LLongfloat320.0FFloatdouble640.0DDoubleboolean1falseBooleanchar8'u0000'Character引用类型在java种，引用类型类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如Employee、Puppy等。变量一旦声明后，类型就不能被改变了。对象、数组都是引用数据类型。所有引用类型的默认值都是null。一个引用变量可以用来引用任何与之兼容的类型。例子：Sitesite=newSite(&quot;Runoob&quot;)。Java常量常量在程序运行时是不能被修改的。在Java中使用final关键字来修饰常量，声明方式和变量类似：finaldoublePI=3.14;常量可以使用小写，但是为了便于识别，通常使用大写字母表示常量。字面量可以赋值给任何内置类型的变量：bytea=68;chara='A';byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。当使用字面量的时候，前缀0表示8进制，而前缀0x代表16进制,例如:intdecimal=100;intoctal=0144;inthexa=0x64;字符串常量和字符变量都可以包含任何Unicode字符。例如：chara='\\u0001';Stringa=&quot;\\u0001&quot;;java语言支持一些特殊的转义字符序列：符号字符含义\\n换行(0x0a)\\r回车(0x0d)\\f换页符(0x0c)\\b退格(0x08)\\0空字符(0x0)\\s空格(0x20)\\t制表符&quot;双引号'单引号\\反斜杠\\ddd八进制字符(ddd)\\uxxxx16进制Unicode字符(xxxx)自动类型转换（重点！）整型、实型（常量）、字符型数据可以混合运算，运算中，不同类型的数据先转换为同一类型，然后进行运算，转换从低级到高级。低------------------------------------&gt;高byte,short,char—&gt;int—&gt;long—&gt;float—&gt;double数据类型必须满足如下规则：不能对boolean进行类型转换不能把对象类型转换成不相关类的对象在把容量大的类型转换为容量小的类型时必须使用强制类型转换转换过程中可能会导致溢出或损失精度，例如：inti=128;byteb=(byte)i;因为byte类型是8位，最大值为127，所以当int强制转换为byte类型时，值128时候就会导致溢出。浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：(int)23.7==23;(int)-45.89f==-45必须满足转换前的数据类型的位数要低于转换后的数据类型，例如:short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。小容量转大容量，自动类型转换；大容量转小容量，强制类型转换。强制类型转换必须满足的条件：转换的数据类型必须是兼容的格式：(type)valuetype是要强制类型转换后的数据类型隐含强制类型转换：整数的默认类型是int小数默认类型是double，在定义float类时必须要在数字后面跟上F或f","link":"https://Vir-Limerence.github.io/post/5-java-ji-ben-shu-ju-lei-xing/","abstract":"Java的两大数据类型：内置数据类型引用数据类型内置数据类型Java提供了8种基本类型，6种数字类型（四个整型，两个浮点型），一种字符类型，一种布尔型。bytebyte数据类型是8位、有符号的，以二进制补码表示的整数；最小值是-128（-2^7）；最大值是127（2^7-1）；默认值是0；byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；例子：b..."},{"title":"4. Java对象和类","content":"Java对象和类java作为一种面向对象的语言，支持以下的基本概念：多态、继承、封装、抽象、类、对象、实例、方法、重载对象：对象是类的一个实例（对象不是找个女朋友）😏，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。类：类是一个模板，它描述一类对象的行为和状态。一个类可以包含以下类型的变量：局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。构造方法每个类都有构造方法，如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。publicclassPuppy{publicPuppy(){}publicPuppy(Stringname){//这个构造器仅有一个参数：name}}创建对象对象是根据类创建的，在java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：声明：声明一个对象，包括对象名称和对象类型。实例化：使用关键字new来创建一个对象。初始化：使用new创建对象时，会调用构造方法初始化对象。声明——&gt;实例化——&gt;初始化publicclassPuppy{publicPuppy(Stringname){//这个构造器仅有一个参数：nameSystem.out.println(&quot;小狗的名字是:&quot;+name);}publicstaticvoidmain(String[]args){//下面的语句将创建一个Puppy对象PuppymyPuppy=newPuppy(&quot;tommy&quot;);}}编译上述程序，得到的结果为：小狗的名字是:tommy访问实例变量和方法通过已创建的对象来访问成员变量和成员方法：/*实例化对象*/ObjectreferenceVariable=newConstructor();/*访问对象中的变量*/referenceVariable.variableName;/*访问对象中的方法*/referenceVariable.methodName();源文件的声明规则一个源文件只能有一个public类一个源文件可以有多个非public类源文件的名称应该和public类的类名保持一致如果一个类定义在某个包中，那么package语句应该在源文件的首行。如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，**不能给不同的类不同的包声明。**也就是说不允许出现两个package。类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。此外：java还有一些特别的类：如内部类、匿名类Java包包主要来对类和接口进行分类，开发java程序时，可能编写成百上千的类，因此有必要对类和接口进行分类。import语句在java中，如果给出一个完整的限定名，包括包名-类名，那么java编译器就可以很容易定位到源码或者类，import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。","link":"https://Vir-Limerence.github.io/post/4-java-dui-xiang-he-lei/","abstract":"Java对象和类java作为一种面向对象的语言，支持以下的基本概念：多态、继承、封装、抽象、类、对象、实例、方法、重载对象：对象是类的一个实例（对象不是找个女朋友）😏，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。类：类是一个模板，它描述一类对象的行为和状态。一个类可以包含以下类型的变量：局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变..."},{"title":"3. Java基础语法","content":"示例一个Java程序可以认为是一系列对象的集合，这些对象通过调用彼此的方法来协同工作，下面介绍下类、对象、方法和示例变量的概念。对象：对象是类的实例，有状态和行为。类：类是模板，描述与一类对象的行为和状态。方法：方法是行为，一个类可以有多个方法。实例变量：每个对象都有独特的实例变量，这些对象的状态由实例变量的值决定。publicclassHelloWorld{/*第一个Java程序*它将输出字符串HelloWorld*/publicstaticvoidmain(String[]args){System.out.println(&quot;HelloWorld&quot;);//输出HelloWorld}}对于上面这样一个简单的java程序，需要先通过javac编译，然后使用java执行编译后的程序，如果遇到编码问题，我们还可以使用-encoding选项指定编译：javac-encodingUTF-8HelloWorld.javajavaHelloWorld基本语法java是大小写敏感的对于java中的所有类来说，类名的首字母应该是大写的，如果类名由若干个单词组成，每个单词的首字母应该大写所有的方法都应该是以小写字母开头的，如果方法含有若干单词，后面的每个单词首字母大写源文件名和类名必须相同，保存文件时使用类名作为文件名保存，文件名的后缀为.java所有java程序由publicstaticvoidmain(String[]args)方法开始执行。Java标识符Java中所有的组成部分都需要名字。类名、变量名和方法名都被称之为标识符。注意：所有的标识符都应该以字母、美元符$、或者下划线_开始首字符之后可以是字母、数字、美元符和下划线的任意组合关键字不能用作标识符标识符是大小写敏感的Java修饰符java中可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：访问控制修饰符：default,public,protected,private非访问控制修饰符：final,abstract,static,synchronizedJava变量Java中主要有如下几种类型的变量：局部变量类变量（静态变量）成员变量（非静态变量）Java数组数组是存储在堆上的对象，可以保存多个同类型的变量。Java枚举Java5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。Java关键字类别关键字说明访问控制private私有的protected受保护的public公共的default默认类、方法和变量修饰符abstract声明抽象class类extends扩充,继承final最终值,不可改变的implements实现（接口）interface接口native本地，原生方法（非Java实现）new新,创建static静态strictfp严格,精准synchronized线程,同步transient短暂volatile易失程序控制语句break跳出循环case定义一个值以供switch选择continue继续do运行else否则for循环if如果instanceof实例return返回switch根据值选择执行while循环错误处理assert断言表达式是否为真catch捕捉异常finally有没有异常都执行throw抛出一个异常对象throws声明一个异常可能被抛出try捕获异常包相关import引入package包基本类型boolean布尔型byte字节型char字符型double双精度浮点float单精度浮点int整型long长整型short短整型变量引用super父类,超类this本类void无返回值保留关键字goto是关键字，但不能使用const是关键字，但不能使用**注意：**Java的null不是关键字，类似于true和false，它是一个字面常量，不允许作为标识符使用。Java注释类似于C/C++、Java也支持单行以及多行注释。注释中的字符将被Java编译器忽略。Java空行空白行或者有注释的行，Java编译器都会忽略掉。继承在Java中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（superclass），派生类称为子类（subclass）。接口在Java中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。Java中的接口是一种特殊的抽象类，它只包含抽象方法和常量字段的定义，没有实例变量和实现方法。接口可以被其他类实现(implement)或者继承(extend)，实现接口的类必须覆盖接口中所有的抽象方法，并且可以提供自己的实现逻辑。这允许类间的松耦合，提高代码的可维护性和扩展性。同时，接口也可以用于多重继承，即一个类可以实现多个接口。接口的定义格式如下：[public]interface接口名称[extends接口列表]{//常量字段声明//抽象方法定义}其中，public表示该接口对所有类可见，省略public则表示该接口仅对同包中的类可见；extends后面跟着接口列表，表示该接口继承自其他接口。Java源程序与编译型运行区别","link":"https://Vir-Limerence.github.io/post/3-java-ji-chu-yu-fa/","abstract":"示例一个Java程序可以认为是一系列对象的集合，这些对象通过调用彼此的方法来协同工作，下面介绍下类、对象、方法和示例变量的概念。对象：对象是类的实例，有状态和行为。类：类是模板，描述与一类对象的行为和状态。方法：方法是行为，一个类可以有多个方法。实例变量：每个对象都有独特的实例变量，这些对象的状态由实例变量的值决定。publicclassHelloWorld{/*第一个Java程序*它将输出字符串..."},{"title":"2. Java简介","content":"简介Java语言是Sun公司于1990年开发的；1994年，Gosling用Java语言开发了一个实用性较高、可靠、安全、有交互功能的新型Web浏览器，它不依赖与任何硬件平台和软件平台，该浏览器被命名为HotJava，并于1995年在业界发表，引起了巨大的轰动，Java语言的地位随之得到了肯定；1995年5月23日，JDK（JavaDevelopmenrKit）1.0a2版本正是对外发布；2009年4月20日，Sun公司被Oracle公司收购。2005年6月，JavaOne大会召开，SUN公司公开JavaSE6。此时，Java的各种版本已经更名，以取消其中的数字&quot;2&quot;：J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME。为了满足不同开发人员的需求，Java开发分成了以下3个方向：JavaSE：主要用于桌面程序的开发。它是学习JavaEE和JavaME的基础。JavaEE：主要用于网页程序的开发。随着互联网的发展，越来越多的企业使用Java语言来开发自己的官方网站，其中不乏一些世界500强。JavaME：主要用于嵌入式系统程序的开发。特性Java语言是简单的：Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动分配和回收内存空间，使得程序员不必为内存管理而担忧。Java语言是面向对象的：Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。Java语言是分布式的：Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（javanet），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。Java语言是健壮的：Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。Java语言是安全的：Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。Java语言是体系结构中立的：Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。Java语言是可移植的：这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSIC实现的。Java语言是解释型的：如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。Java是高性能的：与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。Java语言是多线程的：在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子类将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。Java语言是动态的：Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。发展历史1995年5月23日，Java语言诞生1996年1月，第一个JDK-JDK1.0诞生1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术1996年9月，约8.3万个网页应用了JAVA技术来制作1997年2月18日，JDK1.1发布1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录1997年9月，JavaDeveloperConnection社区成员超过十万1998年2月，JDK1.1被下载超过2,000,000次1998年12月8日，JAVA2企业平台J2EE发布1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）2000年5月8日，JDK1.3发布2000年5月29日，JDK1.4发布2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机2001年9月24日，J2EE1.3发布2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为JavaSE5.02005年6月，JavaOne大会召开，SUN公司公开JavaSE6。此时，Java的各种版本已经更名，以取消其中的数字&quot;2&quot;：J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME2006年12月，SUN公司发布JRE6.02009年04月20日，甲骨文74亿美元收购Sun，取得Java的版权。2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP。2011年7月28日，甲骨文发布Java7.0的正式版。2014年3月18日，Oracle公司发表JavaSE8。2017年9月21日，Oracle公司发表JavaSE92018年3月21日，Oracle公司发表JavaSE102018年9月25日，JavaSE11发布2019年3月20日，JavaSE12发布","link":"https://Vir-Limerence.github.io/post/2-java-jian-jie/","abstract":"简介Java语言是Sun公司于1990年开发的；1994年，Gosling用Java语言开发了一个实用性较高、可靠、安全、有交互功能的新型Web浏览器，它不依赖与任何硬件平台和软件平台，该浏览器被命名为HotJava，并于1995年在业界发表，引起了巨大的轰动，Java语言的地位随之得到了肯定；1995年5月23日，JDK（JavaDevelopmenrKit）1.0a2版本正是对外发布；2009..."},{"title":"1. Java开始","content":"运行java创建文件HelloWorld.java（文件名称与类名一致）publicclassHelloWorld{publicstaticvoidmain(String[]args){System.out.println(&quot;HelloWorld&quot;);}}注：Stringargs[]与String[]args都可以执行，但推荐使用String[]args，这样可以避免歧义和误读。执行命令可以使用javac和java：javac后面跟着的是java文件的文件名，如果成功编译没有错误的话，会出现后缀为class的文件java后面跟着的是java文件中的类名javacHelloWorld.javajavaHelloWorld注意：java命令后面不要加.class。","link":"https://Vir-Limerence.github.io/post/1java-kai-shi/","abstract":"运行java创建文件HelloWorld.java（文件名称与类名一致）publicclassHelloWorld{publicstaticvoidmain(String[]args){System.out.println(&quot;HelloWorld&quot;);}}注：Stringargs[]与String[]args都可以执行，但推荐使用String[]args，这样可以避免歧义和误读..."},{"title":"对python脚本进行性能分析","content":"python-mcProfile-oprofile.pstatsprofiler.py这是一个使用Python内置的cProfile模块对profiler.py脚本进行性能分析的命令。该命令会生成一个名为profile.pstats的性能分析文件，其中包含了profiler.py脚本的函数调用次数、运行时间等性能数据。可以使用pstats模块对该文件进行分析和可视化，以便更好地了解脚本的性能瓶颈和优化方向。具体操作如下：打开Python交互式环境或新建一个Python脚本，导入pstats模块：importpstats创建一个Stats对象，用于加载profile.pstats文件：stats=pstats.Stats('profile.pstats')调用Stats对象的方法来分析和可视化性能数据。例如，可以使用print_stats()方法打印出函数调用次数、运行时间等统计信息：stats.print_stats()可以通过help(pstats.Stats)命令来查看pstats模块的详细使用说明。","link":"https://Vir-Limerence.github.io/post/dui-python-jiao-ben-jin-xing-xing-neng-fen-xi/","abstract":"python-mcProfile-oprofile.pstatsprofiler.py这是一个使用Python内置的cProfile模块对profiler.py脚本进行性能分析的命令。该命令会生成一个名为profile.pstats的性能分析文件，其中包含了profiler.py脚本的函数调用次数、运行时间等性能数据。可以使用pstats模块对该文件进行分析和可视化，以便更好地了解脚本的性能瓶颈和..."},{"title":"图片接口整理","content":"声明：本文是二次整理，来源是庭户皓己盈樱花网址：https://www.dmoe.cc/API：https://www.dmoe.cc/random.php可选参数：type=jsonJSON调用格式：https://www.dmoe.cc/random.php?return=json返回类型：{&quot;code&quot;:&quot;200&quot;#图片状态码&quot;acgurl&quot;:&quot;https:\\/\\/ws1.sinaimg.cn\\/large\\/0072Vf1pgy1foxkfy08umj31kw0w0nng.jpg&quot;#图片地址&quot;width&quot;:&quot;2048&quot;#图片宽&quot;height&quot;:&quot;1152&quot;#图片高}博天网址：https://api.btstu.cn/doc/sjbz.phpAPI：https://api.btstu.cn/sjbz/api.php请求参数：{&quot;method&quot;:输出壁纸端[mobile|pc|zsy]默认为pc,&quot;lx&quot;:选择输出分类[meizi|dongman|fengjing|suiji]，为空随机输出,&quot;format&quot;:输出壁纸格式[json|images]默认为images}返回类型：{&quot;code&quot;:&quot;200&quot;,&quot;imgurl&quot;:&quot;https:\\/\\/tva4.sinaimg.cn\\/large\\/9bd9b167gy1g2qkr95hylj21hc0u01kx.jpg&quot;,&quot;width&quot;:&quot;1920&quot;,&quot;height&quot;:&quot;1080&quot;}樱道网址：https://img.r10086.com/API:https://api.r10086.com/樱道随机图片api接口.php?自适应图片系列=原神请求参数：参数=json可选返回类型：{&quot;error&quot;:0,&quot;result&quot;:200,&quot;img&quot;:&quot;\\/\\/api.r10086.com\\/..\\/图包webp\\/原神横屏系列1\\/wallhaven-1k2ldw.webp&quot;}保罗网址：https://api.paugram.com/help/wallpaperAPI：https://api.paugram.com/wallpaper/EEE.DOG网址：https://www.eee.dog/tech/rand-pic-api.htmlAPI:https://api.yimian.xyz/img岁月小筑网址：https://img.xjh.me/API：https://img.xjh.me/random_img.php?return=302直接返回图片请求参数：return=json","link":"https://Vir-Limerence.github.io/post/tu-pian-jie-kou-zheng-li/","abstract":"声明：本文是二次整理，来源是庭户皓己盈樱花网址：https://www.dmoe.cc/API：https://www.dmoe.cc/random.php可选参数：type=jsonJSON调用格式：https://www.dmoe.cc/random.php?return=json返回类型：{&quot;code&quot;:&quot;200&quot;#图片状态码&quot;acgurl&..."},{"title":" 为页面添加音乐组件","content":"😀音乐组件&lt;!--音乐，只在PC端宽度&gt;1000px时显示--&gt;&lt;linkrel=&quot;stylesheet&quot;href=&quot;https://blog-static.cnblogs.com/files/miluluyo/APlayer.min.css&quot;&gt;&lt;divid=&quot;player&quot;class=&quot;aplayeraplayer-withlistaplayer-fixed&quot;data-id=&quot;3116636104&quot;data-server=&quot;netease&quot;data-type=&quot;playlist&quot;data-order=&quot;random&quot;data-fixed=&quot;true&quot;data-listfolded=&quot;true&quot;data-theme=&quot;#2D8CF0&quot;&gt;&lt;/div&gt;&lt;scriptsrc=&quot;https://blog-static.cnblogs.com/files/miluluyo/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;scriptsrc=&quot;https://blog-static.cnblogs.com/files/miluluyo/Meting.min.js&quot;&gt;&lt;/script&gt;🤗创建目录由于资源访问受限，你需要将网页资源下载到本地，可以在assets/media目录下创建一个子目录music，下载相关的CSS文件和js文件，修改音乐组件如下&lt;linkrel=&quot;stylesheet&quot;href=&quot;/media/music/APlayer.min.css&quot;&gt;&lt;divid=&quot;player&quot;class=&quot;aplayeraplayer-withlistaplayer-fixed&quot;data-id=&quot;3116636104&quot;data-server=&quot;netease&quot;data-type=&quot;playlist&quot;data-order=&quot;random&quot;data-fixed=&quot;true&quot;data-listfolded=&quot;true&quot;data-theme=&quot;#2D8CF0&quot;&gt;&lt;/div&gt;&lt;scriptsrc=&quot;/media/music/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;scriptsrc=&quot;/media/music/Meting.min.js&quot;&gt;&lt;/script&gt;&lt;scriptsrc=&quot;/media/music/instantpage.min.js&quot;type=&quot;module&quot;defer&gt;&lt;/script&gt;😋添加组件将组件添加到footer.ejs的末尾，最终实现效果如下","link":"https://Vir-Limerence.github.io/post/shou-ye/","abstract":"😀音乐组件&lt;!--音乐，只在PC端宽度&gt;1000px时显示--&gt;&lt;linkrel=&quot;stylesheet&quot;href=&quot;https://blog-static.cnblogs.com/files/miluluyo/APlayer.min.css&quot;&gt;&lt;divid=&quot;player&quot;class=&quot;a..."}]}