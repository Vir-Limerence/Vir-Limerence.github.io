{"posts":[{"fileName":"springboot-de-qi-dong-yuan-li-liu-cheng-he-ji-zhi","abstract":"springboot 启动原理、启动过程、启动机制的介绍 1.启动原理 Spring Boot的一个核心特点是自动配置，它会自动配置Spring应用程序基于项目中添加的jar依赖。如果项目中包括 spring-boot-starter-web 依赖，Spring Boot将会配置应用程序使用Tomcat作为默认服务器，并且将基本的MVC支持加入容器中，这是通过 classpath 和已经定义的be...","description":"springboot 启动原理、启动过程、启动机制的介绍 1.启动原理 Spring Boot的一个核心特点是自动配置，它会自动配置Spring应用程序基于项目中添加的jar依赖。如果项目中包括 spring-boot-starter-we...","title":"SpringBoot的启动原理、流程和机制","tags":[{"index":-1,"name":"面试必备","slug":"huYvc0vQH","used":true,"link":"https://Vir-Limerence.github.io/tag/huYvc0vQH/"}],"feature":"https://img.xjh.me/img/63816958_p0_master1200.jpg","link":"https://Vir-Limerence.github.io/post/springboot-de-qi-dong-yuan-li-liu-cheng-he-ji-zhi/","stats":{"text":"7 min read","time":387000,"words":1791,"minutes":7},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#springboot-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BB%8B%E7%BB%8D\">springboot 启动原理、启动过程、启动机制的介绍</a></li>\n<li><a href=\"#1%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86\">1.启动原理</a>\n<ul>\n<li><a href=\"#11%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96starters\">1.1起步依赖(starters)</a></li>\n<li><a href=\"#12%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2\">1.2命令行界面</a></li>\n<li><a href=\"#13%E5%86%85%E5%B5%8C%E6%9C%8D%E5%8A%A1%E5%99%A8\">1.3内嵌服务器</a></li>\n<li><a href=\"#14%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE\">1.4外部化配置</a></li>\n<li><a href=\"#15%E7%9B%91%E6%8E%A7%E5%92%8C%E7%AE%A1%E7%90%86\">1.5监控和管理</a></li>\n<li><a href=\"#16%E6%97%A0%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%92%8Cxml%E9%85%8D%E7%BD%AE\">1.6无代码生成和XML配置</a></li>\n</ul>\n</li>\n<li><a href=\"#2%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B\">2.启动过程</a>\n<ul>\n<li><a href=\"#21%E5%90%AF%E5%8A%A8%E5%85%A5%E5%8F%A3\">2.1启动入口</a></li>\n<li><a href=\"#22%E5%88%9B%E5%BB%BAspringapplication-%E5%AF%B9%E8%B1%A1\">2.2创建<code>SpringApplication</code> 对象</a></li>\n<li><a href=\"#23%E8%BF%90%E8%A1%8Cspringapplication\">2.3运行<code>SpringApplication</code></a></li>\n<li><a href=\"#24%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%92%8Cbean%E7%9A%84%E5%88%9B%E5%BB%BA\">2.4自动配置和Bean的创建</a></li>\n<li><a href=\"#25%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87\">2.5运行应用上下文</a></li>\n<li><a href=\"#26%E5%BA%94%E7%94%A8%E5%B0%B1%E7%BB%AA\">2.6应用就绪</a></li>\n</ul>\n</li>\n<li><a href=\"#3%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3\">3.启动过程详解</a></li>\n</ul>\n","date":"2024-09-23 21:50:03","dateFormat":"2024-09-23"},{"fileName":"xian-duan-shu-he-shu-zhuang-shu-zu","abstract":"线段树和树状数组 1.线段树 线段树适用于区间操作较为复杂或者需要处理多个不同类型的区间操作的场景。具体如下： 区间求和、区间最值查询 区间更新 复杂的动态区间操作（区间最大公约数、最小公倍数） 支持懒标记的区间更新（更新无需遍历整个区间） 代码模板 class SegmentTree{ //存储线段树的数组 private int[] tree; //存储原始数据的数组 private int[...","description":"线段树和树状数组 1.线段树 线段树适用于区间操作较为复杂或者需要处理多个不同类型的区间操作的场景。具体如下： 区间求和、区间最值查询 区间更新 复杂的动态区间操作（区间最大公约数、最小公倍数） 支持懒标记的区间更新（更新无需遍历整个区...","title":"线段树和树状数组","tags":[{"index":-1,"name":"面试必备","slug":"huYvc0vQH","used":true,"link":"https://Vir-Limerence.github.io/tag/huYvc0vQH/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxkjgev08j31hc0u0qgl.jpg","link":"https://Vir-Limerence.github.io/post/xian-duan-shu-he-shu-zhuang-shu-zu/","stats":{"text":"3 min read","time":173000,"words":587,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84\">线段树和树状数组</a>\n<ul>\n<li><a href=\"#1%E7%BA%BF%E6%AE%B5%E6%A0%91\">1.线段树</a>\n<ul>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF\">代码模板</a></li>\n</ul>\n</li>\n<li><a href=\"#2%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84\">2.树状数组</a></li>\n</ul>\n</li>\n</ul>\n","date":"2024-09-08 17:13:43","dateFormat":"2024-09-08"},{"fileName":"shou-xie-hashmap","abstract":"手写HashMap 1.定义HashMap的存储单元Node class Node&lt;K,V&gt;{ final K key; V value; Node&lt;K, V&gt; next; Node(K key, V value){ this.key = key; this.value = value; } } 2.构造器初始化和默认参数 //定义一个默认的初始容量 private sta...","description":"手写HashMap 1.定义HashMap的存储单元Node class Node&lt;K,V&gt;{ final K key; V value; Node&lt;K, V&gt; next; Node(...","title":"手写HashMap","tags":[{"index":-1,"name":"面试必备","slug":"huYvc0vQH","used":true,"link":"https://Vir-Limerence.github.io/tag/huYvc0vQH/"}],"feature":"https://img.btstu.cn/api/images/59f2f39839d72.jpg","link":"https://Vir-Limerence.github.io/post/shou-xie-hashmap/","stats":{"text":"6 min read","time":343000,"words":1098,"minutes":6},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%89%8B%E5%86%99hashmap\">手写HashMap</a>\n<ul>\n<li><a href=\"#1%E5%AE%9A%E4%B9%89hashmap%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83node\">1.定义HashMap的存储单元Node</a></li>\n<li><a href=\"#2%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0\">2.构造器初始化和默认参数</a></li>\n<li><a href=\"#3%E8%AE%A1%E7%AE%97%E7%B4%A2%E5%BC%95\">3.计算索引</a></li>\n<li><a href=\"#4%E6%8F%92%E5%85%A5%E6%9B%B4%E6%96%B0put\">4.插入/更新put</a></li>\n<li><a href=\"#5%E8%8E%B7%E5%8F%96get\">5.获取get</a></li>\n<li><a href=\"#6%E5%88%A0%E9%99%A4remove\">6.删除remove</a></li>\n<li><a href=\"#7%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%B9%E9%87%8Fresize\">7.扩展哈希表的容量resize</a></li>\n<li><a href=\"#8%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">8.完整代码</a></li>\n</ul>\n</li>\n</ul>\n","date":"2024-09-08 16:34:23","dateFormat":"2024-09-08"},{"fileName":"xian-cheng-chi-xiang-guan","abstract":"交替打印数字 利用volatile同步 public class VolatilePrint { // 全局变量i，用于计数 private static int i = 1; // 是否是奇数的标志，用volatile保证可见性 private static volatile boolean isOdd = true; public static void main(String[] args)...","description":"交替打印数字 利用volatile同步 public class VolatilePrint { // 全局变量i，用于计数 private static int i = 1; // 是否是奇数的标志，用volati...","title":"线程池相关","tags":[{"index":-1,"name":"面试必备","slug":"huYvc0vQH","used":true,"link":"https://Vir-Limerence.github.io/tag/huYvc0vQH/"}],"feature":"https://img.btstu.cn/api/images/5a2b8df955f4e.jpg","link":"https://Vir-Limerence.github.io/post/xian-cheng-chi-xiang-guan/","stats":{"text":"7 min read","time":373000,"words":1293,"minutes":7},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E6%95%B0%E5%AD%97\">交替打印数字</a>\n<ul>\n<li><a href=\"#%E5%88%A9%E7%94%A8volatile%E5%90%8C%E6%AD%A5\">利用volatile同步</a></li>\n<li><a href=\"#%E5%88%A9%E7%94%A8waitnotify%E5%90%8C%E6%AD%A5\">利用wait()/notify()同步</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8semaphore%E4%BF%A1%E5%8F%B7%E9%87%8F\">使用Semaphore信号量</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8condition%E5%92%8Clock\">使用Condition和Lock</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8aqs\">使用AQS</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8locksupport\">使用LockSupport</a></li>\n</ul>\n</li>\n</ul>\n","date":"2024-08-23 11:16:59","dateFormat":"2024-08-23"},{"fileName":"ba-da-pai-xu-suan-fa","abstract":"插入排序 直接插入排序 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。 时间复杂度：O(N^2) 空间复杂度：O(1) 稳定 public static void insertionSort(int[] arr) { int n = arr.length; for (int i = 1; i &lt; n; ++i) { in...","description":"插入排序 直接插入排序 把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。 时间复杂度：O(N^2) 空间复杂度：O(1) 稳定 public static void in...","title":"八大排序算法","tags":[{"index":-1,"name":"面试必备","slug":"huYvc0vQH","used":true,"link":"https://Vir-Limerence.github.io/tag/huYvc0vQH/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxkfhjrg5j31hc0u0nfw.jpg","link":"https://Vir-Limerence.github.io/post/ba-da-pai-xu-suan-fa/","stats":{"text":"12 min read","time":681000,"words":2596,"minutes":12},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">插入排序</a>\n<ul>\n<li><a href=\"#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">直接插入排序</a></li>\n<li><a href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\">希尔排序</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">选择排序</a>\n<ul>\n<li><a href=\"#%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">直接选择排序</a></li>\n<li><a href=\"#%E5%A0%86%E6%8E%92%E5%BA%8F\">堆排序</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F\">交换排序</a>\n<ul>\n<li><a href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">冒泡排序</a></li>\n<li><a href=\"#%E5%BF%AB%E6%8E%92\">快排</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">归并排序</a>\n<ul>\n<li><a href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-2\">归并排序</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F\">计数排序</a></li>\n<li><a href=\"#%E6%A1%B6%E6%8E%92%E5%BA%8F\">桶排序</a></li>\n<li><a href=\"#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83\">性能比较</a></li>\n</ul>\n","date":"2024-08-22 19:57:39","dateFormat":"2024-08-22"},{"fileName":"dan-li-mo-shi","abstract":"饿汉式单例 饿汉式单例在类加载时就创建实例，因此是线程安全的。 public class EagerSingleton{ private static final EagerSingleton INSTANCE = new EagerSingleton(); private EagerSingleton(){ //私有构造器 } public static EagerSingleton getIn...","description":"饿汉式单例 饿汉式单例在类加载时就创建实例，因此是线程安全的。 public class EagerSingleton{ private static final EagerSingleton INSTANCE = new Eage...","title":"单例模式","tags":[{"index":-1,"name":"面试必备","slug":"huYvc0vQH","used":true,"link":"https://Vir-Limerence.github.io/tag/huYvc0vQH/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxk6nwijlj31kw0w0ttc.jpg","link":"https://Vir-Limerence.github.io/post/dan-li-mo-shi/","stats":{"text":"2 min read","time":115000,"words":467,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B\">饿汉式单例</a></li>\n<li><a href=\"#%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B\">懒汉式单例</a></li>\n<li><a href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B\">线程安全的懒汉式单例</a></li>\n<li><a href=\"#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81\">双重检查锁</a></li>\n<li><a href=\"#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB\">静态内部类</a></li>\n</ul>\n","date":"2024-08-22 19:28:18","dateFormat":"2024-08-22"},{"fileName":"37-java-xu-lie-hua","abstract":"Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。 将序列化对象写入文件之后，可以从文件中读取出来，并且对他进行反序列化，也就是说，对象的类型信息，对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是java虚拟机（JVM)独立的，也就是说在一个平台上序列化的对象可以在另一...","description":"Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。 将序列化对象写入文件之后，可以从文件中读取出来，并且对他进行反序列化，也就是说，对...","title":"37. Java序列化","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/5a7947fe09c30.jpg","link":"https://Vir-Limerence.github.io/post/37-java-xu-lie-hua/","stats":{"text":"2 min read","time":73000,"words":347,"minutes":2},"isTop":false,"toc":"","date":"2023-06-19 22:36:51","dateFormat":"2023-06-19"},{"fileName":"36-java-fan-xing","abstract":"Java泛型是jdk5引入的一个新特性，泛型提供了编译时类型安全检测机制，允许程序员在编译时检测到非法的类型，泛型的本质是参数化类型，也就是说操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？ 答案是可以使用 Java 泛型。 使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，...","description":"Java泛型是jdk5引入的一个新特性，泛型提供了编译时类型安全检测机制，允许程序员在编译时检测到非法的类型，泛型的本质是参数化类型，也就是说操作的数据类型被指定为一个参数。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数...","title":"36. Java泛型","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/62837820_p0.jpg","link":"https://Vir-Limerence.github.io/post/36-java-fan-xing/","stats":{"text":"6 min read","time":322000,"words":1293,"minutes":6},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95\">泛型方法</a></li>\n<li><a href=\"#%E6%B3%9B%E5%9E%8B%E7%B1%BB\">泛型类</a></li>\n<li><a href=\"#%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6\">类型通配符</a></li>\n</ul>\n","date":"2023-06-19 22:18:36","dateFormat":"2023-06-19"},{"fileName":"35-java-object-lei","abstract":"java的Obejct类是所有类的父类，也就是说java的所有类都继承了Object类，子类可以使用Object的方法。 Object位于java.lang包中，编译时会自动导入，创建一个类，如果没有明确继承一个父类，那么它会自动继承Object类，成为Object的子类. Object类可以显式继承，也可以隐式继承 //显式继承 public class Runoob extends Objec...","description":"java的Obejct类是所有类的父类，也就是说java的所有类都继承了Object类，子类可以使用Object的方法。 Object位于java.lang包中，编译时会自动导入，创建一个类，如果没有明确继承一个父类，那么它会自动继承Ob...","title":"35. Java Object类","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/55015303_p0.jpg","link":"https://Vir-Limerence.github.io/post/35-java-object-lei/","stats":{"text":"2 min read","time":100000,"words":435,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\">类的构造函数</a></li>\n<li><a href=\"#%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95\">类的方法</a></li>\n</ul>\n","date":"2023-06-19 22:13:59","dateFormat":"2023-06-19"},{"fileName":"34-java-iteratordie-dai-qi","abstract":"Java迭代器是java集合框架中的一种机制，提供了一种在不暴露集合内部实现的情况下遍历集合元素的方法. Java迭代器不是一个集合，是用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。 Iterator是java迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。 迭代器 it 的三个基本操作...","description":"Java迭代器是java集合框架中的一种机制，提供了一种在不暴露集合内部实现的情况下遍历集合元素的方法. Java迭代器不是一个集合，是用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。 Iterator是ja...","title":"34. Java Iterator(迭代器)","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/59185850_p0.jpg","link":"https://Vir-Limerence.github.io/post/34-java-iteratordie-dai-qi/","stats":{"text":"2 min read","time":105000,"words":441,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E8%8E%B7%E5%8F%96%E8%BF%AD%E4%BB%A3%E5%99%A8\">获取迭代器</a></li>\n<li><a href=\"#%E5%BE%AA%E7%8E%AF%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0\">循环集合元素</a></li>\n<li><a href=\"#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0\">删除元素</a></li>\n</ul>\n","date":"2023-06-19 22:04:48","dateFormat":"2023-06-19"},{"fileName":"33-java-hashmap","abstract":"HashMap是一个散列表，它存储的内容是键值对的映射。 HashMap实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。 HashMap是无序的，即不会记录插入的顺序，HashMap继承于AbstractMap，实现了Map、Cloneable、Java.io.Serializable接口. HashMap的key与valu...","description":"HashMap是一个散列表，它存储的内容是键值对的映射。 HashMap实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。 HashMap是无序的，即不会记录插入的顺序...","title":"33. Java HashMap","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxkizc9w8j31kw0w0e45.jpg","link":"https://Vir-Limerence.github.io/post/33-java-hashmap/","stats":{"text":"3 min read","time":178000,"words":736,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0\">添加元素</a></li>\n<li><a href=\"#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0\">访问元素</a></li>\n<li><a href=\"#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0\">删除元素</a></li>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E5%A4%A7%E5%B0%8F\">计算大小</a></li>\n<li><a href=\"#%E8%BF%AD%E4%BB%A3hashmap\">迭代HashMap</a></li>\n<li><a href=\"#%E6%96%B9%E6%B3%95\">方法</a></li>\n</ul>\n","date":"2023-06-19 21:42:22","dateFormat":"2023-06-19"},{"fileName":"32-java-hashset","abstract":"HashSet是基于HashMap来实现的，是一个不允许有重复元素的集合. HashSet允许有null值，HashSet是无序的，不会记录插入的顺序. HashSet不是线程安全的, 如果多个线程尝试同时修改HashSet, 则最终结果是不确定的, 必须在多线程访问时，显式同步对HashSet的并发访问. HashSet实现了Set接口. HashSet的元素实际上是对象，一些常见的基本类型可以...","description":"HashSet是基于HashMap来实现的，是一个不允许有重复元素的集合. HashSet允许有null值，HashSet是无序的，不会记录插入的顺序. HashSet不是线程安全的, 如果多个线程尝试同时修改HashSet, 则最终结果是...","title":"32. Java HashSet","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/5a153a2bf3b4c.jpg","link":"https://Vir-Limerence.github.io/post/32-java-hashset/","stats":{"text":"2 min read","time":108000,"words":425,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0\">添加元素</a></li>\n<li><a href=\"#%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8\">判断元素是否存在</a></li>\n<li><a href=\"#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0\">删除元素</a></li>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E5%A4%A7%E5%B0%8F\">计算大小</a></li>\n<li><a href=\"#%E8%BF%AD%E4%BB%A3hashset\">迭代HashSet</a></li>\n</ul>\n","date":"2023-06-19 21:28:48","dateFormat":"2023-06-19"},{"fileName":"31-java-linkedlist","abstract":"链表是常见的数据结构，是一种线性表，但是并不会按照线性的顺序存储数据，而是在每个节点中存储到下一个节点的地址。链表可以分为单向链表和双向链表。 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。 一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。 Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。 与 ArrayList 相比...","description":"链表是常见的数据结构，是一种线性表，但是并不会按照线性的顺序存储数据，而是在每个节点中存储到下一个节点的地址。链表可以分为单向链表和双向链表。 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。 一个双向链表有三个整数值:...","title":"31. Java LinkedList","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/5a0939b48a1d5.jpg","link":"https://Vir-Limerence.github.io/post/31-java-linkedlist/","stats":{"text":"4 min read","time":237000,"words":1010,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#linkedlist%E7%9A%84%E5%BC%80%E5%A4%B4%E5%92%8C%E7%BB%93%E5%B0%BE%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0\">LinkedList的开头和结尾添加元素</a></li>\n<li><a href=\"#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\">常用方法</a></li>\n</ul>\n","date":"2023-06-09 22:16:47","dateFormat":"2023-06-09"},{"fileName":"30-java-arraylist","abstract":"ArrayList类是一个可以动态修改的数组，与普通数组的区别就是它时没有固定大小的限制，我们可以添加或者删除元素。ArrayList继承了AbstractList， 并且实现了List接口。 ArrayList类位于java.util包中，使用前需要引入： import java.util.ArrayList; ArrayList&lt;E&gt; objectName = new ArrayL...","description":"ArrayList类是一个可以动态修改的数组，与普通数组的区别就是它时没有固定大小的限制，我们可以添加或者删除元素。ArrayList继承了AbstractList， 并且实现了List接口。 ArrayList类位于java.util包...","title":"30. Java ArrayList","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/a15b4afely1fnt9oyi2n9j21hc0u04jc.jpg","link":"https://Vir-Limerence.github.io/post/30-java-arraylist/","stats":{"text":"6 min read","time":327000,"words":1211,"minutes":6},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0\">添加元素</a></li>\n<li><a href=\"#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0\">访问元素</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0\">修改元素</a></li>\n<li><a href=\"#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0\">删除元素</a></li>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E5%A4%A7%E5%B0%8F\">计算大小</a></li>\n<li><a href=\"#%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8\">迭代数组列表</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\">其它的引用类型</a></li>\n<li><a href=\"#arraylist%E6%8E%92%E5%BA%8F\">ArrayList排序</a></li>\n<li><a href=\"#java-arraylist%E6%96%B9%E6%B3%95\">Java ArrayList方法</a></li>\n</ul>\n","date":"2023-06-09 21:58:50","dateFormat":"2023-06-09"},{"fileName":"29-java-ji-he-kuang-jia","abstract":"早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。 虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。 集合框架被设计用于满足以下几个目标： 框架必须是高性能的，基本集合（动态数组...","description":"早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。 虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因...","title":"29. Java集合框架","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/005FzdTdgy1geet8ebq4jj31hc0u0tve.jpg","link":"https://Vir-Limerence.github.io/post/29-java-ji-he-kuang-jia/","stats":{"text":"11 min read","time":637000,"words":2766,"minutes":11},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3\">集合接口</a>\n<ul>\n<li><a href=\"#set%E5%92%8Clist%E7%9A%84%E5%8C%BA%E5%88%AB\">Set和List的区别</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB%E9%9B%86%E5%90%88%E7%B1%BB\">集合实现类（集合类）</a></li>\n<li><a href=\"#%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95\">集合算法</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8\">使用迭代器</a>\n<ul>\n<li><a href=\"#%E9%81%8D%E5%8E%86arraylist\">遍历ArrayList</a></li>\n<li><a href=\"#%E9%81%8D%E5%8E%86map\">遍历Map</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E5%99%A8\">使用比较器</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n","date":"2023-06-09 21:27:11","dateFormat":"2023-06-09"},{"fileName":"28-java-zhong-de-shu-ju-jie-gou","abstract":"在java中的数据结构主要包括以下几种接口和类： 枚举 位集合 向量 栈 字典 哈希表 属性 枚举（Enmueration) 枚举接口本身不属于数据结构，但是在其它数据结构的范畴中应用很广泛. 枚举接口定义了一种从数据结构中取回连续元素的方式. 例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。 位集合（BitSet） 位集合类实现了一组可以...","description":"在java中的数据结构主要包括以下几种接口和类： 枚举 位集合 向量 栈 字典 哈希表 属性 枚举（Enmueration) 枚举接口本身不属于数据结构，但是在其它数据结构的范畴中应用很广泛. 枚举接口定义了一种从数据结构中取回连续元素...","title":"28. Java中的数据结构","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/64311913_p0.jpg","link":"https://Vir-Limerence.github.io/post/28-java-zhong-de-shu-ju-jie-gou/","stats":{"text":"2 min read","time":112000,"words":546,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%9E%9A%E4%B8%BEenmueration\">枚举（Enmueration)</a></li>\n<li><a href=\"#%E4%BD%8D%E9%9B%86%E5%90%88bitset\">位集合（BitSet）</a></li>\n<li><a href=\"#%E5%90%91%E9%87%8Fvector\">向量（Vector)</a></li>\n<li><a href=\"#%E6%A0%88stack\">栈（Stack）</a></li>\n<li><a href=\"#%E5%AD%97%E5%85%B8dictionary\">字典（Dictionary)</a></li>\n<li><a href=\"#%E5%93%88%E5%B8%8C%E8%A1%A8hashtable\">哈希表（Hashtable）</a></li>\n<li><a href=\"#%E5%B1%9E%E6%80%A7properties\">属性（Properties)</a></li>\n</ul>\n","date":"2023-06-09 21:13:02","dateFormat":"2023-06-09"},{"fileName":"27-java-mei-ju-enum","abstract":"Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一年的 12 个月份，一个星期的 7 天，方向有东南西北等。 Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。 enum Color { RED, GREEN, BLUE; } 以上枚举类 Color 颜色常量有 RED, GREEN, BLUE，分别表示红色，绿色，蓝色。 内部类中使用枚举 pub...","description":"Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一年的 12 个月份，一个星期的 7 天，方向有东南西北等。 Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。 enum Color { ...","title":"27. Java枚举（enum）","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/5a33869b44968.jpg","link":"https://Vir-Limerence.github.io/post/27-java-mei-ju-enum/","stats":{"text":"2 min read","time":119000,"words":475,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE\">内部类中使用枚举</a></li>\n<li><a href=\"#%E8%BF%AD%E4%BB%A3%E6%9E%9A%E4%B8%BE%E5%85%83%E7%B4%A0\">迭代枚举元素</a></li>\n<li><a href=\"#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95\">枚举类的方法</a></li>\n<li><a href=\"#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%88%90%E5%91%98\">枚举类成员</a></li>\n</ul>\n","date":"2023-06-04 21:43:07","dateFormat":"2023-06-04"},{"fileName":"26-java-jie-kou","abstract":"接口的特点 接口通常以interface来声明，一个类通过继承接口的方式来继承接口的抽象方法 接口不是类，包含类要实现的方法 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法 接口无法被实例化，但可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。 接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 接口与类的区别 接...","description":"接口的特点 接口通常以interface来声明，一个类通过继承接口的方式来继承接口的抽象方法 接口不是类，包含类要实现的方法 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法 接口无法被实例化，但可以被实现。一个实现接口的类，必须...","title":"26. Java接口","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/a15b4afely1fnt9dbypplj21hc0u07wk.jpg","link":"https://Vir-Limerence.github.io/post/26-java-jie-kou/","stats":{"text":"5 min read","time":274000,"words":1327,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9\">接口的特点</a></li>\n<li><a href=\"#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB\">接口与类的区别</a></li>\n<li><a href=\"#%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7\">接口特性</a></li>\n<li><a href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB\">抽象类和接口的区别</a></li>\n<li><a href=\"#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A3%B0%E6%98%8E\">接口的声明</a></li>\n<li><a href=\"#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0\">接口的实现</a></li>\n<li><a href=\"#%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3\">标记接口</a></li>\n</ul>\n","date":"2023-06-04 20:45:12","dateFormat":"2023-06-04"},{"fileName":"25-java-feng-zhuang","abstract":"封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 实现封装的步骤 修改属性的可见性来限制对属性的访问（一般为private） public class Person { private String name; private int age; } 对每个值提供对外的公共访问方法，也就是创建一对赋取值方法，用于对私有属性的访问...","description":"封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 实现封装的步骤 修改属性的可见性来限制对属性的访问（一般为private） public cl...","title":"25. Java封装","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/63453484_p0.jpg","link":"https://Vir-Limerence.github.io/post/25-java-feng-zhuang/","stats":{"text":"1 min read","time":48000,"words":203,"minutes":1},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E7%82%B9\">封装的优点</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85%E7%9A%84%E6%AD%A5%E9%AA%A4\">实现封装的步骤</a></li>\n</ul>\n","date":"2023-06-04 20:42:28","dateFormat":"2023-06-04"},{"fileName":"24-java-chou-xiang-lei","abstract":"如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。 在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 抽象方法 如果你想设计这样一个类，该类包含一个特别的成员方法，...","description":"如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。 在...","title":"24. Java抽象类","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxk7j6oxuj31hc0u0k6u.jpg","link":"https://Vir-Limerence.github.io/post/24-java-chou-xiang-lei/","stats":{"text":"2 min read","time":109000,"words":532,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95\">抽象方法</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n","date":"2023-06-04 20:33:48","dateFormat":"2023-06-04"},{"fileName":"23-java-duo-tai","abstract":"多态是同一行为具有不同表现形式或形态的能力，多态就是同一个接口，使用不同的实例而执行不同操作。 多态的优点 消除类型之间耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的条件 继承 重写 父类的引用指向子类：Parent p = new Child(); 在使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有则编译错误，如果有，再去调用子类的同名方法。多态的好处：使得程序有良...","description":"多态是同一行为具有不同表现形式或形态的能力，多态就是同一个接口，使用不同的实例而执行不同操作。 多态的优点 消除类型之间耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的条件 继承 重写 父类的引用指向子类：Paren...","title":"23. Java多态","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/63176739_p0.jpg","link":"https://Vir-Limerence.github.io/post/23-java-duo-tai/","stats":{"text":"2 min read","time":116000,"words":476,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%82%B9\">多态的优点</a></li>\n<li><a href=\"#%E5%A4%9A%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E6%9D%A1%E4%BB%B6\">多态存在的条件</a></li>\n<li><a href=\"#%E8%99%9A%E5%87%BD%E6%95%B0\">虚函数</a></li>\n<li><a href=\"#%E9%87%8D%E5%86%99\">重写</a></li>\n</ul>\n","date":"2023-06-04 20:21:25","dateFormat":"2023-06-04"},{"fileName":"22-java-chong-xie-overrridehe-chong-zai-overload","abstract":"重写（Override） 重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即外壳不变，核心重写。 重写的好处在于子类可以根据需要，定义特定于自己的行为，也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。 在面向对象的原则里，重写意味着可以重写任何现有的方法。 class Animal{ public void ...","description":"重写（Override） 重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即外壳不变，核心重写。 重写的好处在于子类可以根据需要，定义特定于自己的行为，也就是说子类能够根据需要实现父类的方法。 重写方法不能抛...","title":"22. Java重写（Overrride）和重载（Overload）","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/a15b4afegy1fmvjmodj8sj21hc0u0qcy.jpg","link":"https://Vir-Limerence.github.io/post/22-java-chong-xie-overrridehe-chong-zai-overload/","stats":{"text":"4 min read","time":206000,"words":982,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E9%87%8D%E5%86%99override\">重写（Override）</a></li>\n<li><a href=\"#%E9%87%8D%E5%86%99%E7%9A%84%E8%A7%84%E5%88%99\">重写的规则</a></li>\n<li><a href=\"#%E9%87%8D%E8%BD%BDoverload\">重载（Overload）</a></li>\n<li><a href=\"#%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99\">重载规则</a></li>\n<li><a href=\"#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A7%84%E5%88%99\">重写与重载的规则</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>\n","date":"2023-06-04 20:00:08","dateFormat":"2023-06-04"},{"fileName":"21-java-ji-cheng","abstract":"概念 继承是java面向对象编程的基础，因为它允许创建分层次等级的类。 继承就是子类继承父类的特征和行为，使得子类对象具有父类的实例域和方法。或者子类从父类继承方法，使得子类具有父类相同的行为。 继承需要符合的关系是： is-a ,父类更通用，子类更具体 格式 在java中通过extends关键字可以申明一个类是从另外一个类继承得到的： class 父类{ } class 子类 extends 父...","description":"概念 继承是java面向对象编程的基础，因为它允许创建分层次等级的类。 继承就是子类继承父类的特征和行为，使得子类对象具有父类的实例域和方法。或者子类从父类继承方法，使得子类具有父类相同的行为。 继承需要符合的关系是： is-a ,父类更通...","title":"21. Java继承","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/5ae02b7e4711c.jpg","link":"https://Vir-Limerence.github.io/post/21-java-ji-cheng/","stats":{"text":"3 min read","time":150000,"words":721,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></li>\n<li><a href=\"#%E6%A0%BC%E5%BC%8F\">格式</a></li>\n<li><a href=\"#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB%E5%9E%8B\">继承的类型</a></li>\n<li><a href=\"#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E6%80%A7\">继承的特性</a></li>\n<li><a href=\"#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97\">继承的关键字</a>\n<ul>\n<li><a href=\"#extends%E5%85%B3%E9%94%AE%E5%AD%97\">extends关键字</a></li>\n<li><a href=\"#implements%E5%85%B3%E9%94%AE%E5%AD%97\">implements关键字</a></li>\n<li><a href=\"#super%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97\">super和this关键字</a></li>\n<li><a href=\"#final%E5%85%B3%E9%94%AE%E5%AD%97\">final关键字</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%99%A8\">构造器</a></li>\n</ul>\n","date":"2023-06-04 19:40:14","dateFormat":"2023-06-04"},{"fileName":"20-java-yi-chang-chu-li","abstract":"😍 异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。 异常发生的原因有很多，通常包含以下几大类： 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出。 要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常： **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件...","description":"😍 异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。 异常发生的原因有很多，通常包含以下几大类： 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出。 要理解Java异常...","title":"20. Java异常处理","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxkcukvztj31hc0u0ars.jpg","link":"https://Vir-Limerence.github.io/post/20-java-yi-chang-chu-li/","stats":{"text":"10 min read","time":590000,"words":2628,"minutes":10},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#exception%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1\">Exception类的层次</a></li>\n<li><a href=\"#java%E5%86%85%E7%BD%AE%E5%BC%82%E5%B8%B8%E7%B1%BB\">java内置异常类</a></li>\n<li><a href=\"#%E5%BC%82%E5%B8%B8%E6%96%B9%E6%B3%95\">异常方法</a></li>\n<li><a href=\"#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8\">捕获异常</a></li>\n<li><a href=\"#%E5%A4%9A%E9%87%8D%E6%8D%95%E8%8E%B7%E5%9D%97\">多重捕获块</a></li>\n<li><a href=\"#throwthrows%E5%85%B3%E9%94%AE%E5%AD%97\">throw/throws关键字</a>\n<ul>\n<li><a href=\"#throw%E5%85%B3%E9%94%AE%E5%AD%97\">throw关键字</a></li>\n<li><a href=\"#throws%E5%85%B3%E9%94%AE%E5%AD%97\">throws关键字</a></li>\n</ul>\n</li>\n<li><a href=\"#finally%E5%85%B3%E9%94%AE%E5%AD%97\">finally关键字</a></li>\n<li><a href=\"#try-with-resources\">try-with-resources</a></li>\n<li><a href=\"#%E5%A3%B0%E6%98%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%82%E5%B8%B8\">声明自定义的异常</a></li>\n<li><a href=\"#%E9%80%9A%E7%94%A8%E5%BC%82%E5%B8%B8\">通用异常</a></li>\n</ul>\n","date":"2023-06-03 20:58:38","dateFormat":"2023-06-03"},{"fileName":"19-java-scanner-lei","abstract":"java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 创建Sanner对象： Scanner s = new Scanner(System.in); 通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据： i...","description":"java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 创建Sanner对象： Scanner s = new Scanner(System.in); 通过 Scanner 类的 ...","title":"19. Java Scanner类","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/5a0279d063381.jpg","link":"https://Vir-Limerence.github.io/post/19-java-scanner-lei/","stats":{"text":"3 min read","time":122000,"words":483,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#next-%E4%B8%8E-nextline-%E5%8C%BA%E5%88%AB\">next() 与 nextLine() 区别</a></li>\n</ul>\n","date":"2023-06-03 20:53:19","dateFormat":"2023-06-03"},{"fileName":"18-java-liu-wen-jian-he-io","abstract":"Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。 Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。 一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。 读取控制台输入 Java 的控制台输入由 System.in 完成。为了获得一个绑定到控制台的字符流，你可以把 System.in 包...","description":"Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。 Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。 一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出...","title":"18. Java流、文件和IO","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/63603275_p0.jpg","link":"https://Vir-Limerence.github.io/post/18-java-liu-wen-jian-he-io/","stats":{"text":"9 min read","time":501000,"words":2014,"minutes":9},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E8%AF%BB%E5%8F%96%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5\">读取控制台输入</a></li>\n<li><a href=\"#%E4%BB%8E%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AF%BB%E5%8F%96%E5%A4%9A%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5\">从控制台读取多字符输入</a></li>\n<li><a href=\"#%E4%BB%8E%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2\">从控制台读取字符串</a></li>\n<li><a href=\"#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA\">控制台输出</a></li>\n<li><a href=\"#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6\">读写文件</a></li>\n<li><a href=\"#fileinputstream\">FileInputStream</a></li>\n<li><a href=\"#fileoutputstream\">FileOutputStream</a></li>\n<li><a href=\"#java%E4%B8%AD%E7%9A%84%E7%9B%AE%E5%BD%95\">java中的目录</a>\n<ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95\">创建目录</a></li>\n<li><a href=\"#%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95\">读取目录</a></li>\n<li><a href=\"#%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6\">删除目录或文件</a></li>\n</ul>\n</li>\n</ul>\n","date":"2023-06-03 20:35:15","dateFormat":"2023-06-03"},{"fileName":"17-java-fang-fa","abstract":"😋 在前面几个章节中我们经常使用到 System.out.println()，那么它是什么呢？ println() 是一个方法。 System 是系统类。 out 是标准输出对象。 这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。 什么是方法 Java方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象...","description":"😋 在前面几个章节中我们经常使用到 System.out.println()，那么它是什么呢？ println() 是一个方法。 System 是系统类。 out 是标准输出对象。 这句话的用法是调用系统类 System 中的标准输出...","title":"17. Java方法","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/5a3386b6bfcd2.jpg","link":"https://Vir-Limerence.github.io/post/17-java-fang-fa/","stats":{"text":"7 min read","time":368000,"words":1647,"minutes":7},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95\">什么是方法</a></li>\n<li><a href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9\">方法的优点</a></li>\n<li><a href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99\">方法的命名规则</a></li>\n<li><a href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89\">方法的定义</a></li>\n<li><a href=\"#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8\">方法调用</a></li>\n<li><a href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD\">方法的重载</a></li>\n<li><a href=\"#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\">变量的作用域</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\">使用命令行参数</a></li>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E5%AF%B9%E8%B1%A1\">构造对象</a></li>\n<li><a href=\"#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\">可变参数</a></li>\n<li><a href=\"#finalize%E6%96%B9%E6%B3%95\">finalize方法</a></li>\n</ul>\n","date":"2023-06-03 20:17:01","dateFormat":"2023-06-03"},{"fileName":"16-java-zheng-ze-biao-da-shi","abstract":"java.util.regex包主要包括以下三类： Pattern类： pattern对象是一个正则表达式的编译表示，Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数 Matcher类： Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一...","description":"java.util.regex包主要包括以下三类： Pattern类： pattern对象是一个正则表达式的编译表示，Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 P...","title":"16. Java正则表达式","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxk7b1md7j31hc0u0qlb.jpg","link":"https://Vir-Limerence.github.io/post/16-java-zheng-ze-biao-da-shi/","stats":{"text":"13 min read","time":771000,"words":3207,"minutes":13},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%8D%95%E8%8E%B7%E7%BB%84\">捕获组</a></li>\n<li><a href=\"#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95\">正则表达式语法</a></li>\n<li><a href=\"#matcher%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95\">Matcher类的方法</a>\n<ul>\n<li><a href=\"#%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95\">索引方法</a></li>\n<li><a href=\"#%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95\">查找方法</a></li>\n<li><a href=\"#%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%B3%95\">替换方法</a></li>\n</ul>\n</li>\n<li><a href=\"#patternsyntaxexception-%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95\">PatternSyntaxException 类的方法</a></li>\n</ul>\n","date":"2023-06-02 21:14:52","dateFormat":"2023-06-02"},{"fileName":"15-java-ri-qi-shi-jian","abstract":"java.util包提供了Date类来封装当前的日期和时间。Date类提供两个构造函数来实例化Date对象： //使用当前日期和时间来初始化对象 Date( ) //接收参数，参数是从 1970 年 1 月 1 日起的毫秒数 Date(long millisec) Date对象的方法有： 序号 方法和描述 1 boolean after(Date date) 若当调用此方法的Date对象在指定日期...","description":"java.util包提供了Date类来封装当前的日期和时间。Date类提供两个构造函数来实例化Date对象： //使用当前日期和时间来初始化对象 Date( ) //接收参数，参数是从 1970 年 1 月 1 日起的毫秒数 Date(lo...","title":"15. Java日期时间","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxlhe0a6tj31hc0u0qhh.jpg","link":"https://Vir-Limerence.github.io/post/15-java-ri-qi-shi-jian/","stats":{"text":"8 min read","time":468000,"words":1831,"minutes":8},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4\">获取当前日期时间</a></li>\n<li><a href=\"#%E6%97%A5%E6%9C%9F%E6%AF%94%E8%BE%83\">日期比较</a>\n<ul>\n<li><a href=\"#simpledateformat-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F\">SimpleDateFormat 格式化日期</a></li>\n</ul>\n</li>\n<li><a href=\"#printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F\">printf格式化日期</a></li>\n<li><a href=\"#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E4%B8%BA%E6%97%B6%E9%97%B4\">将字符串解析为时间</a></li>\n<li><a href=\"#java%E4%B8%AD%E7%9A%84%E4%BC%91%E7%9C%A0\">Java中的休眠</a></li>\n<li><a href=\"#%E6%93%8D%E4%BD%9C%E6%97%A5%E6%9C%9Fcalendar%E7%B1%BB\">操作日期Calendar类</a>\n<ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%A3%E8%A1%A8%E7%B3%BB%E7%BB%9F%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E7%9A%84calendar%E5%AF%B9%E8%B1%A1\">创建一个代表系统当前日期的Calendar对象</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%87%E5%AE%9A%E6%97%A5%E6%9C%9F%E7%9A%84calendar%E5%AF%B9%E8%B1%A1\">创建一个指定日期的Calendar对象</a></li>\n<li><a href=\"#calendar%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B\">Calendar类对象字段类型</a></li>\n<li><a href=\"#set%E8%AE%BE%E7%BD%AE-add%E8%AE%BE%E7%BD%AE%E5%92%8Cget%E8%AE%BE%E7%BD%AE\">Set设置、Add设置和Get设置</a></li>\n</ul>\n</li>\n<li><a href=\"#gregoriancalendar%E7%B1%BB\">GregorianCalendar类</a></li>\n</ul>\n","date":"2023-06-02 20:50:19","dateFormat":"2023-06-02"},{"fileName":"14-java-shu-zu","abstract":"Java语言中数组是用来存储固定大小的同类型元素。 声明数组 数组变量必须先声明，才能在程序中使用，一般有以下两种方式： dataType[] arrayRefVar; // 首选的方法 或 dataType arrayRefVar[]; // 效果相同，但不是首选方法 创建数组 Java语言使用new操作符来创建数组 arrayRefVar = new dataType[arraySize]; ...","description":"Java语言中数组是用来存储固定大小的同类型元素。 声明数组 数组变量必须先声明，才能在程序中使用，一般有以下两种方式： dataType[] arrayRefVar; // 首选的方法 或 dataType arrayRefV...","title":"14. Java数组","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/5ba1bc5606968.jpg","link":"https://Vir-Limerence.github.io/post/14-java-shu-zu/","stats":{"text":"4 min read","time":180000,"words":785,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84\">声明数组</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84\">创建数组</a></li>\n<li><a href=\"#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84\">处理数组</a></li>\n<li><a href=\"#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC\">数组作为参数和返回值</a></li>\n<li><a href=\"#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84\">多维数组</a>\n<ul>\n<li><a href=\"#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96\">多维数组的动态初始化</a></li>\n<li><a href=\"#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8\">多维数组的引用</a></li>\n</ul>\n</li>\n<li><a href=\"#arrays%E7%B1%BB\">Arrays类</a></li>\n</ul>\n","date":"2023-06-02 20:36:13","dateFormat":"2023-06-02"},{"fileName":"13-java-stringbuffer","abstract":"对字符串进行修改的时候，需要使用StringBuffer和StringBuilder类，和String对象不同的是，StringBuffer和StringBuilder类的对象可以被多次修改，并且不产生新的未使用对象. 使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改时推荐使用StringBuffer. Stri...","description":"对字符串进行修改的时候，需要使用StringBuffer和StringBuilder类，和String对象不同的是，StringBuffer和StringBuilder类的对象可以被多次修改，并且不产生新的未使用对象. 使用StringB...","title":"13. Java StringBuffer","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/5b57f2f78c206.jpg","link":"https://Vir-Limerence.github.io/post/13-java-stringbuffer/","stats":{"text":"3 min read","time":172000,"words":714,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#stringbuffer%E6%96%B9%E6%B3%95\">StringBuffer方法</a></li>\n</ul>\n","date":"2023-06-02 20:26:06","dateFormat":"2023-06-02"},{"fileName":"wei-wang-zhan-wen-dang-zi-ding-yi-liao-tian-ji-qi-ren","abstract":"网址：https://knowbo.ai/ 功能介绍： 使用机器人： ","description":"网址：https://knowbo.ai/ 功能介绍： 使用机器人： ...","title":"为网站（文档）自定义聊天机器人","tags":[{"name":"小技巧","slug":"duV9sb83D","used":true,"link":"https://Vir-Limerence.github.io/tag/duV9sb83D/"}],"feature":"https://img.btstu.cn/api/images/5a0a5273419a4.jpg","link":"https://Vir-Limerence.github.io/post/wei-wang-zhan-wen-dang-zi-ding-yi-liao-tian-ji-qi-ren/","stats":{"text":"1 min read","time":3000,"words":14,"minutes":1},"isTop":false,"toc":"","date":"2023-06-02 20:19:12","dateFormat":"2023-06-02"},{"fileName":"xie-wan-yi-pian-bo-ke-gridea-tu-ran-da-bu-kai-liao","abstract":"什么原因 根据我的观察，如果你是因为写完一篇博客Gridea打不开了，很有可能是最新写的这篇文章有什么问题 举例 我在使用gridea写博客的时候，是直接在posts文件夹使用Typora进行编辑的，这就导致我不小心把图片放到了posts文件夹，这里建议可以使用Typora的图床功能 解决办法 删除posts中的图片就好了 建议 如果是最后一篇博客出问题了，建议先删除相关博客的内容，应该就能恢复正...","description":"什么原因 根据我的观察，如果你是因为写完一篇博客Gridea打不开了，很有可能是最新写的这篇文章有什么问题 举例 我在使用gridea写博客的时候，是直接在posts文件夹使用Typora进行编辑的，这就导致我不小心把图片放到了posts文...","title":"写完一篇博客，Gridea数据被清空了","tags":[{"name":"小技巧","slug":"duV9sb83D","used":true,"link":"https://Vir-Limerence.github.io/tag/duV9sb83D/"}],"feature":"https://img.xjh.me/img/61896646_p0.jpg","link":"https://Vir-Limerence.github.io/post/xie-wan-yi-pian-bo-ke-gridea-tu-ran-da-bu-kai-liao/","stats":{"text":"1 min read","time":36000,"words":178,"minutes":1},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0\">什么原因</a></li>\n<li><a href=\"#%E4%B8%BE%E4%BE%8B\">举例</a></li>\n<li><a href=\"#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\">解决办法</a></li>\n<li><a href=\"#%E5%BB%BA%E8%AE%AE\">建议</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2\">参考博客</a></li>\n</ul>\n</li>\n</ul>\n","date":"2023-06-01 22:22:41","dateFormat":"2023-06-01"},{"fileName":"yi-tu-nao-tu-dao-chu","abstract":"思路——&gt;先导出文本（免费的，文本可能出现排版错误，需要微调）——&gt; python处理文本，转换为md格式——&gt;使用markmap ——&gt;可导出为svg或者html格式 样例网站 https://mm.edrawsoft.cn/template/156937 超巨大的思维导图 处理脚本 with open('xx.txt', 'r', encoding='utf-8') a...","description":"思路——&gt;先导出文本（免费的，文本可能出现排版错误，需要微调）——&gt; python处理文本，转换为md格式——&gt;使用markmap ——&gt;可导出为svg或者html格式 样例网站 https://mm.edrawso...","title":"亿图脑图导出","tags":[{"name":"小技巧","slug":"duV9sb83D","used":true,"link":"https://Vir-Limerence.github.io/tag/duV9sb83D/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1fodqmy1m4nj31kw0uzhdx.jpg","link":"https://Vir-Limerence.github.io/post/yi-tu-nao-tu-dao-chu/","stats":{"text":"1 min read","time":58000,"words":197,"minutes":1},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E6%A0%B7%E4%BE%8B%E7%BD%91%E7%AB%99\">样例网站</a></li>\n<li><a href=\"#%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC\">处理脚本</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8markmap\">使用markmap</a></li>\n</ul>\n","date":"2023-06-01 18:52:38","dateFormat":"2023-06-01"},{"fileName":"10-java-number-he-math-lei","abstract":"需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等，Java 语言为每一个内置数据类型提供了对应的包装类。所有的包装类Integer、Long、Byte、Double、Float、Short都是抽象类 Number 的子类。 包装类 基本数据类型 Boolean boolean Byte byte Short short Integer int Long...","description":"需要使用数字的时候，我们通常使用内置数据类型，如：byte、int、long、double 等，Java 语言为每一个内置数据类型提供了对应的包装类。所有的包装类Integer、Long、Byte、Double、Float、Short都是抽...","title":"10. Java Number和Math类","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/59f420b75b645.jpg","link":"https://Vir-Limerence.github.io/post/10-java-number-he-math-lei/","stats":{"text":"3 min read","time":178000,"words":746,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#java-math%E7%B1%BB\">Java Math类</a>\n<ul>\n<li><a href=\"#number-math-%E7%B1%BB%E6%96%B9%E6%B3%95\">Number &amp; Math 类方法</a></li>\n<li><a href=\"#math-%E7%9A%84-floorround-%E5%92%8C-ceil-%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E6%AF%94%E8%BE%83\">Math 的 floor,round 和 ceil 方法实例比较</a></li>\n</ul>\n</li>\n</ul>\n","date":"2023-05-31 23:03:12","dateFormat":"2023-05-31"},{"fileName":"9-java-xun-huan-jie-gou","abstract":"主要有三种循环结构： while 循环 do…while 循环 for 循环 while循环 while( 布尔表达式 ) { //循环内容 } //只要布尔表达式为 true，循环就会一直执行下去。 do while循环 do { //代码语句 }while(布尔表达式); //至少会执行一次 for循环 for(初始化; 布尔表达式; 更新) { //代码语句 } Java5 引入了一种主要用...","description":"主要有三种循环结构： while 循环 do…while 循环 for 循环 while循环 while( 布尔表达式 ) { //循环内容 } //只要布尔表达式为 true，循环就会一直执行下去。 do while循环 do ...","title":"9. Java循环结构","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/46116783_p0.jpg","link":"https://Vir-Limerence.github.io/post/9-java-xun-huan-jie-gou/","stats":{"text":"2 min read","time":71000,"words":336,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#while%E5%BE%AA%E7%8E%AF\">while循环</a></li>\n<li><a href=\"#do-while%E5%BE%AA%E7%8E%AF\">do while循环</a></li>\n<li><a href=\"#for%E5%BE%AA%E7%8E%AF\">for循环</a>\n<ul>\n<li><a href=\"#break%E5%85%B3%E9%94%AE%E5%AD%97\">break关键字</a></li>\n<li><a href=\"#continue-%E5%85%B3%E9%94%AE%E5%AD%97\">continue 关键字</a></li>\n</ul>\n</li>\n</ul>\n","date":"2023-05-31 22:59:13","dateFormat":"2023-05-31"},{"fileName":"8-java-yun-suan-fu","abstract":"运算符类型：算数运算符、关系运算符、位运算符、逻辑运算符、赋值运算符、其他运算符 算数运算符 操作符 描述 例子 + 加法 - 相加运算符两侧的值 A + B 等于 30 - 减法 - 左操作数减去右操作数 A – B 等于 -10 * 乘法 - 相乘操作符两侧的值 A * B等于200 / 除法 - 左操作数除以右操作数 B / A等于2 ％ 取余 - 左操作数除以右操作数的余数 B%A等于0 ...","description":"运算符类型：算数运算符、关系运算符、位运算符、逻辑运算符、赋值运算符、其他运算符 算数运算符 操作符 描述 例子 + 加法 - 相加运算符两侧的值 A + B 等于 30 - 减法 - 左操作数减去右操作数 A – B 等...","title":"8. Java运算符","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.btstu.cn/api/images/5a0e4a33edd7b.jpg","link":"https://Vir-Limerence.github.io/post/8-java-yun-suan-fu/","stats":{"text":"6 min read","time":352000,"words":1568,"minutes":6},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6\">算数运算符</a>\n<ul>\n<li><a href=\"#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6\">自增自减运算符</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6\">关系运算符</a></li>\n<li><a href=\"#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\">位运算符</a></li>\n<li><a href=\"#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6\">逻辑运算符</a>\n<ul>\n<li><a href=\"#%E7%9F%AD%E8%B7%AF%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6\">短路逻辑运算符</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6\">赋值运算符</a>\n<ul>\n<li><a href=\"#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6\">条件运算符（?:）</a></li>\n<li><a href=\"#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6\">instanceof 运算符</a></li>\n<li><a href=\"#java%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7\">java运算符优先级</a></li>\n</ul>\n</li>\n</ul>\n","date":"2023-05-31 22:44:40","dateFormat":"2023-05-31"},{"fileName":"7-java-xiu-shi-fu","abstract":"Java语言提供了很多修饰符，主要分为两类： 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。例如public、protected、private等。 访问控制修饰符 java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、...","description":"Java语言提供了很多修饰符，主要分为两类： 访问修饰符 非访问修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。例如public、protected、private等。 访问控制修饰符 java中，可以使用访问控制符来保护...","title":"7. Java修饰符","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/63740101_p0.jpg","link":"https://Vir-Limerence.github.io/post/7-java-xiu-shi-fu/","stats":{"text":"8 min read","time":422000,"words":1939,"minutes":8},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6\">访问控制修饰符</a>\n<ul>\n<li><a href=\"#%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E5%85%B3%E9%94%AE%E5%AD%97\">默认访问修饰符-不使用任何关键字</a></li>\n<li><a href=\"#%E7%A7%81%E6%9C%89%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-private\">私有访问修饰符-private</a></li>\n<li><a href=\"#%E5%85%AC%E6%9C%89%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-public\">公有访问修饰符-public</a></li>\n<li><a href=\"#%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-protected\">受保护的访问修饰符-protected</a></li>\n<li><a href=\"#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E7%BB%A7%E6%89%BF\">访问控制和继承</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%9D%9E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\">非访问修饰符</a>\n<ul>\n<li><a href=\"#static%E4%BF%AE%E9%A5%B0%E7%AC%A6\">static修饰符</a></li>\n<li><a href=\"#final%E4%BF%AE%E9%A5%B0%E7%AC%A6\">final修饰符</a></li>\n<li><a href=\"#abstract-%E4%BF%AE%E9%A5%B0%E7%AC%A6\">abstract 修饰符</a></li>\n<li><a href=\"#synchronized-%E4%BF%AE%E9%A5%B0%E7%AC%A6\">synchronized 修饰符</a></li>\n<li><a href=\"#transient-%E4%BF%AE%E9%A5%B0%E7%AC%A6\">transient 修饰符</a></li>\n<li><a href=\"#volatile-%E4%BF%AE%E9%A5%B0%E7%AC%A6\">volatile 修饰符</a></li>\n</ul>\n</li>\n</ul>\n","date":"2023-05-31 22:17:09","dateFormat":"2023-05-31"},{"fileName":"6-java-bian-liang-lei-xing","abstract":"在java语言中，所有的变量在使用前必须声明，声明变量的基本格式如下： type identifier [ = value][, identifier [= value] ...] ; 格式说明： type：数据类型 identifier：变量名，可以使用逗号 , 隔开来声明多个同类型变量 java支持的变量类型有： 局部变量：定义在方法、构造方法或语句块中的变量，作用域只限于当前方法、构造方法或...","description":"在java语言中，所有的变量在使用前必须声明，声明变量的基本格式如下： type identifier [ = value][, identifier [= value] ...] ; 格式说明： type：数据类型 identifie...","title":"6. Java变量类型","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/62828877_p0.jpg","link":"https://Vir-Limerence.github.io/post/6-java-bian-liang-lei-xing/","stats":{"text":"10 min read","time":542000,"words":2517,"minutes":10},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#java%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F\">Java参数变量</a></li>\n<li><a href=\"#java%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F\">Java局部变量</a></li>\n<li><a href=\"#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F\">成员变量（实例变量）</a></li>\n<li><a href=\"#%E7%B1%BB%E5%8F%98%E9%87%8F%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F\">类变量（静态变量）</a>\n<ul>\n<li><a href=\"#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F\">定义方式</a></li>\n<li><a href=\"#%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F\">访问方式</a></li>\n<li><a href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">生命周期</a></li>\n<li><a href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA\">初始化时机</a></li>\n<li><a href=\"#%E5%B8%B8%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB\">常量与静态变量的区别</a></li>\n<li><a href=\"#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6\">静态变量的访问修饰符</a></li>\n<li><a href=\"#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7\">静态变量的线程安全性</a></li>\n<li><a href=\"#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99\">命名规则</a></li>\n<li><a href=\"#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">静态变量的使用场景</a></li>\n</ul>\n</li>\n</ul>\n","date":"2023-05-29 22:14:40","dateFormat":"2023-05-29"},{"fileName":"5-java-ji-ben-shu-ju-lei-xing","abstract":"Java的两大数据类型： 内置数据类型 引用数据类型 内置数据类型 Java提供了8种基本类型，6种数字类型（四个整型，两个浮点型），一种字符类型，一种布尔型。 byte byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间...","description":"Java的两大数据类型： 内置数据类型 引用数据类型 内置数据类型 Java提供了8种基本类型，6种数字类型（四个整型，两个浮点型），一种字符类型，一种布尔型。 byte byte 数据类型是8位、有符号的，以二进制补码表示的整数； ...","title":"5. Java基本数据类型","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/a15b4afely1fnt99tpvpwj21hc0u0e84.jpg","link":"https://Vir-Limerence.github.io/post/5-java-ji-ben-shu-ju-lei-xing/","stats":{"text":"7 min read","time":360000,"words":1542,"minutes":7},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\">内置数据类型</a>\n<ul>\n<li><a href=\"#byte\">byte</a></li>\n<li><a href=\"#short\">short</a></li>\n<li><a href=\"#int\">int</a></li>\n<li><a href=\"#long\">long</a></li>\n<li><a href=\"#float\">float</a></li>\n<li><a href=\"#double\">double</a></li>\n<li><a href=\"#boolean\">boolean</a></li>\n<li><a href=\"#char\">char</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\">引用类型</a></li>\n<li><a href=\"#java%E5%B8%B8%E9%87%8F\">Java常量</a></li>\n<li><a href=\"#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%87%8D%E7%82%B9\">自动类型转换（重点！）</a></li>\n</ul>\n","date":"2023-05-29 20:52:21","dateFormat":"2023-05-29"},{"fileName":"4-java-dui-xiang-he-lei","abstract":"Java对象和类 java作为一种面向对象的语言，支持以下的基本概念： 多态、继承、封装、抽象、类、对象、实例、方法、重载 对象：对象是类的一个实例（对象不是找个女朋友）😏，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 一个类可以包含以下类型的变量： 局部变量：在方法、构造方法或者语句块中定义的变量...","description":"Java对象和类 java作为一种面向对象的语言，支持以下的基本概念： 多态、继承、封装、抽象、类、对象、实例、方法、重载 对象：对象是类的一个实例（对象不是找个女朋友）😏，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、...","title":"4. Java对象和类","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/005FzdTdgy1geeswu9rjaj31hc0u0e0w.jpg","link":"https://Vir-Limerence.github.io/post/4-java-dui-xiang-he-lei/","stats":{"text":"4 min read","time":207000,"words":971,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#java%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB\">Java对象和类</a></li>\n<li><a href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\">构造方法</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\">创建对象</a></li>\n<li><a href=\"#%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95\">访问实例变量和方法</a></li>\n<li><a href=\"#%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%A3%B0%E6%98%8E%E8%A7%84%E5%88%99\">源文件的声明规则</a></li>\n<li><a href=\"#java%E5%8C%85\">Java包</a></li>\n<li><a href=\"#import%E8%AF%AD%E5%8F%A5\">import语句</a></li>\n</ul>\n","date":"2023-05-28 16:53:02","dateFormat":"2023-05-28"},{"fileName":"3-java-ji-chu-yu-fa","abstract":"示例 一个Java程序可以认为是一系列对象的集合，这些对象通过调用彼此的方法来协同工作，下面介绍下类、对象、方法和示例变量的概念。 对象：对象是类的实例，有状态和行为。 类：类是模板，描述与一类对象的行为和状态。 方法：方法是行为，一个类可以有多个方法。 实例变量：每个对象都有独特的实例变量，这些对象的状态由实例变量的值决定。 public class HelloWorld { /* 第一个Jav...","description":"示例 一个Java程序可以认为是一系列对象的集合，这些对象通过调用彼此的方法来协同工作，下面介绍下类、对象、方法和示例变量的概念。 对象：对象是类的实例，有状态和行为。 类：类是模板，描述与一类对象的行为和状态。 方法：方法是行为，一个类...","title":"3. Java基础语法","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://img.xjh.me/img/57888840_p0.jpg","link":"https://Vir-Limerence.github.io/post/3-java-ji-chu-yu-fa/","stats":{"text":"6 min read","time":315000,"words":1450,"minutes":6},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E7%A4%BA%E4%BE%8B\">示例</a></li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\">基本语法</a></li>\n<li><a href=\"#java%E6%A0%87%E8%AF%86%E7%AC%A6\">Java标识符</a></li>\n<li><a href=\"#java%E4%BF%AE%E9%A5%B0%E7%AC%A6\">Java修饰符</a></li>\n<li><a href=\"#java%E5%8F%98%E9%87%8F\">Java变量</a></li>\n<li><a href=\"#java%E6%95%B0%E7%BB%84\">Java数组</a></li>\n<li><a href=\"#java%E6%9E%9A%E4%B8%BE\">Java枚举</a></li>\n<li><a href=\"#java%E5%85%B3%E9%94%AE%E5%AD%97\">Java关键字</a></li>\n<li><a href=\"#java%E6%B3%A8%E9%87%8A\">Java注释</a>\n<ul>\n<li><a href=\"#java-%E7%A9%BA%E8%A1%8C\">Java 空行</a></li>\n<li><a href=\"#%E7%BB%A7%E6%89%BF\">继承</a></li>\n<li><a href=\"#%E6%8E%A5%E5%8F%A3\">接口</a></li>\n</ul>\n</li>\n<li><a href=\"#java-%E6%BA%90%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%BC%96%E8%AF%91%E5%9E%8B%E8%BF%90%E8%A1%8C%E5%8C%BA%E5%88%AB\">Java 源程序与编译型运行区别</a></li>\n</ul>\n","date":"2023-05-28 16:23:38","dateFormat":"2023-05-28"},{"fileName":"2-java-jian-jie","abstract":"简介 Java语言是Sun公司于1990年开发的；1994年，Gosling用Java语言开发了一个实用性较高、可靠、安全、有交互功能的新型Web浏览器，它不依赖与任何硬件平台和软件平台，该浏览器被命名为HotJava，并于1995年在业界发表，引起了巨大的轰动，Java语言的地位随之得到了肯定；1995年5月23日，JDK（Java Developmenr Kit）1.0a2版本正是对外发布；2...","description":"简介 Java语言是Sun公司于1990年开发的；1994年，Gosling用Java语言开发了一个实用性较高、可靠、安全、有交互功能的新型Web浏览器，它不依赖与任何硬件平台和软件平台，该浏览器被命名为HotJava，并于1995年在业界...","title":"2. Java简介","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxlohgkwfj31hc0u0k69.jpg","link":"https://Vir-Limerence.github.io/post/2-java-jian-jie/","stats":{"text":"8 min read","time":452000,"words":1999,"minutes":8},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E7%AE%80%E4%BB%8B\">简介</a></li>\n<li><a href=\"#%E7%89%B9%E6%80%A7\">特性</a></li>\n<li><a href=\"#%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2\">发展历史</a></li>\n</ul>\n","date":"2023-05-28 16:03:33","dateFormat":"2023-05-28"},{"fileName":"1java-kai-shi","abstract":"运行java 创建文件HelloWorld.java（文件名称与类名一致） public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello World&quot;); } } 注：String args[] 与 String[] args 都可以执行，但推荐使用 St...","description":"运行java 创建文件HelloWorld.java（文件名称与类名一致） public class HelloWorld { public static void main(String[] args) { Sys...","title":"1. Java开始","tags":[{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/"}],"feature":"https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/a15b4afegy1fmvj8iph19j21hc0u0k60.jpg","link":"https://Vir-Limerence.github.io/post/1java-kai-shi/","stats":{"text":"1 min read","time":34000,"words":139,"minutes":1},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E8%BF%90%E8%A1%8Cjava\">运行java</a></li>\n</ul>\n","date":"2023-05-28 15:43:12","dateFormat":"2023-05-28"},{"fileName":"dui-python-jiao-ben-jin-xing-xing-neng-fen-xi","abstract":"python -m cProfile -o profile.pstats profiler.py 这是一个使用Python内置的cProfile模块对profiler.py脚本进行性能分析的命令。该命令会生成一个名为profile.pstats的性能分析文件，其中包含了profiler.py脚本的函数调用次数、运行时间等性能数据。可以使用pstats模块对该文件进行分析和可视化，以便更好地了解脚本...","description":"python -m cProfile -o profile.pstats profiler.py 这是一个使用Python内置的cProfile模块对profiler.py脚本进行性能分析的命令。该命令会生成一个名为profile.pst...","title":"对python脚本进行性能分析","tags":[{"name":"Python","slug":"j-L5ccFDG","used":true,"link":"https://Vir-Limerence.github.io/tag/j-L5ccFDG/"}],"feature":"https://img.xjh.me/img/60317330_p0.jpg","link":"https://Vir-Limerence.github.io/post/dui-python-jiao-ben-jin-xing-xing-neng-fen-xi/","stats":{"text":"1 min read","time":52000,"words":233,"minutes":1},"isTop":false,"toc":"","date":"2023-05-27 09:48:17","dateFormat":"2023-05-27"},{"fileName":"tu-pian-jie-kou-zheng-li","abstract":"声明：本文是二次整理，来源是庭户皓己盈 樱花 网址：https://www.dmoe.cc/ API：https://www.dmoe.cc/random.php 可选参数：type=json JSON调用格式：https://www.dmoe.cc/random.php?return=json 返回类型： { &quot;code&quot;:&quot;200&quot; #图片状态码 &qu...","description":"声明：本文是二次整理，来源是庭户皓己盈 樱花 网址：https://www.dmoe.cc/ API：https://www.dmoe.cc/random.php 可选参数：type=json JSON调用格式：https://www.dm...","title":"图片接口整理","tags":[{"index":-1,"name":"页面美化","slug":"i6SyYe6cd","used":true,"link":"https://Vir-Limerence.github.io/tag/i6SyYe6cd/"}],"feature":"https://img.xjh.me/img/23665621_p0_master1200.jpg","link":"https://Vir-Limerence.github.io/post/tu-pian-jie-kou-zheng-li/","stats":{"text":"2 min read","time":103000,"words":346,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%A8%B1%E8%8A%B1\">樱花</a></li>\n<li><a href=\"#%E5%8D%9A%E5%A4%A9\">博天</a></li>\n<li><a href=\"#%E6%A8%B1%E9%81%93\">樱道</a></li>\n<li><a href=\"#%E4%BF%9D%E7%BD%97\">保罗</a></li>\n<li><a href=\"#eeedog\">EEE.DOG</a></li>\n<li><a href=\"#%E5%B2%81%E6%9C%88%E5%B0%8F%E7%AD%91\">岁月小筑</a></li>\n</ul>\n","date":"2023-05-23 17:34:20","dateFormat":"2023-05-23"},{"fileName":"shou-ye","abstract":"😀音乐组件 &lt;!--音乐，只在PC端宽度&gt;1000px时显示--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://blog-static.cnblogs.com/files/miluluyo/APlayer.min.css&quot;&gt; &lt;div id=&quot;player&quot; class=...","description":"😀音乐组件 &lt;!--音乐，只在PC端宽度&gt;1000px时显示--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://blog-static.cnblogs.c...","title":" 为页面添加音乐组件","tags":[{"index":-1,"name":"页面美化","slug":"i6SyYe6cd","used":true,"link":"https://Vir-Limerence.github.io/tag/i6SyYe6cd/"}],"feature":"https://img.btstu.cn/api/images/5a0a500eeb71e.jpg","link":"https://Vir-Limerence.github.io/post/shou-ye/","stats":{"text":"2 min read","time":106000,"words":327,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E9%9F%B3%E4%B9%90%E7%BB%84%E4%BB%B6\">😀音乐组件</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95\">🤗创建目录</a></li>\n<li><a href=\"#%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6\">😋添加组件</a></li>\n</ul>\n","date":"2023-05-22 22:48:02","dateFormat":"2023-05-22"}],"tags":[{"index":-1,"name":"面试必备","slug":"huYvc0vQH","used":true,"link":"https://Vir-Limerence.github.io/tag/huYvc0vQH/","count":6},{"index":-1,"name":"JAVA速记","slug":"zBJtyRrqa","used":true,"link":"https://Vir-Limerence.github.io/tag/zBJtyRrqa/","count":35},{"name":"小技巧","slug":"duV9sb83D","used":true,"link":"https://Vir-Limerence.github.io/tag/duV9sb83D/","count":3},{"name":"Python","slug":"j-L5ccFDG","used":true,"link":"https://Vir-Limerence.github.io/tag/j-L5ccFDG/","count":1},{"index":-1,"name":"页面美化","slug":"i6SyYe6cd","used":true,"link":"https://Vir-Limerence.github.io/tag/i6SyYe6cd/","count":2}],"menus":[{"link":"/","name":"首页","openType":"Internal"},{"link":"/archives","name":"归档","openType":"Internal"},{"link":"/columns","name":"专栏","openType":"Internal"},{"link":"/tags","name":"标签","openType":"Internal"},{"link":"/post/about","name":"关于","openType":"Internal"}],"themeConfig":{"themeName":"bitcron-pro","postPageSize":10,"archivesPageSize":20,"siteName":"MAQI' blog","siteDescription":"HIT2022级网络安全研究生，在这里我将会记录一些日常学习研究","footerInfo":"","showFeatureImage":true,"domain":"https://Vir-Limerence.github.io","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"customConfig":{"customCss":"","facebook":"","ga":"","github":"https://github.com/Vir-Limerence","twitter":"","weibo":"","zhihu":""},"utils":{"now":1729129799025}}
