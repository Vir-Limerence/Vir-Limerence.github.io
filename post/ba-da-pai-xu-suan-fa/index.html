<!DOCTYPE html>
<html>

<head>
	<link rel="shortcut icon" href="https://Vir-Limerence.github.io/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<meta name="format-detection" content="telephone=no" />
<meta name="renderer" content="webkit">
<meta name="description" content="HIT2022级网络安全研究生，在这里我将会记录一些日常学习研究">
<meta charset="UTF-8">
<title>
	八大排序算法 | MAQI&#39; blog
</title>
<link href="https://Vir-Limerence.github.io/styles/main.css" type="text/css" rel="stylesheet" />
<link href="https://at.alicdn.com/t/font_1621793_zatzzgvf30g.css" type="text/css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
<script async src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.min.js"></script>
<script src="https://Vir-Limerence.github.io/media/js/magnify.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>

<script
	type="text/javascript">function btn_toggle() { document.getElementById("hn").classList.contains("no-js") ? document.getElementById("hn").classList.remove("no-js") : document.getElementById("hn").classList.add("no-js") }
</script>
<!--  -->
<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?e2a8873f488fc608a445013cc86317b0";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
</script>
	


		<link rel="canonical" href="https://Vir-Limerence.github.io/post/ba-da-pai-xu-suan-fa/" />
</head>

<body>
	<div class="progress"></div>
<style>
    body::after {
        content: "";
        background-repeat: no-repeat;
        background-position: center;
        opacity: .06;
        -webkit-filter: grayscale(100%);
        -moz-filter: grayscale(100%);
        -ms-filter: grayscale(100%);
        -o-filter: grayscale(100%);
        filter: grayscale(100%);
        filter: gray;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1
    }

    body::after {
        background-image: url(https://img.xjh.me/random_img.php?type=bg&ctype=acg&return=302)
    }

    .progress {
        background: linear-gradient(to right, #87ceeb var(--scroll), transparent 0);
        background-repeat: no-repeat;
        position: fixed;
        width: 100%;
        height: 4px;
        z-index: 1
    }

    #blogTitle {
        background: url(https://img.xjh.me/random_img.php?type=bg&ctype=nature&return=302) center center / cover no-repeat #222;
        overflow: hidden;
        width: 100%;
        height: 40vh;
        max-height: 40vh;
        box-shadow: 0 1px 2px rgba(150, 150, 150, .7);
        text-align: center;
        display: table
    }


    .vertical {
        display: table-cell;
        vertical-align: middle;
        width: 100%;
        position: relative;
        z-index: 2
    }

    #Header1_HeaderTitle {
        font-family: 'Playball', cursive;
        color: #fff;
        font-size: 3rem;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        margin: 10px 0 10px 0;
        letter-spacing: -1px;
        font-weight: 700;
        animation: fade-in-down 1s both;
        animation-delay: .5s
    }

    .vertical h2 {
        margin: 0;
        font-size: 1rem;
        line-height: 1.5em;
        font-weight: 400;
        letter-spacing: .01rem;
        color: rgba(255, 255, 255, 0.8);
        -webkit-animation: fade-in-down .9s;
        animation: fade-in-down .9s both;
        -webkit-animation-delay: .1s;
        animation-delay: .3s;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 10;
        overflow: hidden;
        font-family: 'Playball', cursive
    }

    .poem-wrap {
        position: relative;
        width: 1000px;
        max-width: 80%;
        border: 2px solid #797979;
        border-top: 0;
        text-align: center;
        margin: 40px auto
    }

    .poem-left {
        left: 0
    }

    .poem-right {
        right: 0
    }

    .poem-border {
        position: absolute;
        height: 2px;
        width: 27%;
        background-color: #797979
    }

    .poem-wrap p {
        width: 70%;
        margin: auto;
        line-height: 30px;
        color: #797979
    }

    .poem-wrap h1 {
        position: relative;
        margin-top: -20px;
        display: inline-block;
        letter-spacing: 4px;
        color: #797979;
        font-size: 2em;
        margin-bottom: 20px;
        /* 将标题位于poem-wrap的正中央 */
    }

    #poem_sentence {
        font-size: 25px;
        color: #797979;
        /* 设置文字居中 */
        text-align: center;
    }

    #poem_info {
        font-size: 15px;
        margin: 15px auto;
        color: #797979;
        text-align: center;
    }

    #navList {
        text-align: center;
        margin: 0;
        padding: 0;
        /* 设置字体大小 */
        font-size: 20px;
    }

    #navList li {
        font-family: 'Josefin Sans Light', -apple-system, BlinkMacSystemFont, "Helvetica Neue", "PingFang SC", "'Hiragino Sans GB", STHeiti, "Microsoft Yahei", "Source Han Sans SC", "Noto Sans CJK SC", "WenQuanYi Micro Hei", Arial, Verdana, sans-serif;
        color: #95a5a6;
        display: inline-block;
        padding: 1rem;
        font-size: 1rem;
        text-align: center
    }

    #navList li a {
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.3)
    }

    #navList li a:hover {
        color: #f60;
        font-weight: 500
    }

    #navigator {
        width: 100%;
        box-shadow: 0 1px 3px rgba(26, 26, 26, .1);
        background: hsla(0, 0%, 100%, .6);
        z-index: 1;
    }
    #starfield {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }
</style>
<div class="darkmode-background"></div>
<div class="darkmode-layer"></div>
<noscript>
    <p class="warn">本页面需要浏览器支持（启用）JavaScript</p>
</noscript>
<!-- 添加星星 -->
<canvas id="starfield"></canvas>
<script>
    // 获取画布及上下文
    var canvas = document.getElementById('starfield');
    var ctx = canvas.getContext('2d');

    // 设置画布大小
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // 创建一个存储星星的数组
    var stars = [];

    // 创建初始的星星
    for (var i = 0; i < 200; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            speed: 1 + Math.random() * 5
        });
    }

    // 定义一个函数来清除画布
    function clear() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // 定义一个函数来更新星星的位置
    function update() {
        for (var i = 0; i < stars.length; i++) {
            stars[i].y += stars[i].speed;
            if (stars[i].y > canvas.height) {
                stars[i].y = 0;
                stars[i].x = Math.random() * canvas.width;
            }
        }
    }

    // 定义一个函数来绘制星星
    function draw() {
        for (var i = 0; i < stars.length; i++) {
            ctx.beginPath();
            ctx.arc(stars[i].x, stars[i].y, 1, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'white';
            ctx.fill();
        }
    }

    // 定义一个函数来执行动画
    function animate() {
        clear();
        update();
        draw();
        requestAnimationFrame(animate);
    }

    // 启动动画
    animate();
</script>
<!-- 添加星星 -->
<div class="header">
    <!-- 添加头部标题 -->
    <div id="blogTitle" style="margin-bottom: 0px;">
        <div class="vertical">
            <h1>
                <a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="/">
                    MAQI&#39; blog
                </a>
            </h1>
        </div>
    </div>
    <!-- 添加导航栏 -->
    <div id="navigator" style="position: static; top: 0px;">
        <div class="nav">
            <ul id="navList">
                
                    <li>
                        <a id="d2ef19af68cc211e98f8a0242ac110003" href="/">
                            首页
                        </a>
                    </li>
                    
                    <li>
                        <a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives">
                            归档
                        </a>
                    </li>
                    
                    <li>
                        <a id="d2ef19af68cc211e98f8a0242ac110003" href="/columns">
                            专栏
                        </a>
                    </li>
                    
                    <li>
                        <a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags">
                            标签
                        </a>
                    </li>
                    
                    <li>
                        <a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about">
                            关于
                        </a>
                    </li>
                    
                        <li>
                            <form id="gridea-search-form" data-update="1578893743252" action="/search/index.html"><input
                                    class="search-input" autocomplete="off" spellcheck="false" name="q"
                                    placeholder="搜索"></form>
                        </li>
                        <li>
                            <input id="switch_default" onclick="mobileBtn()" type="checkbox"
                                class="switch_default"><label for="switch_default"></label>
                        </li>
            </ul>
        </div>
    </div>
    <!-- 添加导航栏 -->
    <!-- 添加古诗词 -->
    <div class="poem-wrap">
        <div class="poem-border poem-left"></div>
        <div class="poem-border poem-right"></div>
        <h1>念两句诗</h1>
        <div id="poem_sentence"></div>
        <div id="poem_info"></div>
    </div>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script type="text/javascript">
        jinrishici.load(function (result) {
            var sentence = document.querySelector("#poem_sentence")
            var info = document.querySelector("#poem_info")
            sentence.innerHTML = result.data.content
            info.innerHTML = '【' + result.data.origin.dynasty + '】' + result.data.origin.author + '《' + result.data.origin.title + '》'
        });
    </script>
    <!-- 添加古诗词 -->
</div>
<!--调节亮度-->
<script>
    function enableDarkmode() {
        document.body.classList.add("darkmode");
        document.getElementById("switch_default").checked = true;
        document.getElementById("switch_default_h").checked = true;
    }

    function removeDarkmode() {
        document.body.classList.remove("darkmode");
        document.getElementById("switch_default").checked = false;
        document.getElementById("switch_default_h").checked = false;
    }

    function getCookie(name) {
        var match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
        return match ? match[2] : null;
    }

    // 删除或注释掉以下行，以防止页面加载时自动启用暗色模式
    // var cookie = getCookie("darkmode");
    // if ("enable" === cookie) enableDarkmode();

    // 如果您希望根据系统的首选项颜色方案自动切换，可以保留以下代码
    // 但是请确保"disable"不在cookie中
    // if (window.matchMedia("(prefers-color-scheme: dark)").matches && "disable" !== cookie) {
    //     enableDarkmode();
    //     document.cookie = "darkmode=enable; path=/";
    // }

    var mobileBtn = function() {
        if (document.getElementById("switch_default").checked) {
            enableDarkmode();
            document.cookie = "darkmode=enable; path=/";
        } else {
            removeDarkmode();
            document.cookie = "darkmode=disable; path=/";
        }
    };
</script>
		<div class="main">
			<div class="main-inner">
				<div class="content">
					<article class="post">
						<h2 class="post_title sm_margin"><a>
								八大排序算法
							</a></h2>
						<script>function lan() { if (document.getElementById("lan").innerText == "繁") { var s = document.getElementById("tongwenlet_cn"); if (s != null) { document.body.removeChild(s) } var s = document.createElement("script"); s.language = "javascript"; s.type = "text/javascript"; s.src = "https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_tw.js"; s.id = "tongwenlet_cn"; document.body.appendChild(s); document.getElementById("lan").innerHTML = "简" } else { if (document.getElementById("lan").innerText == "簡") { var s = document.getElementById("tongwenlet_cn"); if (s != null) { document.body.removeChild(s) } var s = document.createElement("script"); s.language = "javascript"; s.type = "text/javascript"; s.src = "https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_cn.js"; s.id = "tongwenlet_cn"; document.body.appendChild(s); document.getElementById("lan").innerHTML = "繁" } } };</script>
						<section class="post_details"><i class="iconfont icon-calendar"></i><span
								style="margin-right:15px">
								2024-08-22
							</span><i class="iconfont icon-browse"></i><span style="margin-right:15px"> <span
									id="busuanzi_value_page_pv"></span>浏览</span>
									<i class="iconfont icon-category"></i>
								<!-- <span class="weaklink" style="margin-right:15px"> -->
								 <a href="https://Vir-Limerence.github.io/tag/huYvc0vQH/" class="tag">
										面试必备
									</a>
									
								
							</span><i class="iconfont icon-caret-down"></i><span style="margin-right:15px">
								2596字
							</span><i class="iconfont icon-naozhong"></i><span style="margin-right:15px">
								12 min read
							</span><a id="lan" href="javascript:void(0);" onclick="lan();" title="调整简繁体"
								style="margin-right:15px;">繁</a>
							
						</section>
						
							<!-- <img class="featureImg" alt="featureimg" src="https://image.baidu.com/search/down?url=https://tvax3.sinaimg.cn//large/0072Vf1pgy1foxkfhjrg5j31hc0u0nfw.jpg"
								referrerpolicy="no-referrer">
							 -->
								<div style="display:flex">
									<div class="markdown-body" id="md_block">
										<div class="round-shape-one"></div>
										<h1 id="插入排序">插入排序</h1>
<h2 id="直接插入排序">直接插入排序</h2>
<p>把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。</p>
<p>时间复杂度：O(N^2) 空间复杂度：O(1) 稳定</p>
<pre><code class="language-Java">public static void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i &lt; n; ++i) {
        int key = arr[i];
        int j = i - 1;

        // 将选中的元素与已排序的元素进行比较，并将较大的元素向后移动
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        // 将选中的元素插入到正确的位置
        arr[j + 1] = key;
    }
}

</code></pre>
<figure data-type="image" tabindex="1"><img src="../images/202201122058377.gif" alt="直接插入排序" loading="lazy"></figure>
<h2 id="希尔排序">希尔排序</h2>
<p>希尔排序在直接排序之前，进行预排列，将某些极端数据更快的排列到数列前面，构成一个接近排列好的序列，最后再进行一次直接插入排序。<strong>预排列的原理也是插入排列，只不过这里的将数组分成了gap组，分别对每一个小组进行插入排序</strong>。希尔排序是对直接插入排序的优化，<strong>当gap &gt; 1时都是预排序</strong>，目的是让数组更接近于有序。<strong>当gap == 1时，数组已经接近有序的了</strong>，这样就会很快。</p>
<p>时间复杂度：O(N*logN) 空间复杂度O(1) 不稳定</p>
<pre><code class="language-Java">public static void shellSort(int[] arr) {
    int n = arr.length;
    for (int gap = n / 2; gap &gt; 0; gap /= 2) {
        for (int i = gap; i &lt; n; i += 1) {
            int key = arr[i];
            int j = i;

            // 将arr[i]插入到前面已经排好的序列中
            while (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = key;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="../images/202201122058905.gif" alt="希尔排序" loading="lazy"></figure>
<h1 id="选择排序">选择排序</h1>
<h2 id="直接选择排序">直接选择排序</h2>
<p>每一次遍历待排序的数据元素从中选出最小（或最大）的一个元素，存放在序列的起始（或者末尾）位置，直到全部待排序的数据元素排完。</p>
<p>时间复杂度：O(N^2) 空间复杂度：O(1) 不稳定</p>
<pre><code class="language-java">public static void selectionSort(int[] arr) {
    int n = arr.length;

    // 外层循环控制排序的轮数
    for (int i = 0; i &lt; n - 1; i++) {
        // 假设当前位置是最小值
        int minIndex = i;
        // 内层循环用于找到最小值的索引
        for (int j = i + 1; j &lt; n; j++) {
            if (arr[j] &lt; arr[minIndex]) {
                minIndex = j; // 更新最小值的索引
            }
        }
        // 将找到的最小值和当前位置的值交换
        if (minIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="../images/202201122058565.gif" alt="直接选择排序" loading="lazy"></figure>
<p>这里我们还可以对直接选择排序做一个优化：<strong>每次遍历待排序数据找出最大和最小的数据</strong>，分别排列到序列起始和末尾。</p>
<pre><code class="language-Java">public static void optimizedSelectionSort(int[] arr) {
    int n = arr.length;

    // 外层循环控制排序的轮数
    for (int i = 0; i &lt; n / 2; i++) {
        int minIndex = i;
        int maxIndex = i;
        // 内层循环用于找到最小值和最大值的索引
        for (int j = i + 1; j &lt; n - i; j++) {
            if (arr[j] &lt; arr[minIndex]) {
                minIndex = j; // 更新最小值的索引
            }
            if (arr[j] &gt; arr[maxIndex]) {
                maxIndex = j; // 更新最大值的索引
            }
        }
        // 将找到的最小值和当前位置的值交换
        if (minIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
        // 将找到的最大值和末尾位置的值交换
        if (maxIndex != n - i - 1) {
            temp = arr[n - i - 1];
            arr[n - i - 1] = arr[maxIndex];
            arr[maxIndex] = temp;
        }
    }
}

</code></pre>
<h2 id="堆排序">堆排序</h2>
<p>堆排序是指利用堆（数据结构）进行选择数据的一种排序算法。基本思想：</p>
<ol>
<li>原则：先将原数组建成堆，需要注意的是升序需要建大堆，降序需要建立小堆</li>
<li>建堆：一个根节点与子节点数据如果不符合大堆结构，那么则对根节点数据进行向下调整，而向下调整的前提是左右子树也符合大堆结构,所以从堆尾数据的根节点位置开始向下调整建大堆</li>
<li>排序：<strong>大堆堆顶数据一定是待排数据中最大的</strong>，将堆顶数据与堆尾数据交换,交换后将除堆尾数据看成新堆，对现堆顶数据进行向下调整成大堆,以此循环直至排列完毕</li>
<li>向下调整：找到子节点中的较大数据节点比较，如果父节点数据比子节点小则交换，直到不符合则停止向下交换，此时再次构成了一个大堆结构</li>
</ol>
<p>时间复杂度：O(N*logN) 空间复杂度O(1) 不稳定</p>
<pre><code class="language-java">// 构建最大堆
public static void buildMaxHeap(int[] arr, int n) {
    for (int i = n / 2 - 1; i &gt;= 0; i--) {
        heapify(arr, n, i);
    }
}

// 堆调整
public static void heapify(int[] arr, int n, int i) {
    int largest = i; // 初始化最大值为根
    int left = 2 * i + 1; // 左子节点
    int right = 2 * i + 2; // 右子节点

    // 如果左子节点比根大，则更新最大值
    if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }

    // 如果右子节点比最大值还大，则更新最大值
    if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }

    // 如果最大值不是根，交换它们并继续堆调整
    if (largest != i) {
        int swap = arr[i];
        arr[i] = arr[largest];
        arr[largest] = swap;

        // 递归地堆调整子树
        heapify(arr, n, largest);
    }
}

// 堆排序
public static void heapSort(int[] arr) {
    int n = arr.length;
    buildMaxHeap(arr, n);

    // 一个个从堆顶取出元素
    for (int i = n - 1; i &gt;= 0; i--) {
        // 将当前的根（最大值）与最后一个元素交换
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // 堆调整剩下的元素
        heapify(arr, i, 0);
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="../images/202201122058466.gif" alt="堆排序" loading="lazy"></figure>
<h1 id="交换排序">交换排序</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>每次遍历待排序数组，对相邻数据进行比较，不符合排序要求则交换</p>
<p>时间复杂度：O(N^2) 空间复杂度：O(1) 稳定</p>
<pre><code class="language-java">public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i &lt; n - 1; i++) {
        for (int j = 0; j &lt; n - i - 1; j++) {
            // 遍历数组，比较相邻元素，如果顺序错误就交换
            if (arr[j] &gt; arr[j + 1]) {
                // 交换arr[j]和arr[j+1]
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="../images/202201122058114.gif" alt="冒泡排序" loading="lazy"></figure>
<h2 id="快排">快排</h2>
<p>任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列。左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值。</p>
<p>时间复杂度：O(N*logN)  空间复杂度：O(logN)  不稳定</p>
<pre><code class="language-java">/*
  left:数组左边界
  right：数组右边界
*/
//递归版本
public void quickSort(int[] arr, int left, int right){
    if(left &lt; right){
        int pos = partition(arr, left, right);
        quickSort(arr, left, pos - 1);
        quickSort(arr, pos + 1, right);
    }
}
//非递归版本
public static void quickSort(int[] arr, int low, int high) {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    stack.push(low);
    stack.push(high);

    while (!stack.isEmpty()) {
        // 弹出高和低索引
        high = stack.pop();
        low = stack.pop();

        // 找到分区点
        int partitionIndex = partition(arr, low, high);

        // 如果分区点的左边有元素，那么将其推入栈中
        if (partitionIndex &gt; low) {
            stack.push(low);
            stack.push(partitionIndex - 1);
        }

        // 如果分区点的右边有元素，那么将其推入栈中
        if (partitionIndex &lt; high) {
            stack.push(partitionIndex + 1);
            stack.push(high);
        }
    }
}

public int partition(int[] arr, int left, int right){
    int base = arr[left];
    while(left &lt; right){
        //从右向左找，比base大，right--
        while(left &lt; right &amp;&amp; arr[right] &gt;= base){
            right--;
        }
        arr[left] = arr[right];
        //从左向右找，比base小，left++
        while(left &lt; right &amp;&amp; arr[left] &lt;= base){
            left++;
        }
        arr[right] = arr[left];       
    }
    arr[left] = base;
    return left;
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="../images/202201122058521.gif" alt="快排" loading="lazy"></figure>
<h1 id="归并排序">归并排序</h1>
<h2 id="归并排序-2">归并排序</h2>
<p>归并排序是建立在归并操作上的一种有效的排序算法，采用分治法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>
<pre><code class="language-java">// 主归并排序函数
public static void mergeSort(int[] array, int left, int right) {
    if (left &lt; right) {
        int middle = (left + right) / 2;

        // 递归地对左半部分排序
        mergeSort(array, left, middle);
        // 递归地对右半部分排序
        mergeSort(array, middle + 1, right);
        // 合并两个已排序的子数组
        merge(array, left, middle, right);
    }
}

// 合并两个已排序的子数组
public static void merge(int[] array, int left, int middle, int right) {
    // 计算子数组的大小
    int n1 = middle - left + 1;
    int n2 = right - middle;

    // 创建临时数组
    int[] leftArray = new int[n1];
    int[] rightArray = new int[n2];

    // 拷贝数据到临时数组
    System.arraycopy(array, left, leftArray, 0, n1);
    System.arraycopy(array, middle + 1, rightArray, 0, n2);

    // 合并临时数组到原数组
    int i = 0, j = 0;
    int k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (leftArray[i] &lt;= rightArray[j]) {
            array[k++] = leftArray[i++];
        } else {
            array[k++] = rightArray[j++];
        }
    }

    // 拷贝剩余的元素
    while (i &lt; n1) {
        array[k++] = leftArray[i++];
    }
    while (j &lt; n2) {
        array[k++] = rightArray[j++];
    }
}

</code></pre>
<figure data-type="image" tabindex="7"><img src="../images/202201122059165.png" alt="归并排序" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="../images/202201122059064.gif" alt="归并排序" loading="lazy"></figure>
<h1 id="计数排序">计数排序</h1>
<p>计数排序是一种非比较排序，又称为鸽巢原理，是对哈希直接定址法的变形应用。在排序数组中找到最大最小的数据，算出对应范围并创建对应长度个数组用来计数，遍历排序数组，根据每个出现的数据值与计数数组下标构建的相对映射关系进行统计数据出现次数，最后将统计的出的数据按次序赋值给原数组。</p>
<pre><code class="language-java">// 计数排序函数
public static void countingSort(int[] array) {
    if (array.length == 0) return;

    // 在单次遍历中找到最大值和最小值
    int max = array[0];
    int min = array[0];
    for (int num : array) {
        if (num &gt; max) {
            max = num;
        }
        if (num &lt; min) {
            min = num;
        }
    }

    // 创建计数数组
    int[] count = new int[max - min + 1];

    // 统计每个元素的出现次数
    for (int num : array) {
        count[num - min]++;
    }

    // 根据计数数组填充排序后的结果数组
    int index = 0;
    for (int i = 0; i &lt; count.length; i++) {
        while (count[i] &gt; 0) {
            array[index++] = i + min;
            count[i]--;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="9"><img src="../images/202201122059678.gif" alt="计数排序" loading="lazy"></figure>
<h1 id="桶排序">桶排序</h1>
<p>桶排序（Bucket Sort）是一种基于分布的排序算法，适用于数据分布比较均匀的情况。它将数据分到若干个桶中，然后对每个桶内的数据进行排序，最后将桶中的数据合并。</p>
<pre><code class="language-java"> // 桶排序函数
public static void bucketSort(int[] array) {
    if (array.length == 0) return;

    // 1. 找到数据范围
    int min = array[0];
    int max = array[0];
    for (int num : array) {
        if (num &lt; min) min = num;
        if (num &gt; max) max = num;
    }

    // 2. 创建桶
    int bucketCount = (max - min) / array.length + 1;
    List&lt;Integer&gt;[] buckets = new ArrayList[bucketCount];
    for (int i = 0; i &lt; bucketCount; i++) {
        buckets[i] = new ArrayList&lt;&gt;();
    }

    // 3. 将数据分配到桶中
    for (int num : array) {
        int bucketIndex = (num - min) / array.length;
        buckets[bucketIndex].add(num);
    }

    // 4. 对每个桶内的数据进行排序
    for (List&lt;Integer&gt; bucket : buckets) {
        Collections.sort(bucket);
    }

    // 5. 合并桶中的数据
    int index = 0;
    for (List&lt;Integer&gt; bucket : buckets) {
        for (int num : bucket) {
            array[index++] = num;
        }
    }
}
</code></pre>
<h1 id="性能比较">性能比较</h1>
<figure data-type="image" tabindex="10"><img src="../images/202201122059726.png" alt="性能比较" loading="lazy"></figure>
<p>参考链接：https://www.nowcoder.com/discuss/353159614696988672</p>

											<span id="footnote"></span>
											<div id="warn"></div>
									</div>
									<!-- <div class="toc-container">
										这段是目录
										<ul class="markdownIt-TOC">
<li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">直接插入排序</a></li>
<li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
</ul>
</li>
<li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">直接选择排序</a></li>
<li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
</ul>
</li>
<li><a href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F">交换排序</a>
<ul>
<li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a></li>
<li><a href="#%E5%BF%AB%E6%8E%92">快排</a></li>
</ul>
</li>
<li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>
<ul>
<li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-2">归并排序</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F">计数排序</a></li>
<li><a href="#%E6%A1%B6%E6%8E%92%E5%BA%8F">桶排序</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83">性能比较</a></li>
</ul>

									</div> -->
								</div>
								<div id="fullPage"><canvas id="canvas"></canvas></div>
					</article>
					<div id="eof"><span>EOF</span></div>
					<div class="paginator pager pagination">
						<div class="paginator_container pagination_container">
							<a href="https://Vir-Limerence.github.io/post/xian-cheng-chi-xiang-guan/"
								class="btn pre newer-posts newer_posts">上一篇</a>
							
							<a href="https://Vir-Limerence.github.io/post/dan-li-mo-shi/"
									class="btn next older-posts older_posts">下一篇</a>
							
							<div style="clear:both;height:0;"></div>
						</div>
					</div>
					<div class="round-shape-one"></div>
					<section>
						<div class="doc_comments">
							
								
									<div id="gitalk-container"></div>
									<!-- <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/qyxtim/Static@3.8/gitalk.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.css" rel="stylesheet">
<script>
    var gitalk = new Gitalk({
        clientID: "eh46IDcBSFZp7u2HzUgBCcEt-gzGzoHsz",
        clientSecret: "x5QIsbzH84i1HkDH7IkRMs6s",
        repo: "", owner:
            "",
        admin: [""],
        id: (location.pathname).substring(0, 49),
        distractionFreeMode: false
    });
    gitalk.render("gitalk-container");
</script> -->
<!--评论显示区，请插入合适的位置-->
<div id="comment"></div>
<!--Leancloud 操作库:-->
<script src="https://unpkg.com/leancloud-storage@4.12.0/dist/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//cdn.jsdelivr.net/npm/valine@1.4.4/dist/Valine.min.js"></script>
<script>
    new Valine({
        el:'#comment',
        appId: "eh46IDcBSFZp7u2HzUgBCcEt-gzGzoHsz",
        appKey: "x5QIsbzH84i1HkDH7IkRMs6s",
//         masterKey: 'zliw6I1h5Gv3OJfPtEllDP6j'
        placeholder: 'ヾﾉ≧∀≦)o快来评论一下吧!',
        avatar:''
    });
</script>
										

											
														
						</div>
					</section>
				</div>
			</div>
		</div>
		<script>
			"use strict"; !function () { for (var n = document.getElementsByTagName("pre"), e = n.length, s = 0; s < e; s++) { n[s].innerHTML = '<span class="line-number"></span>' + n[s].innerHTML + '<span class="cl"></span>'; for (var a = n[s].innerHTML.split(/\n/).length, r = 0; r < a - 1; r++) { n[s].getElementsByTagName("span")[0].innerHTML += "<span>" + (r + 1) + "</span>" } } }();
			// 不使用目录的颜色标注
			// let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a"); 
			// window.addEventListener("scroll", event => {
			// 	let fromTop = window.scrollY; mainNavLinks.forEach((link, index) => {
			// 		let section = document.getElementById(decodeURI(link.hash).substring(1)); 
			// 		let nextSection = null;
			// 		if (mainNavLinks[index + 1]) { 
			// 			nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1)); 
			// 		}
			// 		if (section.offsetTop <= fromTop) { 
			// 			console.log(section);
			// 			console.log(nextSection?nextSection:0);
			// 			if (nextSection) { 
			// 				if (nextSection.offsetTop > fromTop) { 
			// 					link.classList.add("currentToc"); 
			// 				} 
			// 				else {
			// 					link.classList.remove("currentToc"); 
			// 				} 
			// 			} else { 
			// 				link.classList.add("currentToc"); 
			// 			} 
			// 		} else { 
			// 				link.classList.remove("currentToc"); 
			// 		}
			// 	});
			// });
			var h = document.documentElement, b = document.body, st = "scrollTop", sh = "scrollHeight", progress = document.querySelector(".progress"), scroll; 
			document.addEventListener("scroll", function () { scroll = (h[st] || b[st]) / ((h[sh] || b[sh]) - h.clientHeight) * 100; 
				progress.style.setProperty("--scroll", scroll + "%") });
			var wxScale = new WxScale({ fullPage: document.querySelector("#fullPage"), canvas: document.querySelector("#canvas") }); var imgBox = document.querySelectorAll("#md_block img"); for (var i = 0; i < imgBox.length; i++) { imgBox[i].onclick = function (e) { wxScale.start(this) } };
		</script>
		<a id="scrollUp" href="#top" style="position: fixed; z-index: 2147483647; display: block;"></a>
<div class="footer animated fadeInDown">
    <div class="site_footer">
        <div class="mysocials">
            <div class="my_socials">
                
                    
                            
                    
                            
                    
                            
                    <a href="https://github.com/Vir-Limerence" title="github"><i
                                class="iconfont icon-github"></i></a>
                        
                            
                    
                            
                    
                            
                    
                            
            </div>
        </div>
    </div>
</div>
<!--音乐，只在PC端宽度>1000px时显示-->
<link rel="stylesheet" href="/media/music/APlayer.min.css">
<div id="player" class="aplayer aplayer-withlist aplayer-fixed" data-id="3116636104" data-server="netease" data-type="playlist" data-order="random" data-fixed="true" data-listfolded="true" data-theme="#2D8CF0"></div>
<script src="/media/music/APlayer.min.js"></script>
<script src="/media/music/Meting.min.js"></script>
<script src="/media/music/instantpage.min.js" type="module" defer></script>
<!--看板娘-->
<script src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
<style>
    #waifu{
        right: 20px;
        left: auto;
    }
</style>
<script src="https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>

<script>
// 等待页面加载完成后再绑定事件
// window.onload = function() {
//     // 获取看板娘的 DOM 元素（通常是一个 canvas）
//     const live2dCanvas = document.getElementById('waifu');

//     // 检查是否成功获取到看板娘的元素
//     if (live2dCanvas) {
//         // 添加点击事件监听器
//         live2dCanvas.addEventListener('click', function() {
//             // 切换隐藏和显示
//             if (live2dCanvas.style.display === 'none') {
//                 live2dCanvas.style.display = 'block'; // 显示
//             } else {
//                 live2dCanvas.style.display = 'none';  // 隐藏
//             }
//         });
//     }
// };
window.onload = function() {
    document.getElementById("waifu").addEventListener("click", function() {
        localStorage.setItem("waifu-display", Date.now());

        document.getElementById("waifu").style.bottom = "-500px";
        setTimeout(() => {
            document.getElementById("waifu").style.display = "none";
            document.getElementById("waifu-toggle").classList.add("waifu-toggle-active");
        }, 3000);
    });
};
</script>

			<script type="text/javascript" async src="https://Vir-Limerence.github.io/media/js/prism.js"></script>
</body>

</html>