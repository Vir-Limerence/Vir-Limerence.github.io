<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Vir-Limerence.github.io</id>
    <title>MAQI&apos; blog</title>
    <updated>2024-10-17T02:48:50.089Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Vir-Limerence.github.io"/>
    <link rel="self" href="https://Vir-Limerence.github.io/atom.xml"/>
    <subtitle>HIT2022级网络安全研究生，在这里我将会记录一些日常学习研究</subtitle>
    <logo>https://Vir-Limerence.github.io/images/avatar.png</logo>
    <icon>https://Vir-Limerence.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, MAQI&apos; blog</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot的启动原理、流程和机制]]></title>
        <id>https://Vir-Limerence.github.io/post/springboot-de-qi-dong-yuan-li-liu-cheng-he-ji-zhi/</id>
        <link href="https://Vir-Limerence.github.io/post/springboot-de-qi-dong-yuan-li-liu-cheng-he-ji-zhi/">
        </link>
        <updated>2024-09-23T13:50:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springboot-启动原理-启动过程-启动机制的介绍">springboot 启动原理、启动过程、启动机制的介绍</h1>
<h1 id="1启动原理">1.启动原理</h1>
<p>Spring Boot的一个核心特点是自动配置，它会自动配置Spring应用程序基于项目中添加的jar依赖。如果项目中包括<code> spring-boot-starter-web</code> 依赖，Spring Boot将会配置应用程序使用Tomcat作为默认服务器，并且将基本的MVC支持加入容器中，这是通过<code> classpath</code> 和已经定义的beans来决定配置类的自动应用来实现的，使用的是<code>@EnableAutoConfiguration</code> 注解。</p>
<h2 id="11起步依赖starters">1.1起步依赖(starters)</h2>
<p>Spring Boot 的起步依赖是一组方便的依赖描述符，你可以在应用程序的 <code>pom.xml</code> 中添加它们。每一个起步依赖都旨在简化构建配置，提供所需的依赖。这让你在不担心版本冲突的情况下快速开始一个功能完备的开发环境。</p>
<h2 id="12命令行界面">1.2命令行界面</h2>
<p>Spring Boot提供一个可选的CLI，用于快速开发和原型制作Spring应用，CLI使用Spring的<code>@* </code> 注解进行编码，允许通过 Groovy 语言快速编写 Spring 应用。</p>
<h2 id="13内嵌服务器">1.3内嵌服务器</h2>
<p>Spring Boot 内置了常见的服务器（如 Tomcat、Jetty 或 Undertow），无需复杂的服务器配置，只需一个简单的 <code>main()</code> 方法，即可将应用打包为单一的、可执行的 JAR 文件，这个 JAR 文件包含了一切必要的依赖、类和资源。</p>
<h2 id="14外部化配置">1.4外部化配置</h2>
<p>Spring Boot 允许你通过外部配置（如 properties 文件、YAML 文件、环境变量和命令行参数）来管理应用程序的配置。这使得你的应用可以在不同环境中使用相同的代码，而不需要重新构建。</p>
<h2 id="15监控和管理">1.5监控和管理</h2>
<p>Spring Boot Actuator 提供了许多生产级的特性，如监控和管理应用程序。它可以通过 HTTP 或 JMX 访问应用的内部状态。</p>
<h2 id="16无代码生成和xml配置">1.6无代码生成和XML配置</h2>
<p>Spring Boot 被设计为尽可能地减少显式配置。它使用条件注解来评估环境，自动配置 Spring 容器。Spring Boot 应用不需要使用 XML 配置，尽管可以选择使用 XML 来定义配置，但默认情况下，这种需求被最小化了。</p>
<p>通过以上原理，Spring Boot 实现了“约定大于配置”的软件设计范式，极大地简化了基于 Spring 的应用开发和服务部署。</p>
<h1 id="2启动过程">2.启动过程</h1>
<h2 id="21启动入口">2.1启动入口</h2>
<p>Spring  Boot 应用的启动从一个包含 <code>main()</code> 方法的主类开始。这个主类会使用 <code>SpringApplication.run()</code> 方法来启动 Spring 应用。通常，这个类还带有 <code>@SpringBootApplication</code> 注解，它是一个组合注解，包含了 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</p>
<h2 id="22创建springapplication-对象">2.2创建<code>SpringApplication</code> 对象</h2>
<p>当调用 <code>SpringApplication.run()</code> 时，首先会创建一个 <code>SpringApplication</code> 对象。这个对象负责管理 Spring 应用的启动和初始化。它会设置一些基础属性，比如是否应该添加命令行属性，是否需要横幅（Banner）等。</p>
<h2 id="23运行springapplication">2.3运行<code>SpringApplication</code></h2>
<p>接下来，<code>SpringApplication</code> 对象调用其 <code>run()</code> 方法。这个过程涉及多个重要步骤：</p>
<ul>
<li>
<p><strong>初始化应用上下文</strong>：根据你选择的 web 环境类型（如 Servlet 或 Reactive），Spring Boot 设置合适的应用上下文（<code>ApplicationContext</code>）。</p>
</li>
<li>
<p><strong>环境准备</strong>：在应用上下文准备前，先准备环境（<code>Environment</code>），这包括配置文件、命令行参数、环境变量等的解析。</p>
</li>
<li>
<p><strong>横幅输出</strong>：如果启用，Spring Boot 的启动过程中会在控制台打印一个横幅。</p>
</li>
<li>
<p><strong>注册应用上下文初始化器和监听器</strong>：应用上下文初始化器（<code>ApplicationContextInitializer</code>）和应用事件监听器（<code>ApplicationListener</code>）会被加载和注册，它们可以在上下文的生命周期的不同阶段执行操作。</p>
</li>
<li>
<p><strong>加载 Bean 定义</strong>：通过扫描类路径中的组件和配置类（由 <code>@ComponentScan</code> 和 <code>@Configuration</code> 等注解指定）来加载 Bean 定义。</p>
</li>
</ul>
<h2 id="24自动配置和bean的创建">2.4自动配置和Bean的创建</h2>
<ul>
<li><strong>自动配置</strong>：<code>@EnableAutoConfiguration</code> 注解激活了自动配置的魔法，它告诉 Spring Boot 基于添加到项目中的 jar 依赖，尝试去猜测并配置你可能需要的 Bean。自动配置类会在应用上下文中被条件化地执行。</li>
<li><strong>Bean 实例化</strong>：在所有的配置类和组件被加载之后，Spring 容器会根据需要创建和配置 Bean 实例。</li>
</ul>
<h2 id="25运行应用上下文">2.5运行应用上下文</h2>
<ul>
<li><strong>刷新应用上下文</strong>：完成所有配置后，应用上下文会被刷新，此时所有的 Bean 都已注册完毕，且已准备就绪。</li>
<li><strong>触发命令行运行器</strong>：如果应用中包含 <code>CommandLineRunner</code> 或 <code>ApplicationRunner</code> Bean，它们会在此时执行。</li>
</ul>
<h2 id="26应用就绪">2.6应用就绪</h2>
<ul>
<li><strong>触发应用就绪事件</strong>：最后，一个 <code>ApplicationReadyEvent</code> 被发布，表明应用已完全启动并准备好接收请求。</li>
</ul>
<h1 id="3启动过程详解">3.启动过程详解</h1>
<ul>
<li>
<p>Spring Boot的启动过程从加载包含 <code>main()</code> 方法的主类开始。这个主类通常使用 <code>@SpringBootApplication</code> 注解标记，它是一个组合注解，包含了 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</p>
</li>
<li>
<p>在主类中调用 <code>SpringApplication.run()</code> 方法，会创建一个 <code>SpringApplication</code> 对象。这个对象负责管理 Spring 应用的启动和初始化。</p>
</li>
<li>
<p><code>SpringApplication</code> 对象负责准备 Spring 应用的环境。这包括读取配置文件、解析命令行参数、收集系统环境变量等。这些环境属性将会被用于配置应用上下文和其他组件。</p>
</li>
<li>
<p><code>SpringApplication</code> 使用环境信息初始化 Spring 应用上下文（<code>ApplicationContext</code>）。根据应用是 Web 应用还是非 Web 应用，Spring Boot 会创建对应的应用上下文。</p>
</li>
<li>
<p>应用上下文初始化后，Spring Boot 开始加载 Bean 的定义。它会扫描项目中的组件和配置类（由 <code>@ComponentScan</code> 和 <code>@Configuration</code> 注解指定），并将它们注册到应用上下文中。</p>
</li>
<li>
<p>Spring Boot 的自动配置机制会根据项目中添加的 jar 依赖，尝试猜测并配置可能需要的 Bean。自动配置类会根据条件进行加载和执行，以确保配置的正确性和合理性。</p>
</li>
<li>
<p>所有配置类和组件被加载后，Spring 容器会根据需要创建和配置 Bean 实例。这些 Bean 可能是由 Spring Boot 提供的自动配置，也可能是开发者自定义的 Bean。</p>
</li>
<li>
<p>当所有 Bean 定义加载完毕后，应用上下文会被刷新。在这个阶段，Spring Boot 会执行一系列的初始化动作，确保所有 Bean 都被正确地创建和配置。</p>
</li>
<li>
<p>应用上下文初始化完成后，Spring Boot 将应用状态标记为“已启动”。此时，应用已准备就绪，可以处理请求和响应。</p>
</li>
<li>
<p>在应用启动过程中，Spring Boot 会触发一系列的生命周期事件，如应用启动事件、应用就绪事件等。开发者可以监听这些事件并执行相应的操作。通过这些步骤，Spring Boot 实现了一个简洁而高效的启动过程，使得开发者能够快速启动和运行一个独立的、生产级的应用程序。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线段树和树状数组]]></title>
        <id>https://Vir-Limerence.github.io/post/xian-duan-shu-he-shu-zhuang-shu-zu/</id>
        <link href="https://Vir-Limerence.github.io/post/xian-duan-shu-he-shu-zhuang-shu-zu/">
        </link>
        <updated>2024-09-08T09:13:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="线段树和树状数组">线段树和树状数组</h1>
<h2 id="1线段树">1.线段树</h2>
<blockquote>
<p>线段树适用于<strong>区间操作</strong>较为复杂或者需要处理多个不同类型的区间操作的场景。具体如下：</p>
<ul>
<li>区间求和、区间最值查询</li>
<li>区间更新</li>
<li>复杂的动态区间操作（区间最大公约数、最小公倍数）</li>
<li>支持懒标记的区间更新（更新无需遍历整个区间）</li>
</ul>
</blockquote>
<h3 id="代码模板">代码模板</h3>
<pre><code class="language-java">class SegmentTree{
    //存储线段树的数组
    private int[] tree;
    //存储原始数据的数组
    private int[] data;
    //构造初始化
    public SegmentTree(int[] data){
        this.data = data;
        this.n = data.length;
        tree = new int[n*4];
        build(0,0,n-1);
    }
    private void build(int node, int start, int end){
        if(start == end){
            //叶子节点
            tree[node]= data[start];
        }else{
            int mid = (start+end)/2;
            int leftChild = 2*node + 1;
            int rightChild = 2*node + 2;
            build(leftChild, start, mid);
            build(rightChild, mid+1, end);
            tree[node] = tree[leftChild] + tree[rightChild]; // 区间和
        }
    }
    private int query(int L, int R){
        return query(0,0,n-1,L,R);
    }
    private int query(int node, int start, int end, int L, int R){
        if(R&lt;start || L&gt;end){
            return 0;
        }
        if(L&lt;=start &amp;&amp; end&lt;=R){
            return tree[node];
        }
        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        int leftSum = query(leftChild, start, mid, L, R);
        int rightSum = query(rightChild, mid + 1, end, L, R);
        return leftSum + rightSum;
    }
    
    //单点更新，将data[index]的值更新为val
    public void update(int index, int val) {
        update(0, 0, n - 1, index, val);
    }
    private void update(int node, int start, int end, int index, int val) {
        if (start == end) {
            data[index] = val;
            tree[node] = val;
        } else {
            int mid = (start + end) / 2;
            int leftChild = 2 * node + 1;
            int rightChild = 2 * node + 2;
            if (index &lt;= mid) {
                update(leftChild, start, mid, index, val);
            } else {
                update(rightChild, mid + 1, end, index, val);
            }
            tree[node] = tree[leftChild] + tree[rightChild]; // 更新区间和
        }
    }
}
</code></pre>
<h2 id="2树状数组">2.树状数组</h2>
<blockquote>
<p>树状数组的应用场景多集中在需要快速处理<strong>单点更新、区间查询</strong>的场景，尤其是在操作相对简单且要求较少的情况下。</p>
<ul>
<li>前缀和查询</li>
<li>单点更新+区间查询</li>
<li>动态数组操作</li>
</ul>
</blockquote>
<pre><code class="language-java">Class FenwickTree{
    private int[] tree;
    private int n;
    public FenwickTree(int n) {
        this.n = n;
        // 树状数组从索引1开始，0索引不用
        tree = new int[n + 1]; 
    }
     // 单点更新，将index处的值加上val
    public void update(int index, int val) {
        while (index &lt;= n) {
            tree[index] += val;
            index += index &amp; -index; // 更新父节点
        }
    }
    // 前缀和查询 [1, index]
    public int query(int index) {
        int sum = 0;
        while (index &gt; 0) {
            sum += tree[index];
            index -= index &amp; -index; // 访问父节点
        }
        return sum;
    }
    // 区间和查询 [L, R]
    public int queryRange(int L, int R) {
        return query(R) - query(L - 1);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手写HashMap]]></title>
        <id>https://Vir-Limerence.github.io/post/shou-xie-hashmap/</id>
        <link href="https://Vir-Limerence.github.io/post/shou-xie-hashmap/">
        </link>
        <updated>2024-09-08T08:34:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="手写hashmap">手写HashMap</h1>
<h2 id="1定义hashmap的存储单元node">1.定义HashMap的存储单元Node</h2>
<pre><code class="language-java">class Node&lt;K,V&gt;{
    final K key;
    V value;
    Node&lt;K, V&gt; next;
    Node(K key, V value){
        this.key = key;
        this.value = value;
    }
}
</code></pre>
<h2 id="2构造器初始化和默认参数">2.构造器初始化和默认参数</h2>
<pre><code class="language-java">//定义一个默认的初始容量
private static final int DEFAULT_CAPACITY = 16;
private static final float LOAD_FACTOR = 0.75f;
//构造参数
private Node&lt;K,V&gt;[] table;//哈希表
private int size; //当前哈希表中元素个数
private int capacity; //当前哈希表的容量
//构造函数
public SimpleHashMap(){
    this.capacity = DEFAULT_CAPACITY;
    this.table = new Node[capacity];
    this.size = 0;
}
</code></pre>
<h2 id="3计算索引">3.计算索引</h2>
<pre><code class="language-java">private int hash(K key){
    return key==null?0:Objects.hashCode(key) &amp; (capacity-1);
}
</code></pre>
<h2 id="4插入更新put">4.插入/更新put</h2>
<pre><code class="language-java">public void put(K key, V value){
    int hash = hash(key);
    Node&lt;K,V&gt; node = table[hash];
    while(node!=null){
        if(Objects.equals(node.key, key)){
            //如果找到key，更新值
            node.value = value;
            return;
        }
        node = node.next;
    }
    //否则，将新的节点插入链表头
    Node&lt;K,V&gt; newNode = new Node&lt;&gt;(key,value);
    //头插法
    newNode.next = table[hash];
    table[hash] = newNode;
    size++;
    //插入元素后，判断是否需要扩容
    if(size&gt;=capacity * LOAD_FACTOR){
        resize();
    }
}
</code></pre>
<h2 id="5获取get">5.获取get</h2>
<pre><code class="language-java">public V get(K key){
    int hash = hash(key);
    Node&lt;K,V&gt; node = table[hash];
    //遍历链表，寻找key
    while(node!=null){
        if(Objects.equals(node.key, key)){
            //返回找到的值
            return node.value;
        }
        //如果没有找到，返回null
        node = node.next;
    }
    return null;
}
</code></pre>
<h2 id="6删除remove">6.删除remove</h2>
<pre><code class="language-java">public V remove(K key){
    int hash = hash(key);
    Node&lt;K,V&gt; node = table[hash];
    Node&lt;K,V&gt; prev = null;
    //遍历链表，找到要删除的节点
    while(node!=null){
        if(Objects.equals(node.key, key)){
            if(prev==null){
                //如果要删除的节点是头节点
                table[hash] = node.next;
            }else{
                prev.next = node.next;
            }
            size--;
            return node.value;
        }
        prev = node;
        node = node.next;
    }
    return null;
}
</code></pre>
<h2 id="7扩展哈希表的容量resize">7.扩展哈希表的容量resize</h2>
<pre><code class="language-java">public void resize(){
    capacity = capacity * 2;
    Node&lt;K,V&gt;[] newTable = new Node[capacity];
    for(Node&lt;K,V&gt;node:table){
        while(node!=null){
            Node&lt;K,V&gt; next = node.next;
            int hash = Objects.hashCode(node.key)&amp;(capacity-1);
            node.next=newTable[hash];
            newTable[hash] = node;
            node = next;
        }
    }
    table = newTable;
}
</code></pre>
<h2 id="8完整代码">8.完整代码</h2>
<pre><code class="language-java">import java.util.Objects;

class SimpleHashMap&lt;K, V&gt; {

    // 定义一个默认的初始容量
    private static final int DEFAULT_CAPACITY = 16;
    // 定义装载因子，用于扩展哈希表的大小
    private static final float LOAD_FACTOR = 0.75f;
    
    // 哈希表中的节点类
    class Node&lt;K, V&gt; {
        final K key;
        V value;
        Node&lt;K, V&gt; next;

        Node(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    private Node&lt;K, V&gt;[] table; // 哈希表
    private int size;           // 当前哈希表中元素个数
    private int capacity;       // 当前哈希表的容量

    // 构造函数
    public SimpleHashMap() {
        this.capacity = DEFAULT_CAPACITY;
        this.table = new Node[capacity];
        this.size = 0;
    }

    // 获取哈希值
    private int hash(K key) {
        return key == null ? 0 : Objects.hashCode(key) &amp; (capacity - 1);
    }

    // 插入或更新key-value对
    public void put(K key, V value) {
        int hash = hash(key);
        Node&lt;K, V&gt; node = table[hash];
        // 遍历链表，检查是否已经存在该key
        while (node != null) {
            if (Objects.equals(node.key, key)) {
                node.value = value; // 如果找到key，更新值
                return;
            }
            node = node.next;
        }
        // 否则，将新节点插入链表头
        Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value);
        newNode.next = table[hash];
        table[hash] = newNode;
        size++;

        // 检查是否需要扩容
        if (size &gt;= capacity * LOAD_FACTOR) {
            resize();
        }
    }

    // 获取key对应的value
    public V get(K key) {
        int hash = hash(key);
        Node&lt;K, V&gt; node = table[hash];
        // 遍历链表，寻找key
        while (node != null) {
            if (Objects.equals(node.key, key)) {
                return node.value; // 返回找到的值
            }
            node = node.next;
        }
        return null; // 如果未找到，返回null
    }

    // 删除key对应的节点
    public V remove(K key) {
        int hash = hash(key);
        Node&lt;K, V&gt; node = table[hash];
        Node&lt;K, V&gt; prev = null;

        // 遍历链表，寻找要删除的节点
        while (node != null) {
            if (Objects.equals(node.key, key)) {
                if (prev == null) {
                    // 如果要删除的是链表头节点
                    table[hash] = node.next;
                } else {
                    prev.next = node.next;
                }
                size--;
                return node.value; // 返回被删除的值
            }
            prev = node;
            node = node.next;
        }
        return null; // 未找到返回null
    }

    // 扩展哈希表的容量
    private void resize() {
        capacity = capacity * 2;
        Node&lt;K, V&gt;[] newTable = new Node[capacity];

        // 重新散列所有元素到新表
        for (Node&lt;K, V&gt; node : table) {
            while (node != null) {
                Node&lt;K, V&gt; next = node.next;
                int hash = Objects.hashCode(node.key) &amp; (capacity - 1);
                node.next = newTable[hash];
                newTable[hash] = node;
                node = next;
            }
        }
        table = newTable;
    }

    // 获取当前哈希表中的元素个数
    public int size() {
        return size;
    }

    // 检查哈希表是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    public static void main(String[] args) {
        SimpleHashMap&lt;String, Integer&gt; map = new SimpleHashMap&lt;&gt;();
        map.put(&quot;one&quot;, 1);
        map.put(&quot;two&quot;, 2);
        map.put(&quot;three&quot;, 3);

        System.out.println(&quot;Get 'two': &quot; + map.get(&quot;two&quot;));  // 输出 2
        System.out.println(&quot;Remove 'two': &quot; + map.remove(&quot;two&quot;)); // 删除并输出 2
        System.out.println(&quot;Get 'two' after removal: &quot; + map.get(&quot;two&quot;)); // 输出 null

        System.out.println(&quot;Map size: &quot; + map.size()); // 输出 2
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程池相关]]></title>
        <id>https://Vir-Limerence.github.io/post/xian-cheng-chi-xiang-guan/</id>
        <link href="https://Vir-Limerence.github.io/post/xian-cheng-chi-xiang-guan/">
        </link>
        <updated>2024-08-23T03:16:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="交替打印数字">交替打印数字</h1>
<h2 id="利用volatile同步">利用volatile同步</h2>
<pre><code class="language-java">public class VolatilePrint {
    // 全局变量i，用于计数
    private static int i = 1;
    // 是否是奇数的标志，用volatile保证可见性
    private static volatile boolean isOdd = true;

    public static void main(String[] args) {
        // 线程A，负责打印奇数
        new Thread(() -&gt; {
            while (i &lt;= 100) {
                if (isOdd) {
                    // 打印奇数
                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++);
                    // 打印完奇数后，将标志设为false
                    isOdd = false;
                }
            }
        }, &quot;Thread-A&quot;).start();

        // 线程B，负责打印偶数
        new Thread(() -&gt; {
            while (i &lt;= 100) {
                if (!isOdd) {
                    // 打印偶数
                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++);
                    // 打印完偶数后，将标志设为true
                    isOdd = true;
                }
            }
        }, &quot;Thread-B&quot;).start();
    }
}
</code></pre>
<h2 id="利用waitnotify同步">利用wait()/notify()同步</h2>
<pre><code class="language-java">public class WaitNotify {
    // 全局变量i，用于计数
    public static int i = 1;
    // 锁对象，用于线程同步
    public static final Object lock = new Object();

    public static void main(String[] args) {
        // 线程A，负责打印奇数
        new Thread(() -&gt; {
            synchronized (lock) {
                while (i &lt;= 100) {
                    if (i % 2 == 1) {
                        // 打印奇数
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++);
                        // 唤醒其他线程
                        lock.notify();
                    } else {
                        try {
                            // 当前线程等待，释放锁
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }, &quot;Thread-A&quot;).start();

        // 线程B，负责打印偶数
        new Thread(() -&gt; {
            synchronized (lock) {
                while (i &lt;= 100) {
                    if (i % 2 == 0) {
                        // 打印偶数
                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++);
                        // 唤醒其他线程
                        lock.notify();
                    } else {
                        try {
                            // 当前线程等待，释放锁
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }, &quot;Thread-B&quot;).start();
    }
}
</code></pre>
<h2 id="使用semaphore信号量">使用Semaphore信号量</h2>
<pre><code class="language-java">import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    // 全局变量i，用于计数
    private static int i = 1;
    // 奇数信号量，初始许可数为1
    private static Semaphore semaphoreOdd = new Semaphore(1);
    // 偶数信号量，初始许可数为0
    private static Semaphore semaphoreEven = new Semaphore(0);

    public static void main(String[] args) {
        // 线程A，负责打印奇数
        new Thread(() -&gt; {
            while (i &lt;= 100) {
                try {
                    // 获取奇数信号量，获取后许可数变为0
                    semaphoreOdd.acquire();
                    // 打印奇数
                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++);
                    // 释放偶数信号量，许可数加1
                    semaphoreEven.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;Thread-A&quot;).start();

        // 线程B，负责打印偶数
        new Thread(() -&gt; {
            while (i &lt;= 100) {
                try {
                    // 获取偶数信号量，获取后许可数变为0
                    semaphoreEven.acquire();
                    // 打印偶数
                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i++);
                    // 释放奇数信号量，许可数加1
                    semaphoreOdd.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;Thread-B&quot;).start();
    }
}
</code></pre>
<h2 id="使用condition和lock">使用Condition和Lock</h2>
<pre><code class="language-java">import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ConditionExample {
    // 全局变量i，用于计数
    private static int i = 1;
    // 可重入锁
    private static final Lock lock = new ReentrantLock();
    // 奇数条件变量
    private static final Condition conditionOdd = lock.newCondition();
    // 偶数条件变量
    private static final Condition conditionEven = lock.newCondition();

    public static void main(String[] args) {
        // 线程A，负责打印奇数
        new Thread(() -&gt; {
            lock.lock();  // 加锁
            try {
                while (i &lt;= 100) {
                    if (i % 2 == 1) {
                        // 打印奇数
                        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i++);
                        // 唤醒偶数条件变量等待的线程
                        conditionEven.signal();
                    } else {
                        // 当前线程等待在奇数条件变量上，释放锁
                        conditionOdd.await();
                    }
                }
                // 结束时，唤醒对方线程，防止阻塞
                conditionEven.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();  // 释放锁
            }
        }, &quot;Thread-A&quot;).start();

        // 线程B，负责打印偶数
        new Thread(() -&gt; {
            lock.lock();  // 加锁
            try {
                while (i &lt;= 100) {
                    if (i % 2 == 0) {
                        // 打印偶数
                        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i++);
                        // 唤醒奇数条件变量等待的线程
                        conditionOdd.signal();
                    } else {
                        // 当前线程等待在偶数条件变量上，释放锁
                        conditionEven.await();
                    }
                }
                // 结束时，唤醒对方线程，防止阻塞
                conditionOdd.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();  // 释放锁
            }
        }, &quot;Thread-B&quot;).start();
    }
}
</code></pre>
<h2 id="使用aqs">使用AQS</h2>
<pre><code class="language-java">import java.util.concurrent.locks.AbstractQueuedSynchronizer;

public class AQSSyncExample {
    // 全局变量i，用于计数
    private static int i = 1;

    // 自定义AQS类，负责奇偶数线程的同步
    private static class MyAQS extends AbstractQueuedSynchronizer {
        public MyAQS() {
            // 初始状态为1，表示奇数线程先执行
            setState(1);
        }

        // 打印奇数
        public void printOdd(Runnable printOdd) {
            acquire(1);  // 获取状态为1的许可
            printOdd.run();  // 执行打印操作
            release(0);  // 释放状态为0的许可
        }

        // 打印偶数
        public void printEven(Runnable printEven) {
            acquire(0);  // 获取状态为0的许可
            printEven.run();  // 执行打印操作
            release(1);  // 释放状态为1的许可
        }

        @Override
        protected boolean tryAcquire(int arg) {
            return getState() == arg;  // 获取许可时，判断当前状态是否匹配
        }

        @Override
        protected boolean tryRelease(int arg) {
            setState(arg);  // 释放许可时，设置新的状态
            return true;
        }
    }

    public static void main(String[] args) {
        MyAQS aqs = new MyAQS();

        // 线程A，负责打印奇数
        new Thread(() -&gt; {
            while (i &lt;= 100) {
                aqs.printOdd(() -&gt; {
                    // 打印奇数
                    System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i++);
                });
            }
        }, &quot;Thread-A&quot;).start();

        // 线程B，负责打印偶数
        new Thread(() -&gt; {
            while (i &lt;= 100) {
                aqs.printEven(() -&gt; {
                    // 打印偶数
                    System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i++);
                });
            }
        }, &quot;Thread-B&quot;).start();
    }
}
</code></pre>
<h2 id="使用locksupport">使用LockSupport</h2>
<pre><code class="language-java">import java.util.concurrent.locks.LockSupport;

public class LockSupportExample {
    // 全局变量i，用于计数
    private static int i = 1;
    // 线程引用，用于唤醒对方线程
    private static Thread threadA, threadB;

    public static void main(String[] args) {
        // 线程A，负责打印奇数
        threadA = new Thread(() -&gt; {
            while (i &lt;= 100) {
                if (i % 2 == 1) {
                    // 打印奇数
                    System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i++);
                    // 唤醒线程B
                    LockSupport.unpark(threadB);
                    // 当前线程等待
                    LockSupport.park();
                }
            }
            // 结束时，防止对方线程被永远阻塞
            LockSupport.unpark(threadB);
        }, &quot;Thread-A&quot;);

        // 线程B，负责打印偶数
        threadB = new Thread(() -&gt; {
            while (i &lt;= 100) {
                // 当前线程等待
                LockSupport.park();
                if (i % 2 == 0) {
                    // 打印偶数
                    System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i++);
                    // 唤醒线程A
                    LockSupport.unpark(threadA);
                }
            }
        }, &quot;Thread-B&quot;);

        // 启动线程
        threadA.start();
        threadB.start();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[八大排序算法]]></title>
        <id>https://Vir-Limerence.github.io/post/ba-da-pai-xu-suan-fa/</id>
        <link href="https://Vir-Limerence.github.io/post/ba-da-pai-xu-suan-fa/">
        </link>
        <updated>2024-08-22T11:57:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="插入排序">插入排序</h1>
<h2 id="直接插入排序">直接插入排序</h2>
<p>把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。</p>
<p>时间复杂度：O(N^2) 空间复杂度：O(1) 稳定</p>
<pre><code class="language-Java">public static void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i &lt; n; ++i) {
        int key = arr[i];
        int j = i - 1;

        // 将选中的元素与已排序的元素进行比较，并将较大的元素向后移动
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        // 将选中的元素插入到正确的位置
        arr[j + 1] = key;
    }
}

</code></pre>
<figure data-type="image" tabindex="1"><img src="../images/202201122058377.gif" alt="直接插入排序" loading="lazy"></figure>
<h2 id="希尔排序">希尔排序</h2>
<p>希尔排序在直接排序之前，进行预排列，将某些极端数据更快的排列到数列前面，构成一个接近排列好的序列，最后再进行一次直接插入排序。<strong>预排列的原理也是插入排列，只不过这里的将数组分成了gap组，分别对每一个小组进行插入排序</strong>。希尔排序是对直接插入排序的优化，<strong>当gap &gt; 1时都是预排序</strong>，目的是让数组更接近于有序。<strong>当gap == 1时，数组已经接近有序的了</strong>，这样就会很快。</p>
<p>时间复杂度：O(N*logN) 空间复杂度O(1) 不稳定</p>
<pre><code class="language-Java">public static void shellSort(int[] arr) {
    int n = arr.length;
    for (int gap = n / 2; gap &gt; 0; gap /= 2) {
        for (int i = gap; i &lt; n; i += 1) {
            int key = arr[i];
            int j = i;

            // 将arr[i]插入到前面已经排好的序列中
            while (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = key;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="../images/202201122058905.gif" alt="希尔排序" loading="lazy"></figure>
<h1 id="选择排序">选择排序</h1>
<h2 id="直接选择排序">直接选择排序</h2>
<p>每一次遍历待排序的数据元素从中选出最小（或最大）的一个元素，存放在序列的起始（或者末尾）位置，直到全部待排序的数据元素排完。</p>
<p>时间复杂度：O(N^2) 空间复杂度：O(1) 不稳定</p>
<pre><code class="language-java">public static void selectionSort(int[] arr) {
    int n = arr.length;

    // 外层循环控制排序的轮数
    for (int i = 0; i &lt; n - 1; i++) {
        // 假设当前位置是最小值
        int minIndex = i;
        // 内层循环用于找到最小值的索引
        for (int j = i + 1; j &lt; n; j++) {
            if (arr[j] &lt; arr[minIndex]) {
                minIndex = j; // 更新最小值的索引
            }
        }
        // 将找到的最小值和当前位置的值交换
        if (minIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="../images/202201122058565.gif" alt="直接选择排序" loading="lazy"></figure>
<p>这里我们还可以对直接选择排序做一个优化：<strong>每次遍历待排序数据找出最大和最小的数据</strong>，分别排列到序列起始和末尾。</p>
<pre><code class="language-Java">public static void optimizedSelectionSort(int[] arr) {
    int n = arr.length;

    // 外层循环控制排序的轮数
    for (int i = 0; i &lt; n / 2; i++) {
        int minIndex = i;
        int maxIndex = i;
        // 内层循环用于找到最小值和最大值的索引
        for (int j = i + 1; j &lt; n - i; j++) {
            if (arr[j] &lt; arr[minIndex]) {
                minIndex = j; // 更新最小值的索引
            }
            if (arr[j] &gt; arr[maxIndex]) {
                maxIndex = j; // 更新最大值的索引
            }
        }
        // 将找到的最小值和当前位置的值交换
        if (minIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
        // 将找到的最大值和末尾位置的值交换
        if (maxIndex != n - i - 1) {
            temp = arr[n - i - 1];
            arr[n - i - 1] = arr[maxIndex];
            arr[maxIndex] = temp;
        }
    }
}

</code></pre>
<h2 id="堆排序">堆排序</h2>
<p>堆排序是指利用堆（数据结构）进行选择数据的一种排序算法。基本思想：</p>
<ol>
<li>原则：先将原数组建成堆，需要注意的是升序需要建大堆，降序需要建立小堆</li>
<li>建堆：一个根节点与子节点数据如果不符合大堆结构，那么则对根节点数据进行向下调整，而向下调整的前提是左右子树也符合大堆结构,所以从堆尾数据的根节点位置开始向下调整建大堆</li>
<li>排序：<strong>大堆堆顶数据一定是待排数据中最大的</strong>，将堆顶数据与堆尾数据交换,交换后将除堆尾数据看成新堆，对现堆顶数据进行向下调整成大堆,以此循环直至排列完毕</li>
<li>向下调整：找到子节点中的较大数据节点比较，如果父节点数据比子节点小则交换，直到不符合则停止向下交换，此时再次构成了一个大堆结构</li>
</ol>
<p>时间复杂度：O(N*logN) 空间复杂度O(1) 不稳定</p>
<pre><code class="language-java">// 构建最大堆
public static void buildMaxHeap(int[] arr, int n) {
    for (int i = n / 2 - 1; i &gt;= 0; i--) {
        heapify(arr, n, i);
    }
}

// 堆调整
public static void heapify(int[] arr, int n, int i) {
    int largest = i; // 初始化最大值为根
    int left = 2 * i + 1; // 左子节点
    int right = 2 * i + 2; // 右子节点

    // 如果左子节点比根大，则更新最大值
    if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
    }

    // 如果右子节点比最大值还大，则更新最大值
    if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
    }

    // 如果最大值不是根，交换它们并继续堆调整
    if (largest != i) {
        int swap = arr[i];
        arr[i] = arr[largest];
        arr[largest] = swap;

        // 递归地堆调整子树
        heapify(arr, n, largest);
    }
}

// 堆排序
public static void heapSort(int[] arr) {
    int n = arr.length;
    buildMaxHeap(arr, n);

    // 一个个从堆顶取出元素
    for (int i = n - 1; i &gt;= 0; i--) {
        // 将当前的根（最大值）与最后一个元素交换
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // 堆调整剩下的元素
        heapify(arr, i, 0);
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="../images/202201122058466.gif" alt="堆排序" loading="lazy"></figure>
<h1 id="交换排序">交换排序</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>每次遍历待排序数组，对相邻数据进行比较，不符合排序要求则交换</p>
<p>时间复杂度：O(N^2) 空间复杂度：O(1) 稳定</p>
<pre><code class="language-java">public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i &lt; n - 1; i++) {
        for (int j = 0; j &lt; n - i - 1; j++) {
            // 遍历数组，比较相邻元素，如果顺序错误就交换
            if (arr[j] &gt; arr[j + 1]) {
                // 交换arr[j]和arr[j+1]
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="../images/202201122058114.gif" alt="冒泡排序" loading="lazy"></figure>
<h2 id="快排">快排</h2>
<p>任取待排序元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列。左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值。</p>
<p>时间复杂度：O(N*logN)  空间复杂度：O(logN)  不稳定</p>
<pre><code class="language-java">/*
  left:数组左边界
  right：数组右边界
*/
//递归版本
public void quickSort(int[] arr, int left, int right){
    if(left &lt; right){
        int pos = partition(arr, left, right);
        quickSort(arr, left, pos - 1);
        quickSort(arr, pos + 1, right);
    }
}
//非递归版本
public static void quickSort(int[] arr, int low, int high) {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    stack.push(low);
    stack.push(high);

    while (!stack.isEmpty()) {
        // 弹出高和低索引
        high = stack.pop();
        low = stack.pop();

        // 找到分区点
        int partitionIndex = partition(arr, low, high);

        // 如果分区点的左边有元素，那么将其推入栈中
        if (partitionIndex &gt; low) {
            stack.push(low);
            stack.push(partitionIndex - 1);
        }

        // 如果分区点的右边有元素，那么将其推入栈中
        if (partitionIndex &lt; high) {
            stack.push(partitionIndex + 1);
            stack.push(high);
        }
    }
}

public int partition(int[] arr, int left, int right){
    int base = arr[left];
    while(left &lt; right){
        //从右向左找，比base大，right--
        while(left &lt; right &amp;&amp; arr[right] &gt;= base){
            right--;
        }
        arr[left] = arr[right];
        //从左向右找，比base小，left++
        while(left &lt; right &amp;&amp; arr[left] &lt;= base){
            left++;
        }
        arr[right] = arr[left];       
    }
    arr[left] = base;
    return left;
}
</code></pre>
<figure data-type="image" tabindex="6"><img src="../images/202201122058521.gif" alt="快排" loading="lazy"></figure>
<h1 id="归并排序">归并排序</h1>
<h2 id="归并排序-2">归并排序</h2>
<p>归并排序是建立在归并操作上的一种有效的排序算法，采用分治法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>
<pre><code class="language-java">// 主归并排序函数
public static void mergeSort(int[] array, int left, int right) {
    if (left &lt; right) {
        int middle = (left + right) / 2;

        // 递归地对左半部分排序
        mergeSort(array, left, middle);
        // 递归地对右半部分排序
        mergeSort(array, middle + 1, right);
        // 合并两个已排序的子数组
        merge(array, left, middle, right);
    }
}

// 合并两个已排序的子数组
public static void merge(int[] array, int left, int middle, int right) {
    // 计算子数组的大小
    int n1 = middle - left + 1;
    int n2 = right - middle;

    // 创建临时数组
    int[] leftArray = new int[n1];
    int[] rightArray = new int[n2];

    // 拷贝数据到临时数组
    System.arraycopy(array, left, leftArray, 0, n1);
    System.arraycopy(array, middle + 1, rightArray, 0, n2);

    // 合并临时数组到原数组
    int i = 0, j = 0;
    int k = left;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (leftArray[i] &lt;= rightArray[j]) {
            array[k++] = leftArray[i++];
        } else {
            array[k++] = rightArray[j++];
        }
    }

    // 拷贝剩余的元素
    while (i &lt; n1) {
        array[k++] = leftArray[i++];
    }
    while (j &lt; n2) {
        array[k++] = rightArray[j++];
    }
}

</code></pre>
<figure data-type="image" tabindex="7"><img src="../images/202201122059165.png" alt="归并排序" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="../images/202201122059064.gif" alt="归并排序" loading="lazy"></figure>
<h1 id="计数排序">计数排序</h1>
<p>计数排序是一种非比较排序，又称为鸽巢原理，是对哈希直接定址法的变形应用。在排序数组中找到最大最小的数据，算出对应范围并创建对应长度个数组用来计数，遍历排序数组，根据每个出现的数据值与计数数组下标构建的相对映射关系进行统计数据出现次数，最后将统计的出的数据按次序赋值给原数组。</p>
<pre><code class="language-java">// 计数排序函数
public static void countingSort(int[] array) {
    if (array.length == 0) return;

    // 在单次遍历中找到最大值和最小值
    int max = array[0];
    int min = array[0];
    for (int num : array) {
        if (num &gt; max) {
            max = num;
        }
        if (num &lt; min) {
            min = num;
        }
    }

    // 创建计数数组
    int[] count = new int[max - min + 1];

    // 统计每个元素的出现次数
    for (int num : array) {
        count[num - min]++;
    }

    // 根据计数数组填充排序后的结果数组
    int index = 0;
    for (int i = 0; i &lt; count.length; i++) {
        while (count[i] &gt; 0) {
            array[index++] = i + min;
            count[i]--;
        }
    }
}
</code></pre>
<figure data-type="image" tabindex="9"><img src="../images/202201122059678.gif" alt="计数排序" loading="lazy"></figure>
<h1 id="桶排序">桶排序</h1>
<p>桶排序（Bucket Sort）是一种基于分布的排序算法，适用于数据分布比较均匀的情况。它将数据分到若干个桶中，然后对每个桶内的数据进行排序，最后将桶中的数据合并。</p>
<pre><code class="language-java"> // 桶排序函数
public static void bucketSort(int[] array) {
    if (array.length == 0) return;

    // 1. 找到数据范围
    int min = array[0];
    int max = array[0];
    for (int num : array) {
        if (num &lt; min) min = num;
        if (num &gt; max) max = num;
    }

    // 2. 创建桶
    int bucketCount = (max - min) / array.length + 1;
    List&lt;Integer&gt;[] buckets = new ArrayList[bucketCount];
    for (int i = 0; i &lt; bucketCount; i++) {
        buckets[i] = new ArrayList&lt;&gt;();
    }

    // 3. 将数据分配到桶中
    for (int num : array) {
        int bucketIndex = (num - min) / array.length;
        buckets[bucketIndex].add(num);
    }

    // 4. 对每个桶内的数据进行排序
    for (List&lt;Integer&gt; bucket : buckets) {
        Collections.sort(bucket);
    }

    // 5. 合并桶中的数据
    int index = 0;
    for (List&lt;Integer&gt; bucket : buckets) {
        for (int num : bucket) {
            array[index++] = num;
        }
    }
}
</code></pre>
<h1 id="性能比较">性能比较</h1>
<figure data-type="image" tabindex="10"><img src="../images/202201122059726.png" alt="性能比较" loading="lazy"></figure>
<p>参考链接：https://www.nowcoder.com/discuss/353159614696988672</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例模式]]></title>
        <id>https://Vir-Limerence.github.io/post/dan-li-mo-shi/</id>
        <link href="https://Vir-Limerence.github.io/post/dan-li-mo-shi/">
        </link>
        <updated>2024-08-22T11:28:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="饿汉式单例">饿汉式单例</h1>
<p>饿汉式单例在类加载时就创建实例，因此是线程安全的。</p>
<pre><code class="language-Java">public class EagerSingleton{
    private static final EagerSingleton INSTANCE = new EagerSingleton();
    private EagerSingleton(){
        //私有构造器
    }
    public static EagerSingleton getInstance(){
        return INSTANCE;
    }
}
</code></pre>
<h1 id="懒汉式单例">懒汉式单例</h1>
<p>懒汉式单例在第一次调用<code>getInstance</code>方法时创建实例。这种方式不是线程安全的。在多线程环境下，如果多个线程同时访问<code>getInstance</code>方法并且<code>instance</code>为<code>null</code>，那么多个线程可能会同时通过<code>if (instance == null)</code>这个检查，导致多个线程同时创建实例，这就违反了单例模式的初衷，导致创建了多个实例。</p>
<pre><code class="language-Java">public class LazySingleton{
    private static LazySingleton instance;
    private LazySingleton(){
    //私有构造器
    }
    //多线程下，由于多个线程访问
    public static LazySingleton getInstance(){
        if(instance ==null){
            instance = new LazySingleton();
        }
        return instance;
    }
}
</code></pre>
<h1 id="线程安全的懒汉式单例">线程安全的懒汉式单例</h1>
<p>通过同步<code>getInstance</code>方法来确保线程安全，但这种方式性能较差，因为每次访问都需要同步。</p>
<pre><code class="language-java">public class SynchronizedLazySingleton{
    private static SynchronizedLazySingleton instance;
    private SynchronizedLazySingleton(){
        //私有构造器
    }
    public static synchronized SynchronizedLazySingleton getInstance(){
         if (instance == null) {
            instance = new SynchronizedLazySingleton();
        }
        return instance;
    }
}
</code></pre>
<h1 id="双重检查锁">双重检查锁</h1>
<p>使用双重检查锁机制来确保线程安全，同时提高性能。</p>
<pre><code class="language-Java">public class DoubleCheckedLockingSingleton{
    //使用volatile关键字
	private static volatile DoubleCheckedLockingSingleton instance;
    private DoubleCheckedLockingSingleton(){
        //私有构造器
    }
    public static DoubleCheckedLockingSingleton getInstance(){
        if(instance == null){
            synchronized(DoubleCheckedLockingSingleton.class){
                if(instance ==null){
                    instance =  new DoubleCheckedLockingSingleton();
                }
            }
        }
        return instance;
    }
}
</code></pre>
<h1 id="静态内部类">静态内部类</h1>
<p>Java虚拟机在加载外部类时，并不会立即加载静态内部类，<strong>只有在第一次访问静态内部类的成员时，才会加载该内部类</strong>。由于类加载过程是线程安全的，JVM会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下被正确地加锁和同步。</p>
<pre><code class="language-java">public class BillPughSingle{
    private BillPughSingleton() {
        // 私有构造器
    }
    //使用静态内部类
    private static class SingletonHelper {
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }
    public static BillPughSingleton getInstance() {
        return SingletonHelper.INSTANCE;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[37. Java序列化]]></title>
        <id>https://Vir-Limerence.github.io/post/37-java-xu-lie-hua/</id>
        <link href="https://Vir-Limerence.github.io/post/37-java-xu-lie-hua/">
        </link>
        <updated>2023-06-19T14:36:51.000Z</updated>
        <content type="html"><![CDATA[<p>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p>
<p>将序列化对象写入文件之后，可以从文件中读取出来，并且对他进行反序列化，也就是说，对象的类型信息，对象的数据，还有对象中的数据类型可以用来在内存中新建对象。</p>
<p>整个过程都是java虚拟机（JVM)独立的，也就是说在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。类ObjectInputStream和ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。</p>
<p>ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外：</p>
<pre><code class="language-java">public final void writeObject(Object x) throws IOException
</code></pre>
<p>上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法：</p>
<pre><code class="language-java">public final Object readObject() throws IOException, ClassNotFoundException
</code></pre>
<p>该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[36. Java泛型]]></title>
        <id>https://Vir-Limerence.github.io/post/36-java-fan-xing/</id>
        <link href="https://Vir-Limerence.github.io/post/36-java-fan-xing/">
        </link>
        <updated>2023-06-19T14:18:36.000Z</updated>
        <content type="html"><![CDATA[<p>Java泛型是jdk5引入的一个新特性，泛型提供了编译时类型安全检测机制，允许程序员在编译时检测到非法的类型，泛型的本质是参数化类型，也就是说操作的数据类型被指定为一个参数。</p>
<pre><code class="language-java">假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？
答案是可以使用 Java 泛型。
使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。
</code></pre>
<h1 id="泛型方法">泛型方法</h1>
<p>泛型方法在调用时可以接收不同类型的参数，根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。定义泛型方法的规则：</p>
<ul>
<li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分割）, 该类型参数声明部分在方法返回类型之前</li>
<li>每一个参数类型声明部分包含一个或多个类型参数，参数间使用逗号分隔。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li>
<li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li>
<li>泛型方法体的声明和其它方法一样。注意<strong>类型参数只能代表引用类型参数</strong>，不能是原始类型（像 <strong>int、double、char</strong> 等）。</li>
</ul>
<p>java中泛型标记符：</p>
<ul>
<li><strong>E</strong> - Element (在集合中使用，因为集合中存放的是元素)</li>
<li><strong>T</strong> - Type（Java 类）</li>
<li><strong>K</strong> - Key（键）</li>
<li><strong>V</strong> - Value（值）</li>
<li><strong>N</strong> - Number（数值类型）</li>
<li><strong>？</strong> - 表示不确定的 java 类型</li>
</ul>
<p>下面给出一个示例，演示使用泛型方法打印不同类型的数组.</p>
<pre><code class="language-java">public class GenericMethodTest{
	//定义泛型方法printArray
    public static&lt;E&gt; void printArray(E[] inputArray){
        //输出数组元素
        for(E element : inputArray){
            System.out.printf(&quot;%s &quot;, element);
        }
        System.out.println();
    }
    public static void main(String args[]){
        // 创建不同类型数组： Integer, Double 和 Character
        Integer[] intArray = { 1, 2, 3, 4, 5 };
        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };
 
        System.out.println( &quot;整型数组元素为:&quot; );
        printArray( intArray  ); // 传递一个整型数组
 
        System.out.println( &quot;\n双精度型数组元素为:&quot; );
        printArray( doubleArray ); // 传递一个双精度型数组
 
        System.out.println( &quot;\n字符型数组元素为:&quot; );
        printArray( charArray ); // 传递一个字符型数组
    }
}
</code></pre>
<p><strong>有界的类型参数</strong>：声明有界的类型参数，首先列出类型参数的名称，然后跟上extends关键字，后面紧跟它的上界</p>
<pre><code class="language-java">public class MaximumTest
{
   // 比较三个值并返回最大值
   public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z)
   {                     
      T max = x; // 假设x是初始最大值
      if ( y.compareTo( max ) &gt; 0 ){
         max = y; //y 更大
      }
      if ( z.compareTo( max ) &gt; 0 ){
         max = z; // 现在 z 更大           
      }
      return max; // 返回最大对象
   }
   public static void main( String args[] )
   {
      System.out.printf( &quot;%d, %d 和 %d 中最大的数为 %d\n\n&quot;,
                   3, 4, 5, maximum( 3, 4, 5 ) );
 
      System.out.printf( &quot;%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n&quot;,
                   6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) );
 
      System.out.printf( &quot;%s, %s 和 %s 中最大的数为 %s\n&quot;,&quot;pear&quot;,
         &quot;apple&quot;, &quot;orange&quot;, maximum( &quot;pear&quot;, &quot;apple&quot;, &quot;orange&quot; ) );
   }
}
</code></pre>
<h1 id="泛型类">泛型类</h1>
<p>泛型类和非泛型类的声明类似，在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p>
<pre><code class="language-java">public class Box&lt;T&gt; {
   
  private T t;
 
  public void add(T t) {
    this.t = t;
  }
 
  public T get() {
    return t;
  }
 
  public static void main(String[] args) {
    Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();
    Box&lt;String&gt; stringBox = new Box&lt;String&gt;();
 
    integerBox.add(new Integer(10));
    stringBox.add(new String(&quot;菜鸟教程&quot;));
 
    System.out.printf(&quot;整型值为 :%d\n\n&quot;, integerBox.get());
    System.out.printf(&quot;字符串为 :%s\n&quot;, stringBox.get());
  }
}
</code></pre>
<h1 id="类型通配符">类型通配符</h1>
<p>1、类型通配符一般是使用 <strong>?</strong> 代替具体的类型参数。例如 <strong>List&lt;?&gt;</strong> 在逻辑上是 <strong>List&lt;String&gt;,List&lt;Integer&gt;</strong> 等所有 <strong>List&lt;具体类型实参&gt;</strong> 的父类。</p>
<pre><code class="language-java">public static void getData(List&lt;?&gt; data) {
    System.out.println(&quot;data :&quot; + data.get(0));
}
</code></pre>
<p>2、类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。</p>
<pre><code class="language-java">public static void getUperNumber(List&lt;? extends Number&gt; data) {
	System.out.println(&quot;data :&quot; + data.get(0));
}
</code></pre>
<p>3、类型通配符下限通过形如 <strong>List&lt;? super Number&gt;</strong> 来定义，表示类型只能接受 <strong>Number</strong> 及其上层父类类型，如 <strong>Object</strong> 类型的实例。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[35. Java Object类]]></title>
        <id>https://Vir-Limerence.github.io/post/35-java-object-lei/</id>
        <link href="https://Vir-Limerence.github.io/post/35-java-object-lei/">
        </link>
        <updated>2023-06-19T14:13:59.000Z</updated>
        <content type="html"><![CDATA[<p>java的Obejct类是所有类的父类，也就是说java的所有类都继承了Object类，子类可以使用Object的方法。</p>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2020/10/classes-object.gif" alt="img" loading="lazy"></figure>
<p>Object位于java.lang包中，编译时会自动导入，创建一个类，如果没有明确继承一个父类，那么它会自动继承Object类，成为Object的子类.</p>
<p>Object类可以显式继承，也可以隐式继承</p>
<pre><code class="language-java">//显式继承
public class Runoob extends Object{

}
//隐式继承
public class Runoob {

}
</code></pre>
<h1 id="类的构造函数">类的构造函数</h1>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">构造方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">**Object()**构造一个新对象。</td>
</tr>
</tbody>
</table>
<h1 id="类的方法">类的方法</h1>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-clone.html">protected Object clone()</a>创建并返回一个对象的拷贝</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-equals.html">boolean equals(Object obj)</a>比较两个对象是否相等</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-finalize.html">protected void finalize()</a>当 GC (垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-getclass.html">Class getClass()</a>获取对象的运行时对象的类</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-hashcode.html">int hashCode()</a>获取对象的 hash 值</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-notify.html">void notify()</a>唤醒在该对象上等待的某个线程</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-notifyall.html">void notifyAll()</a>唤醒在该对象上等待的所有线程</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-tostring.html">String toString()</a>返回对象的字符串表示形式</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-wait.html">void wait()</a>让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-wait-timeout.html">void wait(long timeout)</a>让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过参数设置的timeout超时时间。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-object-wait-nanos.html">void wait(long timeout, int nanos)</a>与 wait(long timeout) 方法类似，多了一个 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[34. Java Iterator(迭代器)]]></title>
        <id>https://Vir-Limerence.github.io/post/34-java-iteratordie-dai-qi/</id>
        <link href="https://Vir-Limerence.github.io/post/34-java-iteratordie-dai-qi/">
        </link>
        <updated>2023-06-19T14:04:48.000Z</updated>
        <content type="html"><![CDATA[<p>Java迭代器是java集合框架中的一种机制，提供了一种在<strong>不暴露集合内部实现的情况下遍历集合元素</strong>的方法.</p>
<p>Java迭代器不是一个集合，是用于访问集合的方法，可用于迭代 <a href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a> 和 <a href="https://www.runoob.com/java/java-hashset.html">HashSet</a> 等集合。</p>
<p>Iterator是java迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。</p>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2020/07/ListIterator-Class-Diagram.jpg" alt="img" loading="lazy"></figure>
<p>迭代器 it 的三个基本操作是 next 、hasNext 和 remove。</p>
<p>调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。</p>
<p>调用 it.hasNext() 用于检测集合中是否还有元素。</p>
<p>调用 it.remove() 将迭代器返回的元素删除。</p>
<p>Iterator 类位于 java.util 包中，使用前需要引入它，语法格式如下：</p>
<pre><code class="language-java">import java.util.Iterator;
</code></pre>
<h1 id="获取迭代器">获取迭代器</h1>
<p>集合获取迭代器可以使用iterator方法</p>
<pre><code class="language-java">//创建集合
ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;();
sites.add(&quot;Google&quot;);
sites.add(&quot;Runoob&quot;);
sites.add(&quot;Taobao&quot;);
sites.add(&quot;Zhihu&quot;);
//获取迭代器
Iterator&lt;String&gt; it = sites.iterator();
//输出集合中的第一个元素
System.out.println(it.next());
</code></pre>
<h1 id="循环集合元素">循环集合元素</h1>
<p>让迭代器逐个返回集合中所有元素最简单的方法是使用while循环</p>
<pre><code class="language-java">while(it.hasNext()) {
    System.out.println(it.next());
}
</code></pre>
<h1 id="删除元素">删除元素</h1>
<p>使用remove方法可以删除集合中的元素</p>
<pre><code class="language-java">it.remove();
while(it.hasNext()) {
    Integer i = it.next();
    if(i &lt; 10) {  
    	it.remove();  // 删除小于 10 的元素
    }
}
</code></pre>
<p>java迭代器是一种单向遍历机制，只能从前往后遍历集合中的元素，不能往回遍历。同时，在使用迭代器遍历集合时，不能够直接修改集合中的元素，而是使用迭代器的remov方法来删除当前元素.</p>
]]></content>
    </entry>
</feed>